<!DOCTYPE html>
<html lang="zh-Hans">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="FluentPy Note（1）"/><meta name="keywords" content="Blog" /><link rel="alternate" href="/atom.xml" title="Blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="http://yoursite.com/2018/11/02/python/fluentpy/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" /><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true,"latex":true};
</script>

    <title>FluentPy Note（1） - Blog</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            标签
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            关于
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">FluentPy Note（1）
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2018-11-02
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#python数据模型"><span class="toc-text">python数据模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#如何创建符合python风格的类？"><span class="toc-text">如何创建符合python风格的类？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何使用特殊方法"><span class="toc-text">如何使用特殊方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串表现形式"><span class="toc-text">字符串表现形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义布尔值"><span class="toc-text">自定义布尔值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python中为False"><span class="toc-text">python中为False</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#python特殊方法"><span class="toc-text">python特殊方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#python序列类型"><span class="toc-text">python序列类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#列表推导"><span class="toc-text">列表推导</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#生成器表达式"><span class="toc-text">生成器表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#元组"><span class="toc-text">元组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#元组拆包"><span class="toc-text">元组拆包</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#具名元组"><span class="toc-text">具名元组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#切片"><span class="toc-text">切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对序列使用-和"><span class="toc-text">对序列使用+和*</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#序列的增量赋值"><span class="toc-text">序列的增量赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list-sort-和内置的sorted"><span class="toc-text">list.sort()和内置的sorted()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#当列表不是首选时"><span class="toc-text">当列表不是首选时</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#数组"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#双向队列和其他形式队列"><span class="toc-text">双向队列和其他形式队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字典和集合"><span class="toc-text">字典和集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#泛映射类型"><span class="toc-text">泛映射类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#字典构造"><span class="toc-text">字典构造</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#字典推导"><span class="toc-text">字典推导</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#用setdefault处理找不到的键"><span class="toc-text">用setdefault处理找不到的键</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#映射的弹性键查询"><span class="toc-text">映射的弹性键查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#特殊方法-missing"><span class="toc-text">特殊方法__missing__</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#字典的变种"><span class="toc-text">字典的变种</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#不可变映射类型"><span class="toc-text">不可变映射类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#集合论"><span class="toc-text">集合论</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#集合字面量"><span class="toc-text">集合字面量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dict与散列表"><span class="toc-text">dict与散列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#set与散列表"><span class="toc-text">set与散列表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一等函数"><span class="toc-text">一等函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#高阶函数"><span class="toc-text">高阶函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可调用对象"><span class="toc-text">可调用对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从定位参数到仅限关键字参数"><span class="toc-text">从定位参数到仅限关键字参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内省：获取关于参数的信息"><span class="toc-text">内省：获取关于参数的信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#支持函数式编程的包"><span class="toc-text">支持函数式编程的包</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#functools-partial冻结参数"><span class="toc-text">functools.partial冻结参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用函数实现设计模式"><span class="toc-text">使用函数实现设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#策略模式"><span class="toc-text">策略模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数装饰器和闭包"><span class="toc-text">函数装饰器和闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Python在何时执行装饰器？"><span class="toc-text">Python在何时执行装饰器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用装饰器改进策略模式"><span class="toc-text">使用装饰器改进策略模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量作用域规则"><span class="toc-text">变量作用域规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包"><span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nonlocal声明"><span class="toc-text">nonlocal声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现一个简单的装饰器"><span class="toc-text">实现一个简单的装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#functools-lru-cache做备忘"><span class="toc-text">functools.lru_cache做备忘</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#functools-singledispatch-装饰器"><span class="toc-text">functools.singledispatch 装饰器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参数化装饰器"><span class="toc-text">参数化装饰器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象引用、可变性和垃圾回收"><span class="toc-text">对象引用、可变性和垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#元组的相对不可变性"><span class="toc-text">元组的相对不可变性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#默认做浅复制"><span class="toc-text">默认做浅复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数的参数作为引用时"><span class="toc-text">函数的参数作为引用时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#防御可变参数"><span class="toc-text">防御可变参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#del和垃圾回收"><span class="toc-text">del和垃圾回收</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#符合Python风格的对象"><span class="toc-text">符合Python风格的对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#classmethod与staticmethod"><span class="toc-text">classmethod与staticmethod</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#格式化显示"><span class="toc-text">格式化显示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Python的私有属性和“受保护的”属性"><span class="toc-text">Python的私有属性和“受保护的”属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#覆盖类属性"><span class="toc-text">覆盖类属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#序列的修改、散列、切片"><span class="toc-text">序列的修改、散列、切片</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#切片原理"><span class="toc-text">切片原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#zip函数"><span class="toc-text">zip函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象基类"><span class="toc-text">抽象基类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#标准库中的抽象基类"><span class="toc-text">标准库中的抽象基类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义抽象基类"><span class="toc-text">自定义抽象基类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#虚拟子类"><span class="toc-text">虚拟子类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承的优缺点"><span class="toc-text">继承的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运算符重载"><span class="toc-text">运算符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一元运算符"><span class="toc-text">一元运算符</span></a></li></ol></li></ol>
    </div>
  </div><div class="post-content"><h3 id="python数据模型"><a href="#python数据模型" class="headerlink" title="python数据模型"></a>python数据模型</h3><h4 id="如何创建符合python风格的类？"><a href="#如何创建符合python风格的类？" class="headerlink" title="如何创建符合python风格的类？"></a>如何创建符合python风格的类？</h4><a id="more"></a>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Card = collections.namedtuple(<span class="string">'Card'</span>, [<span class="string">'rank'</span>, <span class="string">'suit'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span>:</span></span><br><span class="line">    <span class="string">"""扑克牌类"""</span></span><br><span class="line"></span><br><span class="line">    ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">11</span>)] + list(<span class="string">'JQKA'</span>)</span><br><span class="line">    suits = <span class="string">'spades diamonds clubs hearts'</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                      <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, position)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._cards[position]</span><br></pre></td></tr></table></figure>
<p>因<code>__getitem__</code>方法把 <strong>[ ]</strong> 操作交给self._cards列表，故FrenchDeck自动支持切片。</p>
<p>实现<code>__getitem__</code>方法，这个类就变成可迭代的；实现<code>__len__</code>，则可调用<code>len()</code></p>
<p>迭代通常是隐式的，譬如一个集合类型没有实现<code>__contains__</code>方法，那么<strong>in</strong>运算符就会按顺序做一次迭代搜索。于是，in可用在FrenchDeck类上。</p>
<p>以上，通过实现<code>__len()__</code>和<code>__getitem__</code>，FrenchDeck就跟Python自有的<strong>序列数据类型</strong>一样，可以体现Python语言的核心特性（例如迭代和切片）。</p>
<h4 id="如何使用特殊方法"><a href="#如何使用特殊方法" class="headerlink" title="如何使用特殊方法"></a>如何使用特殊方法</h4><p>特殊方法是为被解释器调用的，在执行<code>len(my_object)</code>时，若<code>my_object</code>是自定义对象，那么解释器调用其实现的<code>__len__</code></p>
<p>如果是内置类型，如<code>list</code>、<code>str</code>、<code>bytearray</code>，CPython会抄近路…，快得多。</p>
<p>很多时候，特殊方法的调用是隐式的，如</p>
<p><code>for i in x -&gt; iter(x) -&gt; x.__iter__()</code></p>
<p>通常自己的代码无需<strong>直接</strong>使用特殊方法，除非有大量的元编程存在。</p>
<h4 id="字符串表现形式"><a href="#字符串表现形式" class="headerlink" title="字符串表现形式"></a>字符串表现形式</h4><p><code>repr()</code>对应<code>__repr__()</code>，<code>str()</code>对应<code>__str__()</code></p>
<p><code>!r</code>和<code>!s</code>是对应的格式符</p>
<p>两者的区别在于，<code>__str__</code>是在<code>str()</code>函数被使用，或是在print<strong>打印一个对象</strong>时候调用，且其返回的字符串更友好，没有引号<code>(&#39;&#39;)</code></p>
<p>如果只想实现这两个特殊方法中的一个，<code>__repr__</code>是更好的选择。用为如果没有<code>__str__</code>，解释器会用<code>__repr__</code>作为替代。</p>
<h4 id="自定义布尔值"><a href="#自定义布尔值" class="headerlink" title="自定义布尔值"></a>自定义布尔值</h4><p>默认情况下，自定义类的实例总被认为是真，除非这个类对<code>__bool__</code>或者<code>__len__</code></p>
<p>有自己的实现。<code>bool(x)</code>调用<code>x.__bool__()</code>；若未定义<code>__bool__</code>方法，则尝试调用<code>x.__len__()</code>。若返回0，则为False，否则为True。</p>
<h4 id="python中为False"><a href="#python中为False" class="headerlink" title="python中为False"></a>python中为False</h4><ul>
<li>constants defined to be false: <code>None</code> and <code>False</code>.</li>
<li>zero of any numeric type: <code>0</code>, <code>0.0</code>, <code>0j</code>, <code>Decimal(0)</code>, <code>Fraction(0, 1)</code></li>
<li>empty sequences and collections: <code>&#39;&#39;</code>, <code>()</code>, <code>[]</code>, <code>{}</code>, <code>set()</code>, <code>range(0)</code></li>
</ul>
<h4 id="python特殊方法"><a href="#python特殊方法" class="headerlink" title="python特殊方法"></a>python特殊方法</h4><table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">方法名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">字符串/字节序列表示形式</td>
<td style="text-align:center"><code>__repr__  __str__  __format__  __bytes__</code></td>
</tr>
<tr>
<td style="text-align:center">数值转换</td>
<td style="text-align:center"><code>__abs__ __bool__ __complex__ __int__ __float__ __hash__ __index__</code></td>
</tr>
<tr>
<td style="text-align:center">集合模拟</td>
<td style="text-align:center"><code>__len__ __getitem__ __setitem__ __delitem__ __contains__</code></td>
</tr>
<tr>
<td style="text-align:center">迭代模拟</td>
<td style="text-align:center"><code>__iter__ __reversed__ __next__</code></td>
</tr>
<tr>
<td style="text-align:center">可调用模拟</td>
<td style="text-align:center"><code>__call__</code></td>
</tr>
<tr>
<td style="text-align:center">实例创建和销毁</td>
<td style="text-align:center"><code>__new__ __init__ __del__</code></td>
</tr>
<tr>
<td style="text-align:center">属性管理</td>
<td style="text-align:center"><code>__getattr__ __getattribute__ __setattr__ __delattr__ __dir__</code></td>
</tr>
<tr>
<td style="text-align:center">属性描述符</td>
<td style="text-align:center"><code>__get__ __set__ __delete__</code></td>
</tr>
</tbody>
</table>
<p>小结：通过实现特殊方法，自定义数据类型可以表现得跟内置类型一样，从而让我们写出更具表达力的代码——或者说，更具 Python 风格的代码。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="python序列类型"><a href="#python序列类型" class="headerlink" title="python序列类型"></a>python序列类型</h4><ul>
<li>容器序列：list、tuple和collections.deque 这些序列存放不同类型的数据。</li>
<li>扁平序列：str、bytes、bytearray、memoryview和array.array 这些只能容纳一种类型</li>
</ul>
<p>容器序列存放的是任意类型对象的<strong>引用</strong>，而扁平序列存放的是<strong>值</strong>。即，扁平序列其实是一段连续的内存空间。由此可见，扁平序列更加紧凑，但只能存诸如字符、字节和数值这些基础类型。</p>
<p>序列还能按是否被修改分类：</p>
<ul>
<li>可变序列 list、bytearray、array.array、collections.deque和memoryview</li>
<li>不可变序列 tuple、str和bytes</li>
</ul>
<p><img src="https://i.loli.net/2018/10/28/5bd5a17fdbf0a.png" alt="fluentpy1.PNG"></p>
<h4 id="列表推导"><a href="#列表推导" class="headerlink" title="列表推导"></a>列表推导</h4><p>内置函数 ord() ：返回字符的Unicode码，如ord(‘a’)返回97； 与 chr() 效果相反。</p>
<p>列表推导同filter和map比较</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">symbols = <span class="string">'$¢£¥€¤'</span></span><br><span class="line">beyond_ascii = [ord(s) <span class="keyword">for</span> s <span class="keyword">in</span> symbols <span class="keyword">if</span> ord(s) &gt; <span class="number">127</span>]</span><br><span class="line">beyond_ascii = list(filter(<span class="keyword">lambda</span> c: c &gt; <span class="number">127</span>, map(ord, symbols)))</span><br></pre></td></tr></table></figure>
<h4 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h4><p>虽然也能用列表推导来初始化元组、数组和其他序列类型，但生成器是更好的选择。</p>
<p>因为生成器表达式遵守迭代器协议，可逐个产出元素，而不是建立一个完整的列表，节约内存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple(ord(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols)</span><br></pre></td></tr></table></figure>
<h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>可用作不可变的列表，还可以用于<strong>没有字段名的记录</strong>。</p>
<p>若将元组理解为数据记录：元组中的每个元素都存放了记录中一个字段的数据，外加这个字段的位置。</p>
<h5 id="元组拆包"><a href="#元组拆包" class="headerlink" title="元组拆包"></a>元组拆包</h5><p>元组拆包可应用到任何可迭代的对象上（可迭代元素拆包）。</p>
<ul>
<li><p>平行赋值<code>latitude, longitude = (33.9425, -118.408056)</code></p>
</li>
<li><p>还可以用<code>*</code>运算符把可迭代对象拆开作为函数的参数 </p>
<p><code>quotient, remainder = divmod(*t)</code>。</p>
</li>
<li><p>拆包中，_  为占位符。</p>
</li>
<li><p>用<em>来处理剩下的元素 ` a, b, </em>rest = range(5)`</p>
</li>
<li><p>嵌套元组拆包</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, cc, pop, (latitude, longitude) <span class="keyword">in</span> metro_areas:</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="具名元组"><a href="#具名元组" class="headerlink" title="具名元组"></a>具名元组</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Card = collections.namedtuple(<span class="string">'Card'</span>, [<span class="string">'rank'</span>, <span class="string">'suit'</span>])</span><br></pre></td></tr></table></figure>
<p>namedtuple构建的类的实例所消耗的内存跟元组一样，因字段名都被存在对应的类里。</p>
<p>这个实例跟普通的对象实例比起来也要小一些，因Python不会用<code>__dict__</code>来存放这些实例的属性。</p>
<p>具名元组的专有属性：</p>
<ul>
<li><code>_fields</code>属性是一个包含这个类所有字段的元组</li>
<li><code>_make()</code>通过接受一个可迭代对象来生成这个类的一个实例</li>
<li><code>_asdict()</code>把具名元组以collections.OrderedDict形式返回，友好呈现数据</li>
</ul>
<h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p><code>s[a:b:c]</code>形式对s在a和b之间以c为间隔取值。c也可以为负，意味反向取值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'bicycle'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::<span class="number">3</span>]</span><br><span class="line"><span class="string">'bye'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::<span class="number">-1</span>]</span><br><span class="line"><span class="string">'elcycib'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::<span class="number">-2</span>]</span><br><span class="line"><span class="string">'eccb'</span></span><br></pre></td></tr></table></figure>
<p>可以把切片放在赋值语句左边，或把它作为del操作的对象。</p>
<h4 id="对序列使用-和"><a href="#对序列使用-和" class="headerlink" title="对序列使用+和*"></a>对序列使用+和*</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l * <span class="number">5</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>注意在<code>l*n</code>语句中，当序列 <code>l</code>里的元素是对其他可变对象的引用时：</p>
<p>如 <code>my_list= [[]]*3</code>，此时得到的列表里包含的其实是三个引用，而这三个引用指向的是用一个列表。</p>
<h4 id="序列的增量赋值"><a href="#序列的增量赋值" class="headerlink" title="序列的增量赋值"></a>序列的增量赋值</h4><p>+=背后的特殊方法是<code>__iadd__</code>（“就地加法”）。但如果一个类没有实现这个方法的话，Python会退一步调用<code>__add__</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a += b</span><br></pre></td></tr></table></figure>
<p>如果 a 实现了<code>__iadd__</code> 方法，就会调用这个方法。同时对可变序列（例如 list、bytearray 和 array.array）来说，a 会就地改动，就像调用了 a.extend(b) 一样。但是如果 a 没有实现<code>__iadd__</code> 的话，a+= b 这个表达式的效果就变得跟 a = a + b 一样了：首先计算 a +b，得到一个新的对象，然后赋值给 a。</p>
<h4 id="list-sort-和内置的sorted"><a href="#list-sort-和内置的sorted" class="headerlink" title="list.sort()和内置的sorted()"></a>list.sort()和内置的sorted()</h4><p>参数：reversed 、key</p>
<p>可用bisect管理已排序的序列</p>
<h4 id="当列表不是首选时"><a href="#当列表不是首选时" class="headerlink" title="当列表不是首选时"></a>当列表不是首选时</h4><ul>
<li>存放1000万个浮点数，数组（array）的效率要高得多，因数组背后存放的不是float对象，而是数字的机器翻译，也就是字节表述。</li>
<li>如果需要频繁对序列做先进先出的操作，deque（双端队列）的速度更快。</li>
<li>若检查一个元素是否出现的操作频率很高，用set更合适。</li>
</ul>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>如果需要一个只包含数字的列表，那么 array.array 比 list 更高效。数组支持所有跟可变序列有关的操作，包括 .pop 、.insert 和 .extend。另外，数组还提供从文件读取和存入文件的更快的方法，如 .frombytes 和 .tofile。</p>
<p>创建数组需要指定类型码，如 </p>
<ul>
<li>b 类型码代表有符号的字符（signed char）</li>
<li>d 代表双精度实数</li>
<li>h 代表短整型有符号整数</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">floats = array(<span class="string">'d'</span>, (random() <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span> ** <span class="number">7</span>)))</span><br><span class="line">print(floats[<span class="number">-1</span>])</span><br><span class="line"><span class="comment"># 存</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'output/test/floats.bin'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    floats.tofile(fp)</span><br><span class="line"></span><br><span class="line">floats2 = array(<span class="string">'d'</span>)</span><br><span class="line"><span class="comment"># 取</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'output/test/floats.bin'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    floats2.fromfile(fp, <span class="number">10</span> ** <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">print(floats2[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>
<p>数组排序，需新建一个数组<code>a = array.array(a.typecode, sorted(a))</code></p>
<p>memoryview是内置类，它能让用户在不复制内容的情况下操作同一个数组的不同切片。</p>
<h5 id="双向队列和其他形式队列"><a href="#双向队列和其他形式队列" class="headerlink" title="双向队列和其他形式队列"></a>双向队列和其他形式队列</h5><p>列表利用 .append 和 .pop(0) 合起来，就能模拟队列“先进先出”特点，但是删除列表的第一个元素（在第一个元素前插入元素）之类的操作很耗时，因这些操作牵扯移动列表里所有元素。</p>
<p>collections.deque（双向队列）是一个线程安全、可以快速从两端添加或删除元素的数据类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq = deque(range(<span class="number">10</span>), maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.rotate(<span class="number">3</span>) <span class="comment"># 右移</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.rotate(<span class="number">-4</span>) <span class="comment"># 左移</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.appendleft(<span class="number">-1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.extend([<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.extendleft([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], maxlen=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>双向队列也付出了一些代价，从队列中间删除元素的操作会慢一些，因为它只对在头尾的操作进行了优化。</p>
<h3 id="字典和集合"><a href="#字典和集合" class="headerlink" title="字典和集合"></a>字典和集合</h3><h4 id="泛映射类型"><a href="#泛映射类型" class="headerlink" title="泛映射类型"></a>泛映射类型</h4><p><img src="https://i.loli.net/2018/10/29/5bd6aca589c06.png" alt="fluentpy2.PNG"></p>
<p>以上是形式化的文档，定义了最基本的接口，还可以用来跟 isinstance 做类型判断。非抽象映射类型一般直接对 dict 或是 collections.User.Dict 进行扩展。</p>
<p>标准库中所有的映射类型都是利用<strong>dict</strong>来实现的，因此有共同的限制，即只有<strong>可散列</strong>的数据类型才能用作这些映射里的键（值不需要可散列）。</p>
<p>什么是可散列的？</p>
<p>如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变的。而且这个对象需要实现<code>__hash__()</code>，还要有<code>__qe__()</code>。如果两个可散列的对象是相等的，散列值一定相等。</p>
<p>原子不可变数据类型（str、bytes 和数值类型）都是可散列类型，frozenset 也是可散列的，因为根据其定义，frozenset 里只能容纳可散列类型。元组的话，只有当一个元组包含的所有元素都是可散列类型的情况下，它才是可散列的。</p>
<h5 id="字典构造"><a href="#字典构造" class="headerlink" title="字典构造"></a>字典构造</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = dict(one=<span class="number">1</span>, two=<span class="number">2</span>, three=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = &#123;<span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>, <span class="string">'three'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = dict(zip([<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = dict([(<span class="string">'two'</span>, <span class="number">2</span>), (<span class="string">'one'</span>, <span class="number">1</span>), (<span class="string">'three'</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = dict(&#123;<span class="string">'three'</span>: <span class="number">3</span>, <span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b == c == d == e</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h5 id="字典推导"><a href="#字典推导" class="headerlink" title="字典推导"></a>字典推导</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">country_code = &#123;country: code <span class="keyword">for</span> code, country <span class="keyword">in</span> DIAL_CODES&#125;</span><br></pre></td></tr></table></figure>
<h5 id="用setdefault处理找不到的键"><a href="#用setdefault处理找不到的键" class="headerlink" title="用setdefault处理找不到的键"></a>用setdefault处理找不到的键</h5><p>可以用 <code>d.get(k, default)</code> 来代替 <code>d[k]</code>，给找不到的键一个默认的返回值（这比处理 KeyError 要方便不少）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_dict.setdefault(key, []).append(new_value)</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> my_dict:</span><br><span class="line">	my_dict[key] = []</span><br><span class="line">my_dict[key].append(new_value)</span><br></pre></td></tr></table></figure>
<h5 id="映射的弹性键查询"><a href="#映射的弹性键查询" class="headerlink" title="映射的弹性键查询"></a>映射的弹性键查询</h5><p>有时候为了方便起见，就算某个键在映射里不存在，我们也希望在通过这个键读取值的时候能得到一个默认值。</p>
<p>一个是通过 defaultdict 这个类型而不是普通的 dict，另一个是给自己定义一个 dict 的子类，然后在子类中实现 <code>__missing__</code> 方法。</p>
<p>对于defaultdict:</p>
<p>如 dd = defaultdict(list)，这里将 list 指定为 default_factory，它是defaultdict用来生成默认值的实例属性，需要存放可调用对象。</p>
<p>这里，若<code>dd[&#39;new_key&#39;]</code>中键 ‘new_key’ 不存在的话，按以下处理：</p>
<ol>
<li>调用 list() 来建立一个新列表。</li>
<li>把这个新列表作为值，’new-key’ 作为它的键，放到 dd 中。</li>
<li>返回这个列表的引用。</li>
</ol>
<p>defaultdict 里的 default_factory 只会在<code>__getitem__</code>里被调用，也就是dd[k]会调用default_factory，而dd.get(k)则会返回None。</p>
<p>所有这一切背后的功臣其实是特殊方法 <code>__missing__</code>。它会在defaultdict 遇到找不到的键的时候调用 default_factory，而实际上这个特性是所有映射类型都可以选择去支持的。</p>
<h5 id="特殊方法-missing"><a href="#特殊方法-missing" class="headerlink" title="特殊方法__missing__"></a>特殊方法<code>__missing__</code></h5><p>如果有一个类继承了 dict，然后这个继承类提供了<code>__missing__</code>方法，那么在 <code>__getitem__</code> 碰到找不到的键的时候，Python 就会自动调用它，而不是抛出一个 KeyError 异常。</p>
<p><code>__missing__</code> 方法只会被 <code>__getitem__</code> 调用（比如在表达式 d[k] 中）</p>
<h5 id="字典的变种"><a href="#字典的变种" class="headerlink" title="字典的变种"></a>字典的变种</h5><ul>
<li><p>collections.OrderedDict</p>
<p>这个类型添加键时会保持顺序，因此键的迭代次序总是一致的。</p>
</li>
<li><p>collections.ChainMap</p>
<p>该类型可容纳数个不同的映射对象，然后查找时，会当作一个整体查找，直到键被找到为止。如Python变量查找规则：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line">pylookup = ChainMap(locals(), globals(), vars(builtins))</span><br></pre></td></tr></table></figure>
<ul>
<li><p>collections.Counter</p>
<p>这个类会给键设置一个整数计数器。更新键时会增加这个计数器，可用来计数。</p>
</li>
</ul>
<h5 id="不可变映射类型"><a href="#不可变映射类型" class="headerlink" title="不可变映射类型"></a>不可变映射类型</h5><p>types 模块中引入了一个封装类名叫MappingProxyType。如果给这个类一个映射，它会返回一个只读的映射视图。虽然是个只读视图，但是它是动态的。这意味着如果对原映射做出了改动，我们通过这个视图可以观察到，但是无法通过这个视图对原映射做出修改。</p>
<h4 id="集合论"><a href="#集合论" class="headerlink" title="集合论"></a>集合论</h4><p>集合中的元素必须是可散列的，set类型本身是不可散列的，但是frozenset可以。因此可以创建一个包含不同frozenset的set。</p>
<p>集合中缀表达式： a | b : 并集、 a &amp; b : 交集、a - b : 差集</p>
<p>如：needles 的元素在 haystack 里出现的次数，两个变量都是 set 类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">found = len(needles &amp; haystack)</span><br></pre></td></tr></table></figure>
<p>以上代码可以用在任何可迭代对象上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">found = len(set(needles) &amp; set(haystack))</span><br><span class="line"><span class="comment"># 另一种写法：</span></span><br><span class="line">found = len(set(needles).intersection(haystack))</span><br></pre></td></tr></table></figure>
<h5 id="集合字面量"><a href="#集合字面量" class="headerlink" title="集合字面量"></a>集合字面量</h5><p>集合字面量 ： {…}，空集：set()</p>
<p>集合推导 <code>{func(i) for i in iterable}</code></p>
<h5 id="dict与散列表"><a href="#dict与散列表" class="headerlink" title="dict与散列表"></a>dict与散列表</h5><p>由于字典使用了散列表，而散列表又必须是稀疏的，这导致它在空间上的效率低下。</p>
<p>用<br>元组取代字典就能节省空间的原因有两个：其一是避免了散列表所耗费的空间，其二是无需把记录中字段的名字在每个元素里都存一遍。</p>
<h5 id="set与散列表"><a href="#set与散列表" class="headerlink" title="set与散列表"></a>set与散列表</h5><p>set 和 frozenset 的实现也依赖散列表，但在它们的散列表里存放的只有元素的引用（就像在字典里只存放键而没有相应的值）。在 set 加入到 Python 之前，我们都是把字典加上无意义的值当作集合来用的。</p>
<h3 id="一等函数"><a href="#一等函数" class="headerlink" title="一等函数"></a>一等函数</h3><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>接受函数为参数，或者把函数作为结果返回的函数是高阶函数。</p>
<h4 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h4><ul>
<li>用户定义的函数：使用 def 语句或 lambda 表达式创建。</li>
<li>内置函数：使用 C 语言（CPython）实现的函数，如 len 或 time.strftime。</li>
<li>内置方法：使用 C 语言实现的方法，如 dict.get。</li>
<li>方法：在类的定义体中定义的函数。</li>
<li>类：调用类时会运行类的<code>__new__</code>方法创建一个实例，然后运行<code>__init__</code> 方法，初始化实例，最后把实例返回给调用方。因为 Python没有 new 运算符，所以调用类相当于调用函数。</li>
<li>类的实例：如果类定义了 <code>__call__</code> 方法，那么它的实例可以作为函数调用。</li>
<li>生成器函数：使用yield关键字的函数或方法。调用生成器函数返回的是生成器对象。</li>
</ul>
<p><code>callable()</code>判断对象是否可以调用。</p>
<h4 id="从定位参数到仅限关键字参数"><a href="#从定位参数到仅限关键字参数" class="headerlink" title="从定位参数到仅限关键字参数"></a>从定位参数到仅限关键字参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tag</span><span class="params">(name, *content, cls=None, **attrs)</span>:</span></span><br><span class="line">	...</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 调用</span></span><br><span class="line">tag(<span class="string">'br'</span>)</span><br><span class="line">tag(<span class="string">'p'</span>,<span class="string">'hello'</span>)</span><br><span class="line">tag(<span class="string">'p'</span>,<span class="string">'hello'</span>,id=<span class="number">33</span>)</span><br><span class="line">tag(<span class="string">'p'</span>,<span class="string">'hello'</span>,<span class="string">'world'</span>,cls=<span class="string">'sidebar'</span>)</span><br><span class="line">tag(content=<span class="string">'testing'</span>,name=<span class="string">'img'</span>)</span><br><span class="line">my_tag = &#123;<span class="string">'name'</span>: <span class="string">'img'</span>, <span class="string">'title'</span>: <span class="string">'Sunset Boulevard'</span>,</span><br><span class="line">	<span class="string">'src'</span>: <span class="string">'sunset.jpg'</span>, <span class="string">'cls'</span>: <span class="string">'framed'</span>&#125;</span><br><span class="line">tag(**my_tag)</span><br></pre></td></tr></table></figure>
<p>以上 cls参数 只能通过关键字指定，它一定不会捕获未命名的定位参数。</p>
<p>定义函数时若想指定关键字参数，要把它们放到有 <em> 的参数后面。如果不想支持数量不定的定位参数，但想支持仅限关键字参数，在签名中放一个 </em> ，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a,*,b)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> a,b</span><br><span class="line">print(f(<span class="number">1</span>,b=<span class="number">2</span>))</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>注意，仅限关键字参数不一定要有默认值，可以像上例中 b 那样，强制必须传入实参。</p>
<h4 id="内省：获取关于参数的信息"><a href="#内省：获取关于参数的信息" class="headerlink" title="内省：获取关于参数的信息"></a>内省：获取关于参数的信息</h4><p>与内省有关的函数对象</p>
<ul>
<li><code>__defaults__</code>属性，它的值是一个元组，保存着定位参数和关键字参数的默认值。</li>
<li><code>__kwdefaults__</code>属性，保存仅限关键字参数默认值。</li>
<li><code>__code__</code>属性，保存参数的名称，它的值是一个code对象的引用，自身也有很多属性。</li>
</ul>
<p>相关模块：inspect</p>
<h4 id="支持函数式编程的包"><a href="#支持函数式编程的包" class="headerlink" title="支持函数式编程的包"></a>支持函数式编程的包</h4><p>operator模块为多个算术运算符提供了对应的函数，从而避免编写平凡的匿名函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line">	<span class="keyword">return</span> reduce(mul, range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>operator模块中的itemgetter、attrgetter能从序列中取出元素或读取对象属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> city <span class="keyword">in</span> sorted(metro_data, key=itemgetter(<span class="number">1</span>)):</span><br><span class="line">	print(city)</span><br><span class="line"></span><br><span class="line">cc_name = itemgetter(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> city <span class="keyword">in</span> metro_data:</span><br><span class="line">	print(cc_name(city))</span><br></pre></td></tr></table></figure>
<p>itemgetter使用[]运算符，因此它不仅支持序列，还支持映射和任何实现<code>__getitem__</code>方法的类。</p>
<p>attrgetter 与 itemgetter 作用类似，它创建的函数根据名称提取对象的属性。如果把多个属性名传给 attrgetter，它也会返回提取的值构成的元组。此外，如果参数名中包含 .（点号），attrgetter 会深入嵌套对象，获取指定的属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> attrgetter</span><br><span class="line">name_lat = attrgetter(<span class="string">'name'</span>, <span class="string">'coord.lat'</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> city <span class="keyword">in</span> sorted(metro_areas, key=attrgetter(<span class="string">'coord.lat'</span>)): </span><br><span class="line">	print(name_lat(city))</span><br></pre></td></tr></table></figure>
<h5 id="functools-partial冻结参数"><a href="#functools-partial冻结参数" class="headerlink" title="functools.partial冻结参数"></a>functools.partial冻结参数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple = partial(mul, <span class="number">3</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple(<span class="number">7</span>) </span><br><span class="line"><span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 partial 构建一个便利的 Unicode 规范化函数</span></span><br><span class="line">nfc = functools.partial(unicodedata.normalize, <span class="string">'NFC'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="使用函数实现设计模式"><a href="#使用函数实现设计模式" class="headerlink" title="使用函数实现设计模式"></a>使用函数实现设计模式</h3><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span> <span class="comment"># 上下文</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, customer, cart, promotion=None)</span>:</span></span><br><span class="line">        self.customer = customer</span><br><span class="line">        self.cart = list(cart)</span><br><span class="line">        self.promotion = promotion</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">    	<span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'__total'</span>):</span><br><span class="line">    		self.__total = sum(item.total() <span class="keyword">for</span> item <span class="keyword">in</span> self.cart)</span><br><span class="line">    	<span class="keyword">return</span> self.__total</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">due</span><span class="params">(self)</span>:</span></span><br><span class="line">    	<span class="keyword">if</span> self.promotion <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">    		discount = <span class="number">0</span></span><br><span class="line">    	<span class="keyword">else</span>:</span><br><span class="line">    		discount = self.promotion(self) </span><br><span class="line">    	<span class="keyword">return</span> self.total() - discount</span><br><span class="line">    </span><br><span class="line">promos = [func <span class="keyword">for</span> name, func <span class="keyword">in</span> inspect.getmembers(promotions, inspect.isfunction)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""选择可用的最佳折扣</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br><span class="line"></span><br><span class="line"><span class="comment"># promotions.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="函数装饰器和闭包"><a href="#函数装饰器和闭包" class="headerlink" title="函数装饰器和闭包"></a>函数装饰器和闭包</h3><p>装饰器是可调用对象，其参数是另一个函数（被装饰的函数）。装饰器可能会处理被装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用的对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">'running target()'</span>)</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">	print(<span class="string">'running target()'</span>)</span><br><span class="line">target = decorate(target)</span><br></pre></td></tr></table></figure>
<p>严格来说，装饰器只是语法糖。</p>
<h4 id="Python在何时执行装饰器？"><a href="#Python在何时执行装饰器？" class="headerlink" title="Python在何时执行装饰器？"></a>Python在何时执行装饰器？</h4><p>函数装饰器在导入模块时<strong>立即执行</strong>，而被装饰的函数只在明确调用时运行。这突出了导入时和运行时的区别。</p>
<h4 id="使用装饰器改进策略模式"><a href="#使用装饰器改进策略模式" class="headerlink" title="使用装饰器改进策略模式"></a>使用装饰器改进策略模式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">promos = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">promotion</span><span class="params">(promo_func)</span>:</span></span><br><span class="line">    promos.append(promo_func)</span><br><span class="line">    <span class="keyword">return</span> promo_func</span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity_promo</span><span class="params">(order)</span>:</span>  <span class="comment"># 第一个具体策略</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item_promo</span><span class="params">(order)</span>:</span>  <span class="comment"># 第二个具体策略</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_order_promo</span><span class="params">(order)</span>:</span>  <span class="comment"># 第三个具体策略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span> </span><br><span class="line">	<span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br></pre></td></tr></table></figure>
<h4 id="变量作用域规则"><a href="#变量作用域规则" class="headerlink" title="变量作用域规则"></a>变量作用域规则</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(a)</span>:</span></span><br><span class="line"><span class="meta">... </span>print(a)</span><br><span class="line"><span class="meta">... </span>print(b)</span><br><span class="line"><span class="meta">... </span>b = <span class="number">9</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">UnboundLocalError: local variable <span class="string">'b'</span> referenced before assignment</span><br></pre></td></tr></table></figure>
<p>Python不要求声明变量，但是假定在函数定义体中的变量是<strong>局部变量</strong>，参数也是。</p>
<h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包是指<strong>延伸了作用域</strong>的函数，其中包含函数定义体中引用、但是<strong>不在定义体</strong>中定义的<strong>非全局变量</strong>。</p>
<p><a href="https://i.loli.net/2018/10/30/5bd808be8a72b.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/10/30/5bd808be8a72b.png" alt="closure.PNG"></a></p>
<p>综上，闭包是一种函数，它会保留定义函数时存在的自由变量的绑定。这样调用函数时，虽然定义作用域不可用了，但仍能使用那些绑定。</p>
<h4 id="nonlocal声明"><a href="#nonlocal声明" class="headerlink" title="nonlocal声明"></a>nonlocal声明</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line">    <span class="keyword">return</span> averager</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = make_averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">UnboundLocalError: local variable <span class="string">'count'</span> referenced before assignment</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> count, total</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>
<h4 id="实现一个简单的装饰器"><a href="#实现一个简单的装饰器" class="headerlink" title="实现一个简单的装饰器"></a>实现一个简单的装饰器</h4><p>装饰器的典型行为：把被装饰的函数替换成新函数，二者接受相同的参数，而且（通常）返回被装饰函数本该返回的值，同时做些额外的操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args)</span>:</span> </span><br><span class="line">        t0 = time.perf_counter()</span><br><span class="line">        result = func(*args) </span><br><span class="line">        elapsed = time.perf_counter() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_str = <span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args)</span><br><span class="line">        print(<span class="string">'[%0.8fs] %s(%s) -&gt; %r'</span> % (elapsed, name, arg_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> clocked</span><br></pre></td></tr></table></figure>
<p>以上实现的装饰器有缺点：遮盖了被装饰函数的<code>__name__</code>和<code>__doc__</code>属性。</p>
<p>可使用<code>functools.wraps</code> 装饰器把相关的属性从 func 复制到 clocked 中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        t0 = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        elapsed = time.time() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_lst = []</span><br><span class="line">        <span class="keyword">if</span> args:</span><br><span class="line">        arg_lst.append(<span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args))</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">        pairs = [<span class="string">'%s=%r'</span> % (k, w) <span class="keyword">for</span> k, w <span class="keyword">in</span> sorted(kwargs.items())]</span><br><span class="line">        arg_lst.append(<span class="string">', '</span>.join(pairs))</span><br><span class="line">        arg_str = <span class="string">', '</span>.join(arg_lst)</span><br><span class="line">        print(<span class="string">'[%0.8fs] %s(%s) -&gt; %r '</span> % (elapsed, name, arg_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="comment"># 返回一个被装饰过的函数</span></span><br><span class="line">	<span class="keyword">return</span> clocked</span><br></pre></td></tr></table></figure>
<p>Python 内置了三个用于装饰方法的函数：<code>property</code>、<code>classmethod</code> 和<code>staticmethod</code>。</p>
<p>另一个常见的装饰器是 <code>functools.wraps</code>，它的作用是协助构建行为<br>良好的装饰器。标准库中最值得关注的两个装饰器是 <code>lru_cache</code> 和全新的 <code>singledispatch</code>。</p>
<h5 id="functools-lru-cache做备忘"><a href="#functools-lru-cache做备忘" class="headerlink" title="functools.lru_cache做备忘"></a>functools.lru_cache做备忘</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@functools.lru_cache() </span></span><br><span class="line"><span class="meta">@clock </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">    	<span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n<span class="number">-2</span>) + fibonacci(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">$ python3 fibo_demo_lru.py</span><br><span class="line">[0.00000119s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000119s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00010800s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000787s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00016093s] fibonacci(4) -&gt; 3</span><br><span class="line">[0.00001216s] fibonacci(5) -&gt; 5</span><br><span class="line">[0.00025296s] fibonacci(6) -&gt; 8</span><br></pre></td></tr></table></figure>
<h5 id="functools-singledispatch-装饰器"><a href="#functools-singledispatch-装饰器" class="headerlink" title="functools.singledispatch 装饰器"></a>functools.singledispatch 装饰器</h5><p>它可以把整体方案拆分成多个模块，甚至可以为你无法修改的类提供专门的函数。使用<code>@singledispatch</code>装饰的普通函数会变成泛函数（generic function）：根据第一个参数的类型，以不同方式执行相同操作的一组函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @singledispatch标记处理object类型的基函数</span></span><br><span class="line"><span class="meta">@singledispatch </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">htmlize</span><span class="params">(obj)</span>:</span></span><br><span class="line">    content = html.escape(repr(obj))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;pre&gt;&#123;&#125;&lt;/pre&gt;'</span>.format(content)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmlize.register(str) </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(text)</span>:</span> </span><br><span class="line">    content = html.escape(text).replace(<span class="string">'\n'</span>, <span class="string">'&lt;br&gt;\n'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;p&gt;&#123;0&#125;&lt;/p&gt;'</span>.format(content)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmlize.register(numbers.Integral) </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;pre&gt;&#123;0&#125; (0x&#123;0:x&#125;)&lt;/pre&gt;'</span>.format(n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 叠放多个register装饰器，让同一个函数支持不同类型</span></span><br><span class="line"><span class="meta">@htmlize.register(tuple) </span></span><br><span class="line"><span class="meta">@htmlize.register(abc.MutableSequence)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(seq)</span>:</span></span><br><span class="line">    inner = <span class="string">'&lt;/li&gt;\n&lt;li&gt;'</span>.join(htmlize(item) <span class="keyword">for</span> item <span class="keyword">in</span> seq)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;ul&gt;\n&lt;li&gt;'</span> + inner + <span class="string">'&lt;/li&gt;\n&lt;/ul&gt;'</span></span><br></pre></td></tr></table></figure>
<p>以上各个专门函数使用@base_function.register(type)装饰。专门函数的名称无关紧要；使用 _ 简单明了。</p>
<p>只要可能，注册的专门函数应该处理抽象基类（如 numbers.Integral和 abc.MutableSequence），不要处理具体实现（如 int 和list）。这样，代码支持的兼容类型更广泛。</p>
<h4 id="参数化装饰器"><a href="#参数化装饰器" class="headerlink" title="参数化装饰器"></a>参数化装饰器</h4><p>怎么让装饰器接受其他参数？</p>
<p>创建一个装饰器工厂函数，返回装饰器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">registry = set()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(active=True)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span> </span><br><span class="line">        print(<span class="string">'running register(active=%s)-&gt;decorate(%s)'</span> % (active, func))</span><br><span class="line">        <span class="keyword">if</span> active: </span><br><span class="line">        	registry.add(func)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        	registry.discard(func) </span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> decorate</span><br></pre></td></tr></table></figure>
<h3 id="对象引用、可变性和垃圾回收"><a href="#对象引用、可变性和垃圾回收" class="headerlink" title="对象引用、可变性和垃圾回收"></a>对象引用、可变性和垃圾回收</h3><p>== 运算符比较两个对象的值（对象中保存的数据），而 is 比较对象的标识。</p>
<h4 id="元组的相对不可变性"><a href="#元组的相对不可变性" class="headerlink" title="元组的相对不可变性"></a>元组的相对不可变性</h4><p>元组与多数Python容器（列表、字典、集）一样，保存的是对象的引用。元组的不可变性其实是指tuple数据结构的物理内容（即保存的引用）不可变，与引用的对象无关。</p>
<p>元组的相对不变性也是，有些元组不可散列的原因。</p>
<h4 id="默认做浅复制"><a href="#默认做浅复制" class="headerlink" title="默认做浅复制"></a>默认做浅复制</h4><p>复制列表（或多数内置的可变集合）最简单的方式是使用内置类型的构造方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">3</span>, [<span class="number">55</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = list(l1) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2</span><br><span class="line">[<span class="number">3</span>, [<span class="number">55</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 == l1 </span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 <span class="keyword">is</span> l1 </span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>以上看出，二者指代不同的对象。对列表和其他可变序列来说，还能使用简洁的<code>l2=l1[:]</code>语句来创建副本。</p>
<p>然而，构造方法或<code>[:]</code>做的是浅复制（即复制了最外层的容器，副本中的元素是源容器中元素的引用）。如果所有的元素都是不可变的，那么这样没问题。但是，如果有可变元素，可能就会导致意想不到的问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1 = Bus([<span class="string">'Alice'</span>, <span class="string">'Bill'</span>, <span class="string">'Claire'</span>, <span class="string">'David'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2 = copy.copy(bus1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3 = copy.deepcopy(bus1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(bus1), id(bus2), id(bus3)</span><br><span class="line">(<span class="number">4301498296</span>, <span class="number">4301499416</span>, <span class="number">4301499752</span>) ➊</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.drop(<span class="string">'Bill'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers</span><br><span class="line">[<span class="string">'Alice'</span>, <span class="string">'Claire'</span>, <span class="string">'David'</span>] ➋</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(bus1.passengers), id(bus2.passengers), id(bus3.passengers)</span><br><span class="line">(<span class="number">4302658568</span>, <span class="number">4302658568</span>, <span class="number">4302657800</span>) ➌</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.passengers</span><br><span class="line">[<span class="string">'Alice'</span>, <span class="string">'Bill'</span>, <span class="string">'Claire'</span>, <span class="string">'David'</span>] ➍</span><br></pre></td></tr></table></figure>
<p>浅复制，不同引用，同一个对象；深复制，不同引用，不同对象。</p>
<h4 id="函数的参数作为引用时"><a href="#函数的参数作为引用时" class="headerlink" title="函数的参数作为引用时"></a>函数的参数作为引用时</h4><p>Python 唯一支持的参数传递模式是共享传参。共享传参指函数的各个形式参数获得实参中各个引用的副本。也就是说，函数内部的形参是实参的别名。</p>
<p>Java 的引用类型是这样，基本类型按值传参（函数得到参数的副本）。</p>
<p>函数可能会修改接收到的任何可变对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b)</span>:</span></span><br><span class="line"><span class="meta">... </span>a += b</span><br><span class="line"><span class="meta">... </span><span class="keyword">return</span> a</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(x, y)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y </span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(a, b)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b </span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = (<span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(t, u)</span><br><span class="line">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t, u </span><br><span class="line">((<span class="number">10</span>, <span class="number">20</span>), (<span class="number">30</span>, <span class="number">40</span>))</span><br></pre></td></tr></table></figure>
<h4 id="防御可变参数"><a href="#防御可变参数" class="headerlink" title="防御可变参数"></a>防御可变参数</h4><p>不要使用可变类型作为参数的默认值。</p>
<h4 id="del和垃圾回收"><a href="#del和垃圾回收" class="headerlink" title="del和垃圾回收"></a>del和垃圾回收</h4><p>del 语句删除名称，而不是对象。del 命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时。 重新绑定也可能会导致对象的引用数量归零，导致对象被销毁。</p>
<h3 id="符合Python风格的对象"><a href="#符合Python风格的对象" class="headerlink" title="符合Python风格的对象"></a>符合Python风格的对象</h3><p>因Python数据模型，自定义类型行为可以像内置类型那样自然。实现如此自然的行为，靠的不是继承，而是鸭子类型（会叫即鸭子）：只需按照预定行为实现对象所需的方法（一般特殊方法）即可。</p>
<h4 id="classmethod与staticmethod"><a href="#classmethod与staticmethod" class="headerlink" title="classmethod与staticmethod"></a>classmethod与staticmethod</h4><p>classmethod定义操作类，而不是操作实例的方法。classmethod中第一个参数始终是<strong>类本身</strong>。classmethod最常用的用途是定义备选构造方法。staticmethod就是普通函数，只是碰巧在类的定义中。</p>
<h4 id="格式化显示"><a href="#格式化显示" class="headerlink" title="格式化显示"></a>格式化显示</h4><p><code>&#39;{0.mass:5.3e}&#39;</code> 这样的格式字符串其实包含两部分，冒号左边的 ‘0.mass’ 在代换字段句法中是字段名，冒号后面的 ‘5.3e’ 是格式说明符</p>
<p>str.format() 格式说明符使用的表示法是格式规范化微语言（formatspec）。</p>
<p>New in Python3.6</p>
<p>f-string 真正的运行时计算；双引号</p>
<p>!r 调用 repr()、!s调用 str()、!a调用ascii()</p>
<h4 id="Python的私有属性和“受保护的”属性"><a href="#Python的私有属性和“受保护的”属性" class="headerlink" title="Python的私有属性和“受保护的”属性"></a>Python的私有属性和“受保护的”属性</h4><p>为避免子类意外覆盖“私有”属性，以形如<code>__mode</code>的形式（两个前导下划线）命名实例属性，Python会把属性名存入实例的<code>__dict__</code>属性中，而且会在前面加一个下划线和类名，因此有<code>_Class__mode</code>和<code>_Subclass__mode</code>。</p>
<p>有些Python程序员约定使用一个下划线前缀编写“受保护”的属性（如 self._x）。</p>
<p>默认情况下，各个实例在名为<code>__dict__</code>的特殊属性中存储实例属性。</p>
<p><code>__slots__</code>类属性，让解释器在元组中储存实例属性，而不是用字典。这样节省大量内存。在类中定义<code>__slots__</code> 属性的目的是告诉解释器：“这个类中的所有实例属性都在这儿了！”</p>
<p>仅当权衡当下的需求并仔细搜集资料后证明确实有必要时，才应该使用<code>__slots__</code> 属性。</p>
<h4 id="覆盖类属性"><a href="#覆盖类属性" class="headerlink" title="覆盖类属性"></a>覆盖类属性</h4><p>Python中：类属性可用于为实例属性提供默认值。</p>
<p>为不存在的实例属性赋值，会创建新的实例属性。为实例属性赋值后，同名的类属性不受影响。然而自此之后，self.objattr读取的是实例属性objattr，也就把类属性覆盖了。</p>
<p><strong>在 Python中，我们可以先使用公开属性，然后等需要时再变成特性。</strong></p>
<h3 id="序列的修改、散列、切片"><a href="#序列的修改、散列、切片" class="headerlink" title="序列的修改、散列、切片"></a>序列的修改、散列、切片</h3><p>序列类型的构造方法应该接受可迭代的对象为参数，因为所有内置的序列类型就是这样做的。</p>
<h4 id="切片原理"><a href="#切片原理" class="headerlink" title="切片原理"></a>切片原理</h4><p>Python如何把seq[1:3]句法变成传给<code>seq.__getitem__(...)</code>的参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MySeq</span>:</span></span><br><span class="line"><span class="meta">... </span>	<span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line"><span class="meta">... </span>	<span class="keyword">return</span> index </span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = MySeq()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>] </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>] </span><br><span class="line">slice(<span class="number">1</span>, <span class="number">4</span>, <span class="keyword">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>] </span><br><span class="line">slice(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>, <span class="number">9</span>] </span><br><span class="line">(slice(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>), <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>, <span class="number">7</span>:<span class="number">9</span>] </span><br><span class="line">(slice(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>), slice(<span class="number">7</span>, <span class="number">9</span>, <span class="keyword">None</span>))</span><br></pre></td></tr></table></figure>
<p>indices：假设有个长度为 5 的序列，例如 ‘ABCDE’：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>slice(<span class="keyword">None</span>, <span class="number">10</span>, <span class="number">2</span>).indices(<span class="number">5</span>) <span class="comment"># ➊</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>slice(<span class="number">-3</span>, <span class="keyword">None</span>, <span class="keyword">None</span>).indices(<span class="number">5</span>) <span class="comment"># ➋</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>❶ ‘ABCDE’[:10:2] 等同于 ‘ABCDE’[0:5:2]<br>❷ ‘ABCDE’[-3:] 等同于 ‘ABCDE’[2:5:1]</p>
<p>当没有底层序列类型作为依靠，那么使用此方法能节省大量时间。</p>
<p>属性查找失败后，解释器会调用<code>__getattr__</code>方法。简单来说，对my_obj.x 表达式，Python 会检查 my_obj 实例有没有名为 x 的属性；如果没有，到类（<code>my_obj.__class__</code>）中查找；如果还没有，顺着继承树继续查找。 如果依旧找不到，调用 my_obj 所属类中定义的<code>__getattr__</code> 方法，传入 self 和属性名称的字符串形式（如 ‘x’）。</p>
<h5 id="zip函数"><a href="#zip函数" class="headerlink" title="zip函数"></a>zip函数</h5><p>zip函数用于并行迭代两个或多个可迭代对象。当一个可迭代的对象耗尽后，它不发出警告就停止。itertools.zip_longest函数的行为有所不同：使用可选的fillvalue填充缺失的值，直到最长的可迭代对象耗尽。</p>
<p>为了避免在for循环中手动处理索引变量，还经常使用内置的enumerate生成器函数。</p>
<h3 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h3><p>抽象基类常见用途：实现接口时作为超类使用。抽象基类如何检查具体子类是否符合接口定义？如何使用注册机制声明一个类实现了某个接口，而不进行子类化操作。最后说明如何让抽象基类自动“识别”任何符合接口的类——不进行子类化或注册。</p>
<p><strong>Python 是动态语言，因此我们可以在运行时修正一些问题。</strong></p>
<p>object does not support item assignment 问题：可变的序列还必须提供 <code>__setitem__</code>方法。</p>
<h4 id="标准库中的抽象基类"><a href="#标准库中的抽象基类" class="headerlink" title="标准库中的抽象基类"></a>标准库中的抽象基类</h4><p>collections.abc中的抽象基类最常用。</p>
<h4 id="自定义抽象基类"><a href="#自定义抽象基类" class="headerlink" title="自定义抽象基类"></a>自定义抽象基类</h4><p>抽象方法使用@abc.abstractmethod标记，而且定义体中通常只有文档字符串。”是否实现抽象方法”基类检测子类是否符合接口的依据。</p>
<p>声明抽象基类最简单的方法是继承abc.ABC或其他抽象基类。</p>
<p>声明抽象类方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyABC</span><span class="params">(abc.ABC)</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">an_abstract_classmethod</span><span class="params">(cls, ...)</span>:</span></span><br><span class="line">    	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>与其他描述符一起使用时，abstractmethod()应放在最里层。</p>
<h4 id="虚拟子类"><a href="#虚拟子类" class="headerlink" title="虚拟子类"></a>虚拟子类</h4><p>Python新编程风格：使用抽象基类明确声明接口，而且类可以子类化抽象基类或抽象基类注册（无需在继承关系中确立静态的强链接），宣称它实现了某个接口。</p>
<h3 id="继承的优缺点"><a href="#继承的优缺点" class="headerlink" title="继承的优缺点"></a>继承的优缺点</h3><p>不要子类化内置类型，自定义类应该继承collections模块中的类，例如UserDict、UserList和UserString，它们易于扩展。</p>
<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><h4 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h4><p><code>- (__neg__)</code> 、<code>+ (__pos__)</code>、 <code>~(__invert__)</code></p>
<p>支持一元运算符很简单，只需实现相应的特殊方法。这些特殊方法只有一个参数，self。运算符一个基本规则：始终返回一个新对象。也就是说，不能修改self，要创建并返回合适类型的新实例。</p>

      </div>
      
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/python/">python</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2018/11/02/python/fluentpy2/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">FluentPy Note（2）</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:xu.io@qq.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/Langzi418" class="iconfont icon-github" title="github"></a>
        </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2018 - 2019<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Singular</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
