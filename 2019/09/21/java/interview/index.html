<!DOCTYPE html>
<html lang="zh-Hans">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="知识点总结"/><meta name="keywords" content="Blog" /><link rel="alternate" href="/atom.xml" title="Blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="http://yoursite.com/2019/09/21/java/interview/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" /><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true,"latex":true};
</script>

    <title>知识点总结 - Blog</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            标签
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            关于
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">知识点总结
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-09-21
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA"><span class="toc-text">JAVA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#容器"><span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-text">ConcurrentHashMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发"><span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile"><span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized"><span class="toc-text">synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁优化"><span class="toc-text">锁优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java实现原子操作"><span class="toc-text">Java实现原子操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原子类"><span class="toc-text">原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal"><span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS"><span class="toc-text">AQS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock"><span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantReadWriteLock"><span class="toc-text">ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池"><span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor"><span class="toc-text">Executor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FixedThreadPool"><span class="toc-text">FixedThreadPool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SingleThreadExecutor"><span class="toc-text">SingleThreadExecutor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CacheThreadPool"><span class="toc-text">CacheThreadPool</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存模型"><span class="toc-text">内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机"><span class="toc-text">虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#运行时数据区域"><span class="toc-text">运行时数据区域</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#程序计数器"><span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java虚拟机栈"><span class="toc-text">Java虚拟机栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#本地方法栈"><span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Java堆"><span class="toc-text">Java堆</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#方法区"><span class="toc-text">方法区</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾收集器"><span class="toc-text">垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial"><span class="toc-text">Serial</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParNew"><span class="toc-text">ParNew</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-Scavenge"><span class="toc-text">Parallel Scavenge</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial-Old"><span class="toc-text">Serial Old</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-Old"><span class="toc-text">Parallel Old</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS（Concurrent-Mark-Sweep）"><span class="toc-text">CMS（Concurrent Mark Sweep）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1"><span class="toc-text">G1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存分配与回收策略"><span class="toc-text">内存分配与回收策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#分代收集算法"><span class="toc-text">分代收集算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基础"><span class="toc-text">基础</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL"><span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#索引"><span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#B-B-树"><span class="toc-text">B/B+树</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
  </div><div class="post-content"><h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>关键代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;  <span class="comment">//定位索引位置</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>良好的Hash算法和扩容机制是的Hash碰撞的概率减少并且哈希桶数组占用的空间少。</p>
<p><code>threshold = length*Load factor</code> 。默认的负载因子0.75是对空间和时间效率的平衡。</p>
<p>HashMap中table的length必须为2的幂（一定是合数。若自定initial capacity，会指定为大于它的最小2的幂），这样做是为了在取模和扩容时做优化。</p>
<p>为了减少冲突，HashMap定位哈希桶索引位置时，加入了高位参与运算。</p>
<p>HashMap中哈希算法：取key的hashCode()值、高位运算、取模运算。</p>
<p>put</p>
<p><img src="https://i.loli.net/2019/09/25/y9vH3nm2jDsUYex.jpg" alt=""></p>
<p>Java8在扩容时的链表部分的优化，Java7是“重新计算索引+头插法”，Java8在重新计算索引时做了优化，计算快。新增的比特可以认为是随机的，则在扩容时，均匀地将冲突地结点分散到新链表。</p>
<p><img src="https://i.loli.net/2019/09/22/gmxNESoPFi1KUJC.jpg" alt=""></p>
<p>多线程时，可能在put、resize后形成环形链表。</p>
<p>链表元素大于等于8，链表转化为树；扩容时若链表元素小于等于6，转化为链表。红黑树的平均查找长度log(n)，链表为n/2。当n&gt;=8时，有转化为树的必要。另外，在6和8之间有7，可以有效避免树和链表的频繁转化。</p>
<p>Reference</p>
<p><a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">java8之重新认识HashMap</a></p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>1.7  Segment extends ReentrantLock</p>
<p>1.8 CAS + synchronized</p>
<p>由于已经使用volatile保证了key、value可见性，所以在get时不需要加锁。</p>
<p>Reference</p>
<p><a href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/" target="_blank" rel="noopener">HashMap? ConcurrentHashMap?</a></p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>Lock前缀指令。</p>
<p>1）将当前处理器缓存行的数据写回到系统内存。</p>
<p>2）以上写回内存操作会使其他CPU里缓存了该内存地址的数据无效。</p>
<p>指令重排。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>任何一个对象都有一个monitor与之关联，当monitor被持有后，它将处于锁定状态。</p>
<p>代码同步块：monitorenter时，尝试获取monitor；monitorexit时，释放monitor。</p>
<p>同步方法：有ACC_SYNCHRONIZED标志，进入方法获取monitor，方法结束释放monitor。</p>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p>Java的线程是映射到操作系统的原生线程之上的，如果阻塞或唤醒一个线程，都需要操作系统帮忙完成，这就需要从用户态转换到核心态，因此状态转换需要耗费很多的处理器时间。</p>
<p>偏向锁、轻量级锁、重量级锁</p>
<p>对象头信息</p>
<h3 id="Java实现原子操作"><a href="#Java实现原子操作" class="headerlink" title="Java实现原子操作"></a>Java实现原子操作</h3><p>CAS+自旋、锁</p>
<p>CAS的“ABA”问题：A-&gt;B-&gt;A，那么CAS操作就会认为A没有变过，可以通过控制变量值的版本来保证CAS操作的正确性。JUC中提供了一个带有标记的原子类来解决此问题。但大多数情况下ABA问题并不会影响程序并发的正确性，所以如果需要解决ABA问题，采用传统的互斥同步可能更高效。</p>
<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>CAS实现，AtomicInteger等可做计数器，更好地实现LongAdder。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>线程封闭</p>
<p>ThreadLocal提供了get和set等方法，这些方法为每个使用该变量的内存都存有一份独立的副本。</p>
<p>ThreadLocal对象通常用于防止可变的单实例变量（Singleton）或全局变量进行共享。</p>
<p>关键代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadLocal.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/09/21/PGjztove9r2kSEg.jpg" alt=""></p>
<p>线程终止后，threadLocals=null。</p>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>原子性地维护同步状态state（由子类重写tryAcquire、tryRelease…）</p>
<p>阻塞和释放线程（LockSupport）</p>
<p>维护阻塞线程的队列（CLH，双向链表，FIFO）</p>
<p><img src="https://i.loli.net/2019/10/27/R9iVZToqy1pmE6l.png" alt=""></p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>非公平锁：如果获取锁的线程再次请求，则增加state，成功。可能造成饥饿，但线程切换少，吞吐量大。</p>
<p>公平锁：比非公平锁增加了当前结点是否有前驱结点的判断，若有，则不成功，FIFO。线程切换多。</p>
<h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>高16位读状态（c&gt;&gt;&gt;16)， 低16位写状态（c&amp;((1&lt;&lt;16) -1)）。</p>
<p>写锁：获取时，若读锁已经被获取（读状态不为0）或者当前线程不是已经获取写锁的线程，则等待。</p>
<p>读锁：在没有其他写线程访问时（写状态为0），读锁成功获取。  </p>
<p>如果读锁存在，则写锁不能被获取。原因：若允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他线程就可能无法感知当前写线程的操作。（脏读）</p>
<p>锁降级：锁降级中读锁的获取是必要的。若当前线程不获取读锁而直接释放写锁，假如另一个线程获取写锁并更新数据，那么当前线程可能无法感知数据的更新。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>execute执行command分四种情况：</p>
<ol>
<li><p>如果当前运行线程小于corePoolSize，则创建新线程来执行任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = ctl.get();</span><br><span class="line"><span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    <span class="comment">// addWorker需要获取全局锁</span></span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    c = ctl.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果运行的线程大于等于corePoolSize，则将任务加入到BlockingQueue。</p>
</li>
<li><p>如果队列已满，再创建新的线程来处理任务（addWorker（command, false））。</p>
</li>
<li><p>如果创建新线程将使当前运行的线程超出maxinumPoolSize，任务将被拒绝，执行饱和策略。</p>
</li>
</ol>
<p>在ThreadPoolExecutor完成预热后（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都执行步骤2，而它不需要获取全局锁。</p>
<p><strong>工作线程</strong>：线程池创建线程时，会将线程封装成Worker，Worker在执行完任务后，还会循环获取BlockingQueue中的Worker来执行。</p>
<p><strong>提交任务</strong>：pool.execute(Runnable);      Future\<object> future = pool.submit(Runnable);</object></p>
<p><strong>关闭线程池</strong>：</p>
<p>shutdown和shutdownNow都会通知线程池不再接受任务，都会立即返回。</p>
<p>区别：showdown仅中断空闲线程，使得BlockingQueue中的线程可以被剩下的线程执行，该方法返回值为void。showdownNow中断所有线程，返回BlockingQueue中的线程列表。</p>
<p>+++++</p>
<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p><code>ThreadPoolExecutor(corePoolsize,  maxPoolSize,  keepAliveTime, BlockingQueue)</code></p>
<p>当线程池中的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待任务的最长时间，超时则线程终止。</p>
<h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><p>使用无界队列LinkedBlockingQueue作为线程池的工作队列（容量Integer.MAX_VALUE）。影响：</p>
<p>1）线程池中的线程数达到coerPoolSize后，新任务将在无界队列中等待，所以线程池中的线程数将不会超过corePoolSize。</p>
<p>适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，它适用于负载比较重的服务器。</p>
<h4 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h4><p>LinkedBlockingQueue</p>
<p>corePoolSize=1</p>
<p>适用于需要保证顺序地执行各个任务；并且在任意地时间点不会有多个线程是活动的应用场景。</p>
<h4 id="CacheThreadPool"><a href="#CacheThreadPool" class="headerlink" title="CacheThreadPool"></a>CacheThreadPool</h4><p>SynchronousQueue</p>
<p>corePoolSize=0, maxPoolSize=Integer.MAX_VALUE</p>
<p>如果主线程提交任务的速度高于maxPool中处理任务的速度，它会不断地创建新的线程。</p>
<p>适用于执行很多的短期异步任务小程序，或负载较轻的服务器。</p>
<p>Reference：</p>
<p>《Java并发编程实战》</p>
<p>《Java并发编程之美》</p>
<p>《Java并发编程的艺术》</p>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>Java虚拟机规范试图定义一种Java内存模型(JMM)来屏蔽各种硬件和操作系统的内存访问差异。</p>
<p>JMM的目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</p>
<p>Java线程 <-> 工作内存 <-> JMM <-> 主内存</-></-></-></p>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><p>记录正在执行的虚拟机字节码指令的地址。</p>
<h5 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h5><p>每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p>
<p>-Xss 可以指定每个线程的Java虚拟机栈内存大小</p>
<p>异常：</p>
<p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出Stackoverflow异常；</p>
<p>如果虚拟机栈扩展时无法申请到足够的内存，会抛出OOM异常。</p>
<h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><p>与Java虚拟机栈类似</p>
<h5 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h5><p>几乎所有的对象实例以及数组都要在堆上分配，是垃圾收集器管理的主要区域。</p>
<p>从内存回收的角度来看：堆可分为新生代和老年代</p>
<p>从内存分配的进度来看：堆中可能划分出多个、线程私有的分配缓冲区</p>
<p>-Xms 可以指定堆初始值、-Xmx可以设置最大值</p>
<p>堆不需要物理上连续。若堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OOM异常。</p>
<h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><p>在单CPU的环境中，serial由于没有线程交互的开销，所以能获得最高的单线程收集效率。</p>
<h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><p>Serial的多线程版本。</p>
<h4 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h4><p>目标是达到一个可控制的吞吐量。这里，吞吐量=运行用户代码的时间/（运行用户代码的时间+垃圾收集的时间）。高吞吐量可以高效地利用CPU时间，尽快完成程序的计算任务，主要适合在后台计算而不需要太多交互的场景。</p>
<p>-XX:MaxGCPauseMills（最大垃圾收集停顿时间） -XX:GCTimeRatio（垃圾收集时间占总时间的比率） </p>
<p>GC时间的缩短是以牺牲吞吐量的和新生代的空间来换取的：系统把新生代的空间调小。</p>
<h4 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h4><p>Serial的老年代版本。</p>
<h4 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h4><p>parallel scavenge的老年代版本。</p>
<h4 id="CMS（Concurrent-Mark-Sweep）"><a href="#CMS（Concurrent-Mark-Sweep）" class="headerlink" title="CMS（Concurrent Mark Sweep）"></a>CMS（Concurrent Mark Sweep）</h4><p>目标是获得最短的回收停顿时间。</p>
<p>4个步骤：</p>
<p>1）初始标记：只标记GC Roots能直接关联到的对象，速度很快，需要停顿；</p>
<p>2）并发标记：GC Roots Tracing的过程；</p>
<p>3）重新标记：修正并发标记期间因用户程序继续运行导致标记产生变动的那一部分对象的标记记录，停顿稍长一些；</p>
<p>4）并发清除。</p>
<p><img src="https://i.loli.net/2019/11/11/HDFZ3Ej62nCBxV4.jpg" alt=""></p>
<p><strong>Todo: Safepoint ?</strong></p>
<h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><p>使用大小相等的独立区域（Region）划分内存以及按优先级来回收内存。</p>
<p>新生代和老年代不再是物理隔离的，它们都是一部分Region（不需要连续）的集合。</p>
<h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>分为新生代和老年代。</p>
<p>新生代：每次垃圾收集时都发现大量的对象死亡，存活率低。可以使用复制算法进行收集，只需要使用少量的复制成本，算法简单，效率高。</p>
<p>老年代：对象存活率高、没有额外空间对它进行分配担保，必须使用“标记——清理”，或者“标记——整理”。</p>
<p>新生代GC（Minor GC）：新生代特点，频繁。</p>
<p>老年代GC（Major GC/Full GC）：比Minor GC慢10倍以上。</p>
<p>大多数情况下，对象在新生代Eden区中分配。很长的字符串以及数组直接进入老年代。</p>
<p>Reference：</p>
<p>《深入理解JAVA虚拟机》</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>IO 阻塞、每个连接一个线程</p>
<p>NIO selector + 轮询 （Netty）</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="B-B-树"><a href="#B-B-树" class="headerlink" title="B/B+树"></a>B/B+树</h4><p>m阶B树和B+树的主要区别在于：</p>
<ol>
<li>在B+树中，<strong>叶节点包含信息</strong>，所有非叶节点仅起索引作用，非叶节点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，<strong>不含有</strong>该关键字对应记录的<strong>存储地址</strong>。</li>
<li>B+树中，叶节点包含了<strong>全部关键字</strong>，且相邻叶节点是链接起来的；而在B树中，叶节点包含的关键字和非叶节点包含的关键字<strong>不重复</strong>。</li>
</ol>
<p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式<strong>存储在磁盘</strong>上。这样的话，索引查找过程中就要产生<strong>磁盘I/O消耗</strong>，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的时间复杂度。</p>
<p>数据库系统的设计者巧妙利用了磁盘预读原理，将一个<strong>节点的大小设为等于一个页</strong>，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p>每次新建节点时，直接申请一个页的空间，<strong>这样就保证一个节点物理上也存储在一个页里</strong>，加之计算机存储分配都是按页对齐的，就实现了一个节点只需一次I/O。</p>
<p><strong>B/B+树与红黑树比较</strong></p>
<p>平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。</p>
<p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</p>
<p><strong>B+树与B树比较</strong></p>
<p>B+Tree更适合索引，原因和节点出度d有关。d越大索引的性能越好，<strong>而出度的上限取决于节点内key和data的大小</strong>：<br>$$<br>dmax=floor(pagesize/(keysize+datasize+pointsize))<br>$$<br>由于B+Tree内节点<strong>去掉了data域</strong>，因此可以拥有更大的出度，拥有更好的性能。</p>
<p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p>

      </div>
      
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/java/">java</a>
            </div>
        
        <nav class="post-nav"><a class="next" href="/2019/08/21/algorithm/algorithm/">
        <span class="next-text nav-default">Algorithm Note</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:xu.io@qq.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/Langzi418" class="iconfont icon-github" title="github"></a>
        </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2018 - 2019<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Singular</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
