<!DOCTYPE html>
<html  lang="zh">
<head>
    <meta charset="utf-8">
<title>Java8 Learn - PIO</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />



    <meta name="description" content="行为参数化  行为参数化，就是一个方法接受多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力。 行为参数化让代码更好地适应不断变化的要求，减轻未来的工作量。 传递代码，就是将新行为作为参数传递给方法。Java API中包括排序、线程和GUI处理。">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java8 Learn">
<meta property="og:url" content="http://yoursite.com/2018/11/12/java/java8/index.html">
<meta property="og:site_name" content="PIO">
<meta property="og:description" content="行为参数化  行为参数化，就是一个方法接受多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力。 行为参数化让代码更好地适应不断变化的要求，减轻未来的工作量。 传递代码，就是将新行为作为参数传递给方法。Java API中包括排序、线程和GUI处理。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/og_image.png">
<meta property="og:updated_time" content="2018-11-12T11:35:26.521Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java8 Learn">
<meta name="twitter:description" content="行为参数化  行为参数化，就是一个方法接受多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力。 行为参数化让代码更好地适应不断变化的要求，减轻未来的工作量。 传递代码，就是将新行为作为参数传递给方法。Java API中包括排序、线程和GUI处理。">
<meta name="twitter:image" content="http://yoursite.com/images/og_image.png">







<link rel="icon" href="/images/favicon.svg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    

    
    
    
        <script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    

    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-3-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.svg" alt="Java8 Learn" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">Home</a>
                
                <a class="navbar-item"
                href="/archives">Archives</a>
                
                <a class="navbar-item"
                href="/tags">Tags</a>
                
                <a class="navbar-item"
                href="/about">About</a>
                
            </div>
            
            <div class="navbar-end">
                
                
                
                <a class="navbar-item search" title="Search" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-6-widescreen has-order-2 column-main"><div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2018-11-12T11:35:43.000Z">2018-11-12</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    40 minutes read (About 6006 words)
                </span>
                
                
                <span class="level-item has-text-grey" id="busuanzi_container_page_pv">
                    <i class="far fa-eye"></i>
                    <span id="busuanzi_value_page_pv">0</span> visits
                </span>
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                Java8 Learn
            
        </h1>
        <div class="content">
            <p>行为参数化</p>
<ul>
<li>行为参数化，就是一个方法接受多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力。</li>
<li>行为参数化让代码更好地适应不断变化的要求，减轻未来的工作量。</li>
<li>传递代码，就是将新行为作为参数传递给方法。Java API中包括排序、线程和GUI处理。</li>
</ul>
<a id="more"></a>
<h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p><strong>在哪里使用Lambda?</strong></p>
<h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>函数式接口即只定义一个抽象方法的接口。</p>
<p><strong>Lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例（具体说来，是函数式接口一个具体实现的实例）。</strong></p>
<p>使用：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BufferedReaderProcessor</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function">String <span class="hljs-title">process</span><span class="hljs-params">(BufferedReader b)</span> <span class="hljs-keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BufferTest</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">processFile</span><span class="hljs-params">(BufferedReaderProcessor p)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> (BufferedReader br =</span><br><span class="line">                     <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-string">"data.txt"</span>))) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> p.process(br);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String oneLine = processFile((BufferedReader br) -&gt; br.readLine());</span><br><span class="line">        <span class="hljs-comment">// String oneLine = processFile(BufferedReader::readLine);</span></span><br><span class="line">        String twoLines = processFile(</span><br><span class="line">                (BufferedReader br) -&gt; br.readLine() + br.readLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用函数式接口"><a href="#使用函数式接口" class="headerlink" title="使用函数式接口"></a>使用函数式接口</h4><p>函数式接口很有用，因为抽象方法的签名可以描述Lambda表达式的签名。函数式接口的抽象方法的签名称为函数描述符。</p>
<p>Java API中已经有了几个函数式接口，比如 Comparable 、 Runnable 和Callable 。</p>
<p>Java 8 中有Predicate 、 Consumer 和 Function。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Predicate</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; nonEmptyStringPredicate = (String s) -&gt; !s.isEmpty();</span><br></pre></td></tr></table></figure>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Consumer</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(List&lt;T&gt; list, Consumer&lt;T&gt; c)</span></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span>(T i: list)&#123;</span><br><span class="line">    	c.accept(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">forEach(</span><br><span class="line">    Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>),(Integer i) -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Function</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt;</span>&#123;</span><br><span class="line">	<span class="hljs-function">R <span class="hljs-title">apply</span><span class="hljs-params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, R&gt; <span class="hljs-function">List&lt;R&gt; <span class="hljs-title">map</span><span class="hljs-params">(List&lt;T&gt; list,Function&lt;T, R&gt; f)</span></span>&#123;</span><br><span class="line">List&lt;R&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="hljs-keyword">for</span>(T s: list)&#123;</span><br><span class="line">    	result.add(f.apply(s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// [7, 2, 6]</span></span><br><span class="line">List&lt;Integer&gt; l = map(Arrays.asList(<span class="hljs-string">"lambdas"</span>,<span class="hljs-string">"in"</span>,<span class="hljs-string">"action"</span>),(String s) -&gt; s.length());</span><br></pre></td></tr></table></figure>
<h4 id="原始类型特化"><a href="#原始类型特化" class="headerlink" title="原始类型特化"></a>原始类型特化</h4><p>比如，在下面的代码中，使用 IntPredicate 就避免了对值 1000 进行装箱操作，但要是用 <code>Predicate&lt;Integer&gt;</code> 就会把参数 1000 装箱到一个 Integer 对象中：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IntPredicate</span></span>&#123;</span><br><span class="line">	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">int</span> t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">IntPredicate evenNumbers = (<span class="hljs-keyword">int</span> i) -&gt; i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>;</span><br><span class="line">evenNumbers.test(<span class="hljs-number">1000</span>);</span><br><span class="line"></span><br><span class="line">Predicate&lt;Integer&gt; oddNumbers = (Integer i) -&gt; i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>;</span><br><span class="line">oddNumbers.test(<span class="hljs-number">1000</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2018/11/06/5be0f72e8cebf.png" alt="funinter.PNG"></p>
<p><img src="https://i.loli.net/2018/11/09/5be538c6a377b.png" alt="funinter2.png"></p>
<p>因函数式接口都不允许抛出受检异常。如果需要Lambda表达式抛出异常，有两种方法：定义一个自己的函数式接口，并声明受检异常，或把Lambda包在一个try/catch块中。</p>
<h3 id="类型检查、类型推断以及限制"><a href="#类型检查、类型推断以及限制" class="headerlink" title="类型检查、类型推断以及限制"></a>类型检查、类型推断以及限制</h3><h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><p>Java编译器会从上下文（<strong>目标类型</strong>）推断出用什么函数式接口来配合Lambda表达式，这意味着它也可以推断出适合Lambda的签名，因为函数描述符可以通过目标类型来得到。这样做的好处在于，编译器可以了解Lambda表达式的参数类型，这样就可以在Lambda语法中<strong>省去标注</strong>参数类型。</p>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>可以视为某些Lambda的快捷写法。可以重复使用现有的方法定义，并像Lambda一样传递它们。</p>
<p>如果一个Lambda表达式只是“直接调用这个方法”，那最好还是用名称来调用它，而不是去描述如何调用它。</p>
<h3 id="复合Lambda表达式的有用方法"><a href="#复合Lambda表达式的有用方法" class="headerlink" title="复合Lambda表达式的有用方法"></a>复合Lambda表达式的有用方法</h3><h4 id="比较器复合"><a href="#比较器复合" class="headerlink" title="比较器复合"></a>比较器复合</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort(comparing(Apple::getWeight).reversed());</span><br></pre></td></tr></table></figure>
<h4 id="比较器链"><a href="#比较器链" class="headerlink" title="比较器链"></a>比较器链</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort(comparing(Apple::getWeight)</span><br><span class="line">    .reversed()</span><br><span class="line">    .thenComparing(Apple::getCountry));</span><br></pre></td></tr></table></figure>
<h4 id="谓词复合"><a href="#谓词复合" class="headerlink" title="谓词复合"></a>谓词复合</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;Apple&gt; redAndHeavyAppleOrGreen =</span><br><span class="line">    redApple.and(a -&gt; a.getWeight() &gt; <span class="hljs-number">150</span>)</span><br><span class="line">    .or(a -&gt; <span class="hljs-string">"green"</span>.equals(a.getColor()));</span><br></pre></td></tr></table></figure>
<h4 id="函数复合"><a href="#函数复合" class="headerlink" title="函数复合"></a>函数复合</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; f = x -&gt; x + <span class="hljs-number">1</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; g = x -&gt; x * <span class="hljs-number">2</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; h = f.andThen(g);</span><br><span class="line"><span class="hljs-keyword">int</span> result = h.apply(<span class="hljs-number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>它允许以声明性方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。 </p>
<p><strong>只能遍历一次。</strong></p>
<h4 id="内部迭代与外部迭代"><a href="#内部迭代与外部迭代" class="headerlink" title="内部迭代与外部迭代"></a>内部迭代与外部迭代</h4><p>Java Collection外部迭代，Stream内部迭代。</p>
<p>内部迭代优点：可以透明地并行处理， 或者用更优化的顺序进行处理。</p>
<h4 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h4><p>诸如 filter 或 sorted 等中间操作会返回另一个流。这让多个操作可以连接起来形成一个查询。重要的是，除非流水线上触发一个终端操作，否则中间操作不会执行任何处理——它们很懒。</p>
<h4 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h4><p>终端操作会从流的流水线生成结果。其结果是任何不是流的值，比如 List 、 Integer ，甚至 void 。</p>
<h4 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h4><p>三件事：一数据源、二中间操作链、三终端操作。</p>
<p>流的流水线理念类似于构建器模式。</p>
<p><img src="https://i.loli.net/2018/11/06/5be14723ab807.png" alt="stream.PNG"></p>
<h3 id="筛选和切片"><a href="#筛选和切片" class="headerlink" title="筛选和切片"></a>筛选和切片</h3><h4 id="用谓词筛选"><a href="#用谓词筛选" class="headerlink" title="用谓词筛选"></a>用谓词筛选</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dish&gt; vegetarianMenu = menu.stream()</span><br><span class="line">	.filter(Dish::isVegetarian)</span><br><span class="line">	.collect(toList());</span><br></pre></td></tr></table></figure>
<p>流还支持一个叫作 distinct 的方法，它会返回一个元素各异（根据流所生成元素的hashCode 和 equals 方法实现）的流。</p>
<h4 id="截短流"><a href="#截短流" class="headerlink" title="截短流"></a>截短流</h4><p>流支持 limit(n) 方法，该方法会返回一个不超过给定长度的流。</p>
<h4 id="跳过元素"><a href="#跳过元素" class="headerlink" title="跳过元素"></a>跳过元素</h4><p>流还支持 skip(n) 方法，返回一个扔掉了前 n 个元素的流。</p>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><h4 id="流的扁平化"><a href="#流的扁平化" class="headerlink" title="流的扁平化"></a>流的扁平化</h4><p> Arrays.stream() 的方法可以接受一个数组并产生一个流</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; uniqueCharacters =</span><br><span class="line">    words.stream()</span><br><span class="line">    .map(w -&gt; w.split(<span class="hljs-string">""</span>))</span><br><span class="line">    .flatMap(Arrays::stream)</span><br><span class="line">    .distinct()</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>flatMap合并为一个流。</p>
<h4 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h4><p>allMatch、anyMatch、noneMatch、findFirst、findAny</p>
<h5 id="短路求值"><a href="#短路求值" class="headerlink" title="短路求值"></a>短路求值</h5><p>对于流而言，某些操作（例如 allMatch 、 anyMatch 、 noneMatch 、 findFirst 和 findAny ）不用处理整个流就能得到结果。只要找到一个元素，就可以有结果了。同样， limit 也是一个短路操作：它只需要创建一个给定大小的流，而用不着处理流中所有的元素。在碰到无限大小的流的时候，这种操作就有用了：它们可以把无限流变成有限流。</p>
<h4 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h4><h5 id="算术"><a href="#算术" class="headerlink" title="算术"></a>算术</h5><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> sum = numbers.stream().reduce(<span class="hljs-number">0</span>, (a, b) -&gt; a + b);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> sum = numbers.stream().reduce(<span class="hljs-number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure>
<h5 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h5><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; max = numbers.stream().reduce(Integer::max);</span><br></pre></td></tr></table></figure>
<h4 id="原始类型流特化"><a href="#原始类型流特化" class="headerlink" title="原始类型流特化"></a>原始类型流特化</h4><p>IntStream、DoubleStream、LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本。还带来了进行常用数值归约的新方法，如sum、max。</p>
<p> IntStream 还支持其他的方便方法，如max 、 min 、 average 等。</p>
<h5 id="映射到数值流"><a href="#映射到数值流" class="headerlink" title="映射到数值流"></a>映射到数值流</h5><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> calories = menu.stream()</span><br><span class="line">    .mapToInt(Dish::getCalories)</span><br><span class="line">    .sum();</span><br></pre></td></tr></table></figure>
<h5 id="转换回对象流"><a href="#转换回对象流" class="headerlink" title="转换回对象流"></a>转换回对象流</h5><p>IntStream 上的操作只能产生原始整数： IntStream 的 map 操作接受的Lambda必须接受 int 并返回 int。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = intStream.boxed();</span><br></pre></td></tr></table></figure>
<h5 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h5><p>Java 8引入了两个可以用于 IntStream 和 LongStream 的静态方法，帮助生成这种范围：range 和 rangeClosed 。这两个方法都是第一个参数受起始值，第二个参数接受结束值。但range 是不包含结束值的，而 rangeClosed 则包含结束值。</p>
<h3 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h3><h4 id="由值创建流"><a href="#由值创建流" class="headerlink" title="由值创建流"></a>由值创建流</h4><p>静态方法Stream.of，通过显示值创建流。可接受任意数量的参数。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string">"Java 8 "</span>, <span class="hljs-string">"Lambdas "</span>, <span class="hljs-string">"In "</span>, <span class="hljs-string">"Action"</span>);</span><br></pre></td></tr></table></figure>
<p>可使用empty得到一个空流。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; emptyStream = Stream.empty();</span><br></pre></td></tr></table></figure>
<h4 id="由数组创建流"><a href="#由数组创建流" class="headerlink" title="由数组创建流"></a>由数组创建流</h4><p>Arrays.stream接受数组作为参数，例如，可将一个原始类型int转换成IntStream。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span>[] numbers = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>&#125;;</span><br><span class="line"><span class="hljs-keyword">int</span> sum = Arrays.stream(numbers).sum();</span><br></pre></td></tr></table></figure>
<h4 id="由文件生成流"><a href="#由文件生成流" class="headerlink" title="由文件生成流"></a>由文件生成流</h4><p>Java NIO（非阻塞IO）</p>
<h4 id="由函数生成流：创建无限流"><a href="#由函数生成流：创建无限流" class="headerlink" title="由函数生成流：创建无限流"></a>由函数生成流：创建无限流</h4><p>Stream API提供了两个静态方法来从函数生成流： Stream.iterate 和 Stream.generate 。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="hljs-number">0</span>, n -&gt; n + <span class="hljs-number">2</span>)</span><br><span class="line">    .limit(<span class="hljs-number">10</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>都是按需生成，但generate不是依次对每个新生成的值应用函数。它接受一个<code>Supplier&lt;T&gt;</code>类型的Lambda提供新的值。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(Math::random)</span><br><span class="line">    .limit(<span class="hljs-number">5</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="用流-lt-收集-gt-数据"><a href="#用流-lt-收集-gt-数据" class="headerlink" title="用流&lt;收集&gt;数据"></a>用流&lt;收集&gt;数据</h3><p>函数式编程相对于指令式编程一个主要的优势：只需指出希望的结果——“做什么”，而不用操心执行的步骤——“如何做”。</p>
<h4 id="预定义收集器"><a href="#预定义收集器" class="headerlink" title="预定义收集器"></a>预定义收集器</h4><p>三大功能：</p>
<ul>
<li>将流元素归约和汇总为一个值</li>
<li>元素分组</li>
<li>元素分区</li>
</ul>
<h4 id="归约和汇总"><a href="#归约和汇总" class="headerlink" title="归约和汇总"></a>归约和汇总</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">long</span> howManyDishes = menu.stream().count()；</span><br><span class="line"><span class="hljs-keyword">int</span> howManyDishes = menu.size();</span><br></pre></td></tr></table></figure>
<h5 id="查找流中的最大值和最小值"><a href="#查找流中的最大值和最小值" class="headerlink" title="查找流中的最大值和最小值"></a>查找流中的最大值和最小值</h5><p>Collectors.maxBy 和Collectors.minBy ，用来计算流中的最大或最小值。这两个收集器接收一个 Comparator 参数来比较流中的元素。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Dish&gt; dishCaloriesComparator =</span><br><span class="line">	Comparator.comparingInt(Dish::getCalories);</span><br><span class="line"></span><br><span class="line">Optional&lt;Dish&gt; mostCalorieDish =</span><br><span class="line">    menu.stream()</span><br><span class="line">    .collect(maxBy(dishCaloriesComparator));</span><br><span class="line"></span><br><span class="line">Optional&lt;Dish&gt; mostCalorieDish =</span><br><span class="line">                menu.stream()</span><br><span class="line">                        .max(dishCaloriesComp);</span><br></pre></td></tr></table></figure>
<h5 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h5><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 求和</span></span><br><span class="line"><span class="hljs-keyword">int</span> totalCalories =</span><br><span class="line">	menu.stream().collect(summingInt(Dish::getCalories));</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">int</span> totalCalories =</span><br><span class="line">                menu.stream()</span><br><span class="line">                        .mapToInt(Dish::getCalories).sum();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 求平均值</span></span><br><span class="line"><span class="hljs-keyword">double</span> avgCalories =</span><br><span class="line">	menu.stream().collect(averagingInt(Dish::getCalories));</span><br><span class="line"></span><br><span class="line">OptionalDouble avgCalories2 =</span><br><span class="line">                menu.stream()</span><br><span class="line">                        .mapToDouble(Dish::getCalories)</span><br><span class="line">                        .average();</span><br></pre></td></tr></table></figure>
<p>有时候，我们可能希望得到两个或更多这样的结果，而且只需要一次操作就可以完成。此时，可以使用summarizingInt工厂方法返回收集器。例如，通过一次summarinzing操作，即可得到菜肴热量的总和、平均值、最大值、最小值：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics menuStatistics =</span><br><span class="line">	menu.stream().collect(summarizingInt(Dish::getCalories));</span><br></pre></td></tr></table></figure>
<p>收集到一个IntSummaryStatisics中，它提供了一个取值方法来访问结果。</p>
<h5 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h5><p>joining工厂方法返回一个收集器会把对流中的每一个对象应用toString方法得到的字符串连接成一个字符串。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String shortMeu = menu.stream().map(Dish::getName).collect(joining());</span><br></pre></td></tr></table></figure>
<p>joining内部使用StringBuilder。如果Dish类有一个toString方法来返回菜肴的名称，那无需用提取每一道菜名称的函数来对原流做映射，就能得到相同的结果：</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String shortMenu = menu.stream().collect(joining());</span><br></pre></td></tr></table></figure>
<p>joining()工厂方法有一个重载版本，可接受分界符，</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String shortMenu = 		menu.stream().map(Dish::getName).collect(joining(<span class="hljs-string">", "</span>));</span><br></pre></td></tr></table></figure>
<h4 id="广义的归约汇总"><a href="#广义的归约汇总" class="headerlink" title="广义的归约汇总"></a>广义的归约汇总</h4><p>以上所有的收集器，都可以用reducing方法定义归约过程。以上方法只是方便程序员而已。</p>
<p><strong>collect与reduce</strong>: collect()适合表达可变容器上的归约，更关键的是它适合并行操作。</p>
<p><strong>根据情况选择最佳方案</strong></p>
<h4 id="以下开始发挥collect的作用"><a href="#以下开始发挥collect的作用" class="headerlink" title="以下开始发挥collect的作用"></a>以下开始发挥collect的作用</h4><h5 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h5><p><code>Collections.groupingBy(Function)</code></p>
<p>Function称为分类函数。分组操作的结果是一个Map。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, List&lt;Dish&gt;&gt; dishesByType =</span><br><span class="line">	menu.stream().collect(groupingBy(Dish::getType));</span><br></pre></td></tr></table></figure>
<p>可用Lambda编写复杂的分类函数。</p>
<p><code>Collections.groupingBy(Function,Collector)</code></p>
<p>接受collector类型的第二个参数，进行二级分组。可把一个内层的groupingBy传递给外层的groupingBy，作为二级分类标准。</p>
<p>这里的collector可以是任意类型，例如counting()，maxBy()。</p>
<p><code>maxBy(Comparator)</code></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Optional&lt;Dish&gt;&gt; mostCaloricByType =</span><br><span class="line">    menu.stream()</span><br><span class="line">    .collect(groupingBy(Dish::getType,</span><br><span class="line">    	maxBy(comparingInt(Dish::getCalories))));</span><br></pre></td></tr></table></figure>
<p> groupingBy 收集器只有在应用分组条件后，第一次在流中找到某个键对应的元素时才会把键加入分组 Map 中。这意味着 Optional 包装器在这里不是很有用。</p>
<p>把收集器返回的结果转换为另一种类型，你可以使用Collectors.collectingAndThen 工厂方法返回的收集器。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Dish&gt; mostCaloricByType =</span><br><span class="line">	menu.stream()</span><br><span class="line">        .collect(groupingBy(Dish::getType,</span><br><span class="line">        	collectingAndThen(</span><br><span class="line">            maxBy(comparingInt(Dish::getCalories)),</span><br><span class="line">            Optional::get)));</span><br></pre></td></tr></table></figure>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Integer&gt; totalCaloriesByType =</span><br><span class="line">    menu.stream().collect(groupingBy(Dish::getType,</span><br><span class="line">    summingInt(Dish::getCalories)));</span><br></pre></td></tr></table></figure>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Set&lt;CaloricLevel&gt;&gt; caloricLevelsByType =</span><br><span class="line">    menu.stream().collect(</span><br><span class="line">    	groupingBy(Dish::getType, mapping(</span><br><span class="line">    	dish -&gt; &#123; <span class="hljs-keyword">if</span> (dish.getCalories() &lt;= <span class="hljs-number">400</span>) <span class="hljs-keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dish.getCalories() &lt;= <span class="hljs-number">700</span>) <span class="hljs-keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> CaloricLevel.FAT; &#125;,</span><br><span class="line">        toSet() )));</span><br></pre></td></tr></table></figure>
<p>注意在上一个示例中，对于返回的 Set 是什么类型并没有任何保证。但通过使用 toCollection ，你就可以有更多的控制。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Set&lt;CaloricLevel&gt;&gt; caloricLevelsByType =</span><br><span class="line">    menu.stream().collect(</span><br><span class="line">    groupingBy(Dish::getType, mapping(</span><br><span class="line">    dish -&gt; &#123; <span class="hljs-keyword">if</span> (dish.getCalories() &lt;= <span class="hljs-number">400</span>) <span class="hljs-keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dish.getCalories() &lt;= <span class="hljs-number">700</span>) <span class="hljs-keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> CaloricLevel.FAT; &#125;,</span><br><span class="line">    toCollection(HashSet::<span class="hljs-keyword">new</span>) )));</span><br></pre></td></tr></table></figure>
<h5 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h5><p>它是分组的特殊情况：由一个谓词（返回布尔值的函数）作为分类函数，称为分区函数。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Dish&gt;&gt; partitionedMenu =</span><br><span class="line">                menu.stream()</span><br><span class="line">                      .collect(partitioningBy(Dish::isVegetarian));</span><br><span class="line"></span><br><span class="line">List&lt;Dish&gt; vegetarianDishes = partitionedMenu.get(<span class="hljs-keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>分区的好处在于保留了分区函数返回 true 或 false 的两套流元素列表。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, Dish&gt; mostCaloricPartitionedByVegetarian =</span><br><span class="line">	menu.stream().collect(</span><br><span class="line">        partitioningBy(Dish::isVegetarian,</span><br><span class="line">        collectingAndThen(</span><br><span class="line">        maxBy(comparingInt(Dish::getCalories)),</span><br><span class="line">        Optional::get)));</span><br></pre></td></tr></table></figure>
<p>可以仿造groupingBy多级分区。</p>
<p><img src="http://ww1.sinaimg.cn/large/005wR1ytgy1fx53bfox7aj30wg0cqmyx.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005wR1ytgy1fx53bfsibxj30v00tdn2l.jpg" alt=""></p>
<h3 id="收集器接口"><a href="#收集器接口" class="headerlink" title="收集器接口"></a>收集器接口</h3><p>可为collector接口提供自己的实现，从而自由地创建自定义归约操作。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collector</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">A</span>, <span class="hljs-title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-function">Supplier&lt;A&gt; <span class="hljs-title">supplier</span><span class="hljs-params">()</span></span>;</span><br><span class="line">    <span class="hljs-function">BiConsumer&lt;A, T&gt; <span class="hljs-title">accumulator</span><span class="hljs-params">()</span></span>;</span><br><span class="line">    <span class="hljs-function">Function&lt;A, R&gt; <span class="hljs-title">finisher</span><span class="hljs-params">()</span></span>;</span><br><span class="line">    <span class="hljs-function">BinaryOperator&lt;A&gt; <span class="hljs-title">combiner</span><span class="hljs-params">()</span></span>;</span><br><span class="line">    <span class="hljs-function">Set&lt;Characteristics&gt; <span class="hljs-title">characteristics</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h3><p>对顺序流调用parallel方法，并不意味着流本身有任何实际的变化。它在内部实际上就是设了一个 boolean 标志，表示你想让调用 parallel 之后进行的所有操作都并行执行。</p>
<p>并行流内部使用了默认的ForkJoinPool，它默认的线程数量是处理器的数量，可由Runtime.getRuntime().availableProcessors()得到。</p>
<p><strong>避免共享可变状态，确保并行 Stream 得到正确的结果。</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/005wR1ytgy1fx54gljrqpj30ua08rdg5.jpg" alt=""></p>
<p>并行流无需显式地处理线程和同步问题。</p>
<h4 id="自定义Spliterator"><a href="#自定义Spliterator" class="headerlink" title="自定义Spliterator"></a>自定义Spliterator</h4><p>因为原始的 String 在任意位置拆分，所以有时一个词会被分为两个词，然后数了两次。这就说明，拆分流会影响结果，而把顺序流换成并行流就可能使结果出错。</p>
<p>如何解决这个问题呢？解决方案就是要确保 String 不是在随机位置拆开的，而只能在尾<br>拆开。要做到这一点，你必须为 Character 实现一个 Spliterator ，它只能在两个词之间拆开String （如下所示），然后由此创建并行流。</p>
<h3 id="Optional替代Null"><a href="#Optional替代Null" class="headerlink" title="Optional替代Null"></a>Optional替代Null</h3><h4 id="如何为缺失的对象建模？"><a href="#如何为缺失的对象建模？" class="headerlink" title="如何为缺失的对象建模？"></a>如何为缺失的对象建模？</h4><p>Optional：当变量存在时，Optional类只是对类的简单封装。当变量不存在时，缺失的值被建模成一个“空”的Optional对象，由方法Optional.empty返回。 Optional.empty() 方法是一个静态工厂方法，它返回 Optional 类的特定单一实例。</p>
<p>Optional.empty()用处：</p>
<p><img src="http://ww1.sinaimg.cn/large/005wR1ytgy1fx5b99awl1j30t60b3mym.jpg" alt=""></p>
<h4 id="应用Optional"><a href="#应用Optional" class="headerlink" title="应用Optional"></a>应用Optional</h4><h5 id="创建Optional对象："><a href="#创建Optional对象：" class="headerlink" title="创建Optional对象："></a>创建Optional对象：</h5><ol>
<li><p>声明一个空的Optional</p>
<p><code>Optional&lt;Car&gt; optCar= Optional.empty();</code></p>
</li>
<li><p>依据一个非空值创建Optional</p>
<p><code>Optional&lt;Car&gt; optCar = Optional.of(car);</code></p>
<p>若car是null，抛出NPE。</p>
</li>
<li><p>可接受null的Optional</p>
<p><code>Optional&lt;Car&gt; optCar = Optional.ofNullable(car);</code>    </p>
</li>
</ol>
<p>Optional提供的get方法在遭遇空的Optional对象时，也会抛出异常。</p>
<p>怎么办？</p>
<h5 id="使用map从Optional对象中提取和转换值"><a href="#使用map从Optional对象中提取和转换值" class="headerlink" title="使用map从Optional对象中提取和转换值"></a>使用map从Optional对象中提取和转换值</h5><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCarInsuranceName</span><span class="hljs-params">(Optional&lt;Person&gt; person)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> person.flatMap(Person::getCar)</span><br><span class="line">        .flatMap(Car::getInsurance)</span><br><span class="line">        .map(Insurance::getName)</span><br><span class="line">        .orElse(<span class="hljs-string">"Unknown"</span>); <span class="hljs-comment">// Optional为空时，设置默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 Optional 类设计时就没特别考虑将其作为类的字段使用，所以它也并未实现<br>Serializable 接口。</p>
<p>若要实现序列化的域模型，作为替代方案，提供一个能访问声明为 Optional 、变量值可能缺失的接口。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Car car;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Optional&lt;Car&gt; <span class="hljs-title">getCarAsOptional</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    	<span class="hljs-keyword">return</span> Optional.ofNullable(car);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CompleptableFuture-组合式异步编程"><a href="#CompleptableFuture-组合式异步编程" class="headerlink" title="CompleptableFuture:组合式异步编程"></a>CompleptableFuture:组合式异步编程</h3><h4 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h4><p>它设计初衷是为将来某个时刻会发生的结果进行建模。</p>
<p><img src="http://ww1.sinaimg.cn/large/005wR1ytgy1fx5deji7d2j30q90ao0um.jpg" alt=""></p>
<p>这种编程方式让你的线程可以在 ExecutorService 以并发方式调用另一个线程执行耗时操作的同时，去执行一些其他的任务。接着，如果你已经运行到没有异步操作的结果就无法继续任何有意义的工作时，可以调用它的 get 方法去获取操作的结果。如果操<br>作已经完成，该方法会立刻返回操作的结果，否则它会阻塞你的线程，直到操作完成，返回相应的结果。</p>
<p>Future 接口的局限性：很难表述 Future 结果之间的依赖性。</p>
<p>于是CompletableFuture，CompletableFuture 和 Future 的关系就跟 Stream 和 Collection 的关系一样。</p>
<h4 id="使用-CompletableFuture-构建异步应用"><a href="#使用-CompletableFuture-构建异步应用" class="headerlink" title="使用 CompletableFuture 构建异步应用"></a>使用 CompletableFuture 构建异步应用</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Future&lt;Double&gt; <span class="hljs-title">getPriceAsync</span><span class="hljs-params">(String product)</span> </span>&#123;</span><br><span class="line">	CompletableFuture&lt;Double&gt; futurePrice = <span class="hljs-keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    <span class="hljs-keyword">new</span> Thread( () -&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">double</span> price = calculatePrice(product);</span><br><span class="line">    futurePrice.complete(price);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-comment">// 无需等待尚未结束的计算，直接返回Future对象</span></span><br><span class="line">    <span class="hljs-keyword">return</span> futurePrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用工厂方法-supplyAsync-创建-CompletableFuture"><a href="#使用工厂方法-supplyAsync-创建-CompletableFuture" class="headerlink" title="使用工厂方法 supplyAsync 创建 CompletableFuture"></a>使用工厂方法 supplyAsync 创建 CompletableFuture</h5><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> Future&lt;Double&gt; <span class="hljs-title">getPriceAsync</span><span class="hljs-params">(String product)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; calculatePrice(product));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>supplyAsync 方法接受一个生产者（ Supplier ）作为参数，返回一个CompletableFuture对象，该对象完成异步执行后会读取调用生产者方法的返回值。</p>
<p>生产者方法会交由 ForkJoinPool池中的某个执行线程（ Executor ）运行，但是你也可以使用 supplyAsync 方法的重载版本，传递第二个参数指定不同的执行线程执行生产者方法。一般而言，向 CompletableFuture 的工厂方法传递可选参数，指定生产者方法的执行线程是可行的。</p>
<h5 id="使用-CompletableFuture-发起异步请求"><a href="#使用-CompletableFuture-发起异步请求" class="headerlink" title="使用 CompletableFuture 发起异步请求"></a>使用 CompletableFuture 发起异步请求</h5><p><img src="http://ww1.sinaimg.cn/large/005wR1ytgy1fx5drh2b6uj30u608k3zg.jpg" alt=""></p>
<p>这里使用两个不同的Stream流水线的原因是：流操作之间存在延迟。如果在单一的流水线中处理流，发向不同商家的请求只能以同步、顺序执行的方式才会成功。</p>
<h3 id="寻找更好的方案"><a href="#寻找更好的方案" class="headerlink" title="寻找更好的方案"></a>寻找更好的方案</h3><p> 当任务数超过四个时，定制执行器。</p>
<p>N(threads) = N(CPU) <em> U(CPU) </em> (1 + W/C)<br>其中：</p>
<ul>
<li>N CPU 是处理器的核的数目，可以通过 Runtime.getRuntime().availableProce-<br>ssors() 得到</li>
<li>U CPU 是期望的CPU利用率（该值应该介于0和1之间）</li>
<li>W/C是等待时间与计算时间的比率</li>
</ul>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Executor executor =</span><br><span class="line">    Executors.newFixedThreadPool(Math.min(shops.size(), <span class="hljs-number">100</span>),</span><br><span class="line">        <span class="hljs-keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="hljs-keyword">new</span> Thread(r);</span><br><span class="line">            t.setDaemon(<span class="hljs-keyword">true</span>);</span><br><span class="line">            <span class="hljs-keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>Java程序无法终止或者退出一个正在运行中的线程，所以最后剩下的那个线程会由于一直等待无法发生的事件而引发问题。与此相反，如果将线程标记为守护进程，意味着程序退出时它也会被回收。这二者之间没有性能上的差异。</p>
<h4 id="并行——使用流还是-CompletableFutures-？"><a href="#并行——使用流还是-CompletableFutures-？" class="headerlink" title="并行——使用流还是 CompletableFutures ？"></a>并行——使用流还是 CompletableFutures ？</h4><ul>
<li>如果进行的是计算密集型的操作，并且没有IO，推荐使用Stream接口，因为实现简单，同时效率也可能是最高的（如果所有线程都是计算密集型，根据以上估算公式，就没有必要创建比处理器核数更多的线程）。</li>
<li>反之，如果你并行的工作单元还涉及等待I/O的操作（包括网络连接等待），那么使用CompletableFuture 灵活性更好，你可以像前文讨论的那样，依据等待/计算，或者W/C的比率设定需要使用的线程数。这种情况不使用并行流的另一个原因是，处理流的流水线中如果发生I/O等待，流的延迟特性会让我们很难判断到底什么时候触发了等待。</li>
</ul>
<h4 id="对多个异步任务进行流水线操作"><a href="#对多个异步任务进行流水线操作" class="headerlink" title="对多个异步任务进行流水线操作"></a>对多个异步任务进行流水线操作</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">findDiscountFuture</span><span class="hljs-params">(String product)</span> </span>&#123;</span><br><span class="line">        List&lt;CompletableFuture&lt;String&gt;&gt; futureList = shops.stream()</span><br><span class="line">                .map(shop -&gt;</span><br><span class="line">                        CompletableFuture.supplyAsync(</span><br><span class="line">                                () -&gt; shop.getName() + <span class="hljs-string">" price is "</span> + shop.getPrice(product),executor))</span><br><span class="line">                .map(future -&gt; future.thenApply(Quote::parse))</span><br><span class="line">                .map(future -&gt; future.thenCompose(quote -&gt;</span><br><span class="line">                        CompletableFuture.supplyAsync(</span><br><span class="line">                                () -&gt; Discount.applyDiscount(quote), executor)))</span><br><span class="line">                .collect(toList());</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> futureList.stream()</span><br><span class="line">                .map(CompletableFuture::join)</span><br><span class="line">                .collect(toList());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>thenCompose方法允许对两个异步操作进行流水线，第一个操作完成时，将其结果作为参数传递给第二个操作。换句话说，即创建两个CompletableFuture对象调用thenCompose，并向其传递一个Function。当第一个CompletableFuture执行完毕后，它的结果结果将作为该函数的参数， 这个函数返回值是以第一个 CompletableFuture 的返回做输入计算出的第二个 CompletableFuture 对象。</p>
<p> thenCompose 方法像 CompletableFuture 类中的其他方法一<br>样，也提供了一个以 Async 后缀结尾的版本 thenComposeAsync 。通常而言，名称中不带 Async的方法和它的前一个任务一样，在同一个线程中运行；而名称以 Async 结尾的方法会将后续的任务提交到一个线程池，所以每个任务是由不同的线程处理的。就这个例子而言，第二个CompletableFuture 对象的结果取决于第一个CompletableFuture ，所以无论你使用哪个版本的方法来处理 CompletableFuture 对象，对于最终的结果，或者大致的时间而言都没有多少差别。我们选择 thenCompose 方法的原因是因为它更高效一些，因为少了很多线程切换的开销。</p>
<p>主线程还能执行其它重要的操作，如响应UI。</p>
<p>另一种比较常见的情况是，你需要将两个完全不相干的 CompletableFuture 对象的结果整合起来，而且你也不希望等到第一个任务完全结束才开始第二项任务。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Double&gt; futurePriceInUSD =</span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; shop.getPrice(product))</span><br><span class="line">    .thenCombine(</span><br><span class="line">    	CompletableFuture.supplyAsync(</span><br><span class="line">    		() -&gt; exchangeService.getRate(Money.EUR, Money.USD)),</span><br><span class="line">    		(price, rate) -&gt; price * rate</span><br><span class="line">   	 	);</span><br></pre></td></tr></table></figure>
<p>这里thenCombine方法，它接受BiFunction作为第二个参数，这个参数定义了两个CompletableFuture 对象完成计算后，如何合并结果。它的Async版本是：导致BiFunction中定义的合并操作被提交到线程池中，由另一个任务以异步的方式执行。<strong>其中的两个CompletableFuture 对象是在不同的线程执行的。</strong></p>
<p><strong>CompletableFuture 利用Lambda表达式以声明式的API提供了一种机制，能够用最有效的方式，非常容易地将多个以同步或异步方式执行复杂操作的任务结合到一起。</strong></p>
<h4 id="响应-CompletableFuture-的-completion-事件"><a href="#响应-CompletableFuture-的-completion-事件" class="headerlink" title="响应 CompletableFuture 的 completion 事件"></a>响应 CompletableFuture 的 completion 事件</h4><p>避免的首要的问题是，等待创建一个包含了所有价格的List创建完成。应该直接处理CompletableFuture。这样每个 CompletableFuture 都在为某个商店执行必要的操<br>作。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> Stream&lt;CompletableFuture&lt;String&gt;&gt; findDiscountStream(String product) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> shops.stream()</span><br><span class="line">                .map(shop -&gt;</span><br><span class="line">                        CompletableFuture.supplyAsync(</span><br><span class="line">                                () -&gt; shop.getName() + <span class="hljs-string">" price is "</span> + shop.getPrice(product),</span><br><span class="line">                                executor))</span><br><span class="line">                .map(future -&gt; future.thenApply(Quote::parse))</span><br><span class="line">                .map(future -&gt; future.thenCompose(quote -&gt;</span><br><span class="line">                        CompletableFuture.supplyAsync(</span><br><span class="line">                                () -&gt; Discount.applyDiscount(quote), executor)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">findPricesStream(<span class="hljs-string">"myPhone"</span>).map(f -&gt; f.thenAccept(System.out::println));</span><br></pre></td></tr></table></figure>
<p>thenAccept方法也有Async版本。异步版本会对处理结果的消费者进行调度，从线程池中选择一个新的线程继续执行，不再由同一个线程完成CompletableFuture的所有任务。</p>
<p>如果想避免不必要的上下文切换，避免在等待线程上浪费时间，尽快响应CompletableFuture的completion事件，可以不使用异步版本。</p>
<p>由于 thenAccept 方法已经定义了如何处理 CompletableFuture 返回的结果，一旦<br>CompletableFuture 计算得到结果，它就返回一个<code>CompletableFuture&lt;Void&gt;</code>。</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture[] futures = findPricesStream(<span class="hljs-string">"myPhone"</span>)</span><br><span class="line">    .map(f -&gt; f.thenAccept(System.out::println))</span><br><span class="line">    .toArray(size -&gt; <span class="hljs-keyword">new</span> CompletableFuture[size]);</span><br><span class="line">CompletableFuture.allOf(futures).join();</span><br></pre></td></tr></table></figure>
<p>allOf 工厂方法接收一个由 CompletableFuture 构成的数组，数组中的所有CompletableFuture 对象执行完成之后，它返回一个<code>CompletableFuture&lt;Void&gt;</code> 对象。这意味着，如果你需要等待最初 Stream 中的所有 CompletableFuture 对象执行完毕，对 allOf 方法返回的CompletableFuture 执行 join 操作是个不错的主意。</p>
<p>然而在另一些场景中，你可能希望只要 CompletableFuture 对象数组中有任何一个执行完毕就不再等待，比如，你正在查询两个汇率服务器，任何一个返回了结果都能满足你的需求。在这种情况下，你可以使用一个类似的工厂方法 anyOf 。该方法接收一个 CompletableFuture 对象构成的数组，返回由第一个执行完毕的 CompletableFuture 对象的返回值构成的<code>CompletableFuture&lt;Object&gt;</code> 。</p>
<h3 id="新的日期和时间API"><a href="#新的日期和时间API" class="headerlink" title="新的日期和时间API"></a>新的日期和时间API</h3>
        </div>
        
        <div class="level is-size-7 is-uppercase">
            <div class="level-start">
                <div class="level-item">
                    <span class="is-size-6 has-text-grey has-mr-7">#</span>
                    <a class="has-link-grey -link" href="/tags/java/">java</a>
                </div>
            </div>
        </div>
        
        
        
    </div>
</div>





<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        <div class="level-start">
            <a class="level level-item has-link-grey  article-nav-prev" href="/2018/11/20/python/problem/">
                <i class="level-item fas fa-chevron-left"></i>
                <span class="level-item">Python编程中邂逅的问题</span>
            </a>
        </div>
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/2018/11/02/python/fluentpy2/">
                <span class="level-item">FluentPy Note（2）</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>


</div>
                




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered">
                <div>
                    
                        <img class="image is-128x128 has-mb-6" src="/images/avatar.png" alt="PIO">
                    
                    
                    <p class="is-size-4 is-block">
                        PIO
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        Master
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>Wuhan</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Articles
                    </p>
                    <p class="title has-text-weight-normal">
                        14
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Catégories
                    </p>
                    <p class="title has-text-weight-normal">
                        0
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Tags
                    </p>
                    <p class="title has-text-weight-normal">
                        4
                    </p>
                </div>
            </div>
        </nav>
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/Langzi418" target="_blank">
                SUIVRE</a>
        </div>
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Github" href="https://github.com/Langzi418">
                
                <i class="fab fa-github"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        
    
        
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Nuage de tags
        </h3>
        <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/bigdata/" style="font-size: 10px;">bigdata</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/python/" style="font-size: 15px;">python</a>
    </div>
</div>

    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
            
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Récents
        </h3>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-04-22T10:04:57.000Z">2019-04-22</time></div>
                    <a href="/2019/04/22/java/spring/" class="has-link-black-ter is-size-6">Spring框架的一些理解</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-04-20T12:33:57.000Z">2019-04-20</time></div>
                    <a href="/2019/04/20/java/concurrent/" class="has-link-black-ter is-size-6">Concurrent</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-03-10T12:56:57.000Z">2019-03-10</time></div>
                    <a href="/2019/03/10/java/DynamicProxy/" class="has-link-black-ter is-size-6">DynamicProxy</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-02-24T12:19:43.000Z">2019-02-24</time></div>
                    <a href="/2019/02/24/algorithm/dp/" class="has-link-black-ter is-size-6">DP Note</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-02-24T12:18:43.000Z">2019-02-24</time></div>
                    <a href="/2019/02/24/algorithm/leetcode/" class="has-link-black-ter is-size-6">LeetCode Note</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>

        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Archives
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/04/">
                <span class="level-start">
                    <span class="level-item">April 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/03/">
                <span class="level-start">
                    <span class="level-item">March 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/02/">
                <span class="level-start">
                    <span class="level-item">February 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/12/">
                <span class="level-start">
                    <span class="level-item">December 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/11/">
                <span class="level-start">
                    <span class="level-item">November 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">5</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/10/">
                <span class="level-start">
                    <span class="level-item">October 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
        
            <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Tags
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/algorithm/">
                        <span class="tag">algorithm</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/bigdata/">
                        <span class="tag">bigdata</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/java/">
                        <span class="tag">java</span>
                        <span class="tag is-grey">6</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/python/">
                        <span class="tag">python</span>
                        <span class="tag is-grey">4</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
        
        </div>
    
</div>

                




<div class="column is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only has-order-3 column-right ">
    
        
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Récents
        </h3>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-04-22T10:04:57.000Z">2019-04-22</time></div>
                    <a href="/2019/04/22/java/spring/" class="has-link-black-ter is-size-6">Spring框架的一些理解</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-04-20T12:33:57.000Z">2019-04-20</time></div>
                    <a href="/2019/04/20/java/concurrent/" class="has-link-black-ter is-size-6">Concurrent</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-03-10T12:56:57.000Z">2019-03-10</time></div>
                    <a href="/2019/03/10/java/DynamicProxy/" class="has-link-black-ter is-size-6">DynamicProxy</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-02-24T12:19:43.000Z">2019-02-24</time></div>
                    <a href="/2019/02/24/algorithm/dp/" class="has-link-black-ter is-size-6">DP Note</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-02-24T12:18:43.000Z">2019-02-24</time></div>
                    <a href="/2019/02/24/algorithm/leetcode/" class="has-link-black-ter is-size-6">LeetCode Note</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>

    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
        <h3 class="menu-label">
            Archives
        </h3>
        <ul class="menu-list">
        
        <li>
            <a class="level is-marginless" href="/archives/2019/04/">
                <span class="level-start">
                    <span class="level-item">April 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/03/">
                <span class="level-start">
                    <span class="level-item">March 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">1</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2019/02/">
                <span class="level-start">
                    <span class="level-item">February 2019</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/12/">
                <span class="level-start">
                    <span class="level-item">December 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/11/">
                <span class="level-start">
                    <span class="level-item">November 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">5</span>
                </span>
            </a>
        </li>
        
        <li>
            <a class="level is-marginless" href="/archives/2018/10/">
                <span class="level-start">
                    <span class="level-item">October 2018</span>
                </span>
                <span class="level-end">
                    <span class="level-item tag">2</span>
                </span>
            </a>
        </li>
        
        </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Tags
            </h3>
            <div class="field is-grouped is-grouped-multiline">
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/algorithm/">
                        <span class="tag">algorithm</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/bigdata/">
                        <span class="tag">bigdata</span>
                        <span class="tag is-grey">2</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/java/">
                        <span class="tag">java</span>
                        <span class="tag is-grey">6</span>
                    </a>
                </div>
                
                <div class="control">
                    <a class="tags has-addons" href="/tags/python/">
                        <span class="tag">python</span>
                        <span class="tag is-grey">4</span>
                    </a>
                </div>
                
            </div>
        </div>
    </div>
</div>
    
    
</div>

            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.svg" alt="Java8 Learn" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2019 PIO&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a
                        href="http://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>
                
                <br>
                <span id="busuanzi_container_site_uv">
                Visited by <span id="busuanzi_value_site_uv">0</span> users
                </span>
                
                </p>
            </div>
            <div class="level-end">
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-Hans");</script>


    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>

    
    

<a id="back-to-top" title="Back to Top" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    
    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>
    <script src="/js/clipboard.js" defer></script>
    

    
    
    

    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Articles',
                PAGES: 'Pages',
                CATEGORIES: 'Catégories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>