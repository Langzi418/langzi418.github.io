<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>知识点总结</title>
      <link href="/2019/09/21/java/interview/"/>
      <url>/2019/09/21/java/interview/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="hashCode-和equals"><a href="#hashCode-和equals" class="headerlink" title="hashCode()和equals()"></a>hashCode()和equals()</h3><p>如果两个对象equals()，那么hashCode()一定相等。（想想散列表）</p><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p>IO 阻塞、对每个连接创建一个线程处理</p><p>NIO Selector（Netty）</p><p>AIO 线程池异步处理</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>关键代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;  <span class="comment">//定位索引位置</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>良好的Hash算法和扩容机制是的Hash碰撞的概率减少并且哈希桶数组占用的空间少。</p><p><code>threshold = length*Load factor</code> 。默认的负载因子0.75是对空间和时间效率的平衡。</p><p>HashMap中table的length必须为2的幂（若自定义initial capacity，会指定为大于它的最小2的幂），这样做是为了在<strong>取模和扩容时做优化</strong>。</p><p>为了减少冲突，HashMap定位哈希桶索引位置时，加入了高位参与运算。</p><p>HashMap中哈希算法：取key的hashCode()值、高位运算、取模运算。</p><p>Java8在扩容时的链表部分的优化，Java7是“重新计算索引+头插法”，Java8在重新计算索引时做了优化，计算快。下图中新增的比特可以认为是随机的，则在扩容时，均匀地将冲突地结点分散到新链表。</p><p><img src="https://i.loli.net/2019/09/22/gmxNESoPFi1KUJC.jpg" alt=""></p><p>多线程时，可能在put、resize后形成环形链表。</p><p>链表元素大于等于8，链表转化为树；扩容时若链表元素小于等于6，转化为链表。红黑树的平均查找长度log(n)，链表为n/2。当n&gt;=8时，有转化为树的必要。另外，在6和8之间有7，可以有效避免树和链表的频繁转化。</p><p>Reference</p><p><a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">java8之重新认识HashMap</a></p><p><a href="https://javadoop.com/post/hashmap#toc9" target="_blank" rel="noopener">Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析</a></p><h4 id="HashMap树化的过程"><a href="#HashMap树化的过程" class="headerlink" title="HashMap树化的过程"></a>HashMap树化的过程</h4><p>TREEIFY_THRESHOLD = 8</p><p>MIN_TREEIFY_CAPACITY = 64</p><p>以上两者同时满足时，才树化。</p><p><a href="https://blog.csdn.net/fan2012huan/article/details/51088211" target="_blank" rel="noopener">HashMap的扩容及树化过程</a></p><p><a href="https://blog.csdn.net/xiao1_1bing/article/details/81870708" target="_blank" rel="noopener">HashMap分析之红黑树树化过程</a></p><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>1.7 Segment extends ReentrantLock</p><p>1.8 CAS + synchronized</p><p>由于已经使用volatile保证了key、value可见性，所以在get时不需要加锁。</p><h4 id="Collections-synchronizedMap-和ConcurrentHashMap区别"><a href="#Collections-synchronizedMap-和ConcurrentHashMap区别" class="headerlink" title="Collections.synchronizedMap()和ConcurrentHashMap区别"></a>Collections.synchronizedMap()和ConcurrentHashMap区别</h4><p><a href="https://stackoverflow.com/questions/510632/whats-the-difference-between-concurrenthashmap-and-collections-synchronizedmap" target="_blank" rel="noopener">https://stackoverflow.com/questions/510632/whats-the-difference-between-concurrenthashmap-and-collections-synchronizedmap</a></p><h3 id="其他容器源码"><a href="#其他容器源码" class="headerlink" title="其他容器源码"></a>其他容器源码</h3><p><a href="http://cmsblogs.com/?p=4781" target="_blank" rel="noopener">【死磕 Java 集合】— 总结篇</a></p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>Lock前缀指令。</p><p>1）将当前处理器缓存行的数据写回到系统内存。</p><p>2）以上写回内存操作会使其他CPU里缓存了该内存地址的数据无效。</p><p>指令重排。</p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>任何一个对象都有一个monitor与之关联，当monitor被持有后，它将处于锁定状态。</p><p>代码同步块：monitorenter时，尝试获取monitor；monitorexit时，释放monitor。</p><p>同步方法：有ACC_SYNCHRONIZED标志，进入方法获取monitor，方法结束释放monitor。</p><p><a href="https://www.zybuluo.com/kiraSally/note/857726" target="_blank" rel="noopener">并发番@Synchronized一文通（1.8版）</a></p><h3 id="Java实现原子操作"><a href="#Java实现原子操作" class="headerlink" title="Java实现原子操作"></a>Java实现原子操作</h3><p>CAS+自旋、锁</p><p>CAS的“ABA”问题：A-&gt;B-&gt;A，那么CAS操作就会认为A没有变过，可以通过控制变量值的版本来保证CAS操作的正确性。JUC中提供了一个带有标记的原子类来解决此问题。但大多数情况下ABA问题并不会影响程序并发的正确性，所以如果需要解决ABA问题，采用传统的互斥同步可能更高效。</p><h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>CAS实现，AtomicInteger等可做计数器，更好的实现：LongAdder。</p><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>线程封闭</p><p>ThreadLocal提供了get和set等方法，这些方法为每个使用该变量的内存都存有一份独立的副本。</p><p>ThreadLocal对象通常用于防止可变的单实例变量（Singleton）或全局变量进行共享。</p><p>原理：线程的成员变量theadLocalMap是一个散列表（key为ThreadLocal，value为独立副本）。</p><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>原子性地维护同步状态state（由子类重写tryAcquire、tryRelease…）</p><p>阻塞和释放线程（LockSupport）</p><p><strong>维护阻塞线程的队列</strong>（CLH，双向链表，FIFO）</p><p><img src="https://i.loli.net/2019/10/27/R9iVZToqy1pmE6l.png" alt=""></p><p><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer" target="_blank" rel="noopener">一行一行源码分析清楚AbstractQueuedSynchronizer</a></p><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>非公平锁：如果获取锁的线程再次请求，则增加state，成功。可能造成饥饿，但线程切换少，吞吐量大。</p><p>公平锁：比非公平锁增加了当前结点是否有前驱结点的判断，若有，则不成功，FIFO。线程切换多。</p><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>高16位读状态（c&gt;&gt;&gt;16)， 低16位写状态（c&amp;((1&lt;&lt;16) -1)）。</p><p>写锁：获取时，若读锁已经被获取（读状态不为0）或者当前线程不是已经获取写锁的线程，则等待。</p><p>读锁：在没有其他写线程访问时（写状态为0），读锁成功获取。  </p><p>如果读锁存在，则写锁不能被获取。原因：若允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他线程就可能无法感知当前写线程的操作。（脏读）</p><p>锁降级：锁降级中读锁的获取是必要的。若当前线程不获取读锁而直接释放写锁，假如另一个线程获取写锁并更新数据，那么当前线程可能无法感知数据的更新（<strong>可见性</strong>）。</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>execute执行command分四种情况：</p><ol><li><p>如果当前运行线程小于corePoolSize，则创建新线程来执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = ctl.get();</span><br><span class="line"><span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    <span class="comment">// addWorker需要获取全局锁</span></span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    c = ctl.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果运行的线程大于等于corePoolSize，则将任务加入到BlockingQueue。</p></li><li><p>如果队列已满，再创建新的线程来处理任务（addWorker（command, false））。</p></li><li><p>如果创建新线程将使当前运行的线程超出maxinumPoolSize，任务将被拒绝，执行饱和策略。</p></li></ol><p>在ThreadPoolExecutor完成预热后（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都执行步骤2，而它不需要获取全局锁。</p><p><strong>工作线程</strong>：线程池创建线程时，会将线程封装成Worker，Worker在执行完任务后，还会循环获取BlockingQueue中的Worker来执行。</p><p><strong>提交任务</strong>：pool.execute(Runnable);      Future\<object> future = pool.submit(Runnable);</object></p><p><strong>关闭线程池</strong>：</p><p>shutdown和shutdownNow都会通知线程池不再接受任务，都会立即返回。</p><p>区别：showdown仅中断空闲线程，使得BlockingQueue中的线程可以被剩下的线程执行，该方法返回值为void。showdownNow中断所有线程，返回BlockingQueue中的线程列表。</p><h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p><code>ThreadPoolExecutor(corePoolsize,  maxPoolSize,  keepAliveTime, BlockingQueue)</code></p><p>当线程池中的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待任务的最长时间，超时则线程终止。</p><h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><p>使用无界队列LinkedBlockingQueue作为线程池的工作队列（容量Integer.MAX_VALUE）。影响：</p><p>1）线程池中的线程数达到coerPoolSize后，新任务将在无界队列中等待，所以线程池中的线程数将不会超过corePoolSize。</p><p>适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，它适用于负载比较重的服务器。</p><h4 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h4><p>LinkedBlockingQueue</p><p>corePoolSize=1</p><p>适用于需要保证顺序地执行各个任务；并且在任意地时间点不会有多个线程是活动的应用场景。</p><h4 id="CacheThreadPool"><a href="#CacheThreadPool" class="headerlink" title="CacheThreadPool"></a>CacheThreadPool</h4><p>SynchronousQueue</p><p>corePoolSize=0, maxPoolSize=Integer.MAX_VALUE</p><p>如果主线程提交任务的速度高于maxPool中处理任务的速度，它会不断地创建新的线程。</p><p>适用于执行很多的短期异步任务小程序，或负载较轻的服务器。</p><p>Reference</p><p>《Java并发编程实战》</p><p>《Java并发编程的艺术》</p><p> <a href="http://cmsblogs.com/?cat=151" target="_blank" rel="noopener">死磕Java并发</a></p><h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>记录正在执行的虚拟机字节码指令的地址。</p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p><p>-Xss 可以指定每个线程的Java虚拟机栈内存大小</p><p>异常：</p><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出Stackoverflow异常；</p><p>如果虚拟机栈扩展时无法申请到足够的内存，会抛出OOM异常。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>与Java虚拟机栈类似</p><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>几乎所有的对象实例以及数组都要在堆上分配，是垃圾收集器管理的主要区域。</p><p>从内存回收的角度来看：堆可分为新生代和老年代</p><p>从内存分配的进度来看：堆中可能划分出多个、线程私有的分配缓冲区</p><p>-Xms 可以指定堆初始值、-Xmx可以设置最大值</p><p>堆不需要物理上连续。若堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OOM异常。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><p>在单CPU的环境中，serial由于没有线程交互的开销，所以能获得最高的单线程收集效率。</p><h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><p>Serial的多线程版本。</p><h4 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h4><p>目标是达到一个可控制的吞吐量。这里，吞吐量=运行用户代码的时间/（运行用户代码的时间+垃圾收集的时间）。高吞吐量可以高效地利用CPU时间，尽快完成程序的计算任务，主要适合在后台计算而不需要太多交互的场景。</p><p>-XX:MaxGCPauseMills（最大垃圾收集停顿时间） -XX:GCTimeRatio（垃圾收集时间占总时间的比率） </p><p>GC时间的缩短是以牺牲吞吐量的和新生代的空间来换取的：系统把新生代的空间调小。</p><h4 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h4><p>Serial的老年代版本。</p><h4 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h4><p>parallel scavenge的老年代版本。</p><h4 id="CMS（Concurrent-Mark-Sweep）"><a href="#CMS（Concurrent-Mark-Sweep）" class="headerlink" title="CMS（Concurrent Mark Sweep）"></a>CMS（Concurrent Mark Sweep）</h4><p>目标是获得最短的回收停顿时间。</p><p>4个步骤：</p><p>1）初始标记：只标记GC Roots能直接关联到的对象，速度很快，需要停顿；</p><p>2）并发标记：GC Roots Tracing的过程；</p><p>3）重新标记：修正并发标记期间因用户程序继续运行导致标记产生变动的那一部分对象的标记记录，停顿稍长一些；</p><p>4）并发清除。</p><p><img src="https://i.loli.net/2019/11/11/HDFZ3Ej62nCBxV4.jpg" alt=""></p><p><a href="https://www.cnblogs.com/littleLord/p/5380624.html" target="_blank" rel="noopener">详解CMS垃圾回收机制</a></p><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><p>使用大小相等的独立区域（Region）划分内存以及按优先级来回收内存。</p><p>新生代和老年代不再是物理隔离的，它们都是一部分Region（不需要连续）的集合。</p><h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>分为新生代和老年代。</p><p>新生代：每次垃圾收集时都发现大量的对象死亡，存活率低。可以使用复制算法进行收集，只需要使用少量的复制成本，算法简单，效率高。</p><p>老年代：对象存活率高、没有额外空间对它进行分配担保，必须使用“标记——清理”，或者“标记——整理”。</p><p>大多数情况下，对象在新生代Eden区中分配。很长的字符串以及数组直接进入老年代。</p><h4 id="Full-GC-amp-Minor-GC"><a href="#Full-GC-amp-Minor-GC" class="headerlink" title="Full GC&amp;Minor GC"></a>Full GC&amp;Minor GC</h4><p>young GC：当young gen中的eden区分配满的时候触发。注意young GC中有部分存活对象会晋升到old gen，所以young GC后old gen的占用量通常会有所升高。</p><p>full GC：当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发young GC而是转为触发full GC（因为HotSpot VM的GC里，除了CMS的concurrent collection之外，其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先触发一次单独的young GC）；或者，如果有perm gen的话，要在perm gen分配空间但已经没有足够空间时，也要触发一次full GC；或者System.gc()、heap dump带GC，默认也是触发full GC。</p><p><a href="https://juejin.im/post/5b8d2a5551882542ba1ddcf8" target="_blank" rel="noopener">JVM 系列文章之 Full GC 和 Minor GC</a></p><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p><a href="https://www.cnblogs.com/fefjay/p/6305499.html" target="_blank" rel="noopener">Java类编译、加载、和执行机制</a></p><p><a href="https://juejin.im/post/5c04892351882516e70dcc9b" target="_blank" rel="noopener">老大难的 Java ClassLoader 再不理解就老了</a></p><h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><p>情形一：<strong>受到加载范围的限制</strong>，顶层加载器（Boot、Ext）无法加载到用户代码。</p><p>解决：设置线程上下文类加载器，可以在父类加载时使用这个加载器去加载所需的用户代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Launcher.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过聚合实现双亲委派，每个ClassLoader对象内部都有一个parent属性指向它的父加载器。</span></span><br><span class="line">var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line"><span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认将AppClassLoader设置为ContextClassLoader</span></span><br><span class="line">Thread.currentThread().setContextClassLoader(<span class="keyword">this</span>.loader);</span><br></pre></td></tr></table></figure><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><p>where子句指定行的条件，having子句指定组的条件。</p><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p><a href="https://segmentfault.com/a/1190000013695030" target="_blank" rel="noopener">数据库逻辑设计之三大范式通俗理解</a></p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="B-Tree-B-Tree"><a href="#B-Tree-B-Tree" class="headerlink" title="B-Tree/B+Tree"></a>B-Tree/B+Tree</h3><p>m阶B树和B+树的主要区别在于：</p><ol><li>在B+树中，<strong>叶节点包含信息</strong>，所有非叶节点仅起索引作用，非叶节点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，<strong>不含有</strong>该关键字对应记录的<strong>存储地址</strong>。</li><li>B+树中，叶节点包含了<strong>全部关键字</strong>，且相邻叶节点是链接起来的；而在B树中，叶节点包含的关键字和非叶节点包含的关键字<strong>不重复</strong>。</li></ol><p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式<strong>存储在磁盘</strong>上。这样的话，索引查找过程中就要产生<strong>磁盘I/O消耗</strong>，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的时间复杂度。</p><p>数据库系统的设计者巧妙利用了磁盘预读原理，将一个<strong>节点的大小设为等于一个页</strong>，这样<strong>每个节点只需要一次I/O就可以完全载入</strong>。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p><p>每次新建节点时，直接申请一个页的空间，<strong>这样就保证一个节点物理上也存储在一个页里</strong>，加之计算机存储分配都是按页对齐的，就实现了一个节点只需一次I/O。</p><p><strong>B-Tree/B+Tree与红黑树比较</strong></p><p>平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。</p><p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</p><p><strong>B+Tree与B-Tree比较</strong></p><p>B+Tree更适合索引，原因和节点出度d有关。d越大索引的性能越好，<strong>而出度的上限取决于节点内key和data的大小</strong>：<br>$$<br>dmax=floor(pagesize/(keysize+datasize+pointsize))<br>$$<br>由于B+Tree内节点<strong>去掉了data域</strong>，因此可以拥有更大的出度，拥有更好的性能。</p><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>保证二叉查找树的平衡性代价太高。</p><p>为了保证查找树的平衡性，我们需要一些灵活性，因此可以允许树中的一个节点保存多个键——2-3查找树。</p><p>2-3树中将一个4-节点分解为一棵2-3树可能有6种情况。每个变换（分解）都会将4-节点中的中键送入到父节点中，并重构相应的链接而不必涉及树的其他部分。这种局部变换<strong>不会影响树的全局有序性和平衡性</strong>。</p><p>红黑二叉查找树背后基本思想是用标准的二叉查找树和一些额外的信息（替换3-节点）来<strong>表示2-3树</strong>。</p><p><strong>左斜</strong>红链接表示两个2-节点连接起来构成一个3-节点，黑链接则是2-3树中的普通链接。</p><p>满足定义的红黑树与2-3树一一对应。</p><p>三种操作：左旋转、右旋转和颜色转换，这三种操作本质上是<strong>将红链接向上传递</strong>。</p><p><img src="https://i.loli.net/2019/11/14/VjCeM4JTcZzyrwO.jpg" alt=""></p><p>Reference</p><p>《算法（第四版）》</p><h3 id="索引的适用条件"><a href="#索引的适用条件" class="headerlink" title="索引的适用条件"></a>索引的适用条件</h3><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>多键值B+树</p><h4 id="匹配最左列"><a href="#匹配最左列" class="headerlink" title="匹配最左列"></a>匹配最左列</h4><p>最左列相等时，才能继续往下使用索引。    </p><p>《MySQL是怎样运行的：从根儿上理解MySQL》</p><h3 id="高性能索引策略"><a href="#高性能索引策略" class="headerlink" title="高性能索引策略"></a>高性能索引策略</h3><h4 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h4><p>索引不能是表达式的一部分，也不能是函数的参数。</p><h4 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h4><p>选择足够长的前缀以保证较高的选择性，同时又不能太长。前缀索引应该足够长，使得前缀索引的选择性<strong>接近于索引整个列</strong>。</p><p>一般来说，可以通过计算索引的选择性来确定前缀列的长度。不过，也要考虑数据分布不均匀的情况。</p><p>前缀索引的缺点：MySQL不能使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描（后面介绍）。</p><p>MySQL不支持后缀索引，可通过逆序存储数据实现“后缀索引”。</p><h4 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h4><p>在出现索引合并时，应考虑查询和表的单列索引是否合适。</p><p>给了三个查询 where分别是 a=? b=? 、b=? c=?、c=? a=?，问怎么建索引查找效率高。</p><h4 id="索引列的顺序"><a href="#索引列的顺序" class="headerlink" title="索引列的顺序"></a>索引列的顺序</h4><p>经验法则：把选择性最高的放在前列。</p><h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>是一种<strong>数据存储</strong>方式。InnoDB中聚簇索引是在同一个结构中保存了索引和数据行。InnoDB通过主键聚簇数据。</p><p>二级索引保存<strong>主键值</strong>。</p><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>一个索引包含（覆盖）所需要查询的字段的值。</p><p>对于InnoDB，如果二级索引保存的主键值能够覆盖查询，则可以避免对主键索引的二次查询。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>原子性</p><p>不可分割，要么全部成功提交，要么全部失败回滚。</p><p>一致性</p><p>数据库总是从一个一致性状态转换到另一个一致性状态（典型例子：转账时资金的增减）。</p><p><strong>隔离性</strong></p><p>通常来说，一个事务的修改在最终提交之前，对于其他事物是不可见的。</p><p>持久性</p><p>一旦事务提交，其所做的修改被永久保存在数据库中。</p><h3 id="ACID实现"><a href="#ACID实现" class="headerlink" title="ACID实现"></a>ACID实现</h3><p><a href="https://www.cnblogs.com/rjzheng/p/10841031.html" target="_blank" rel="noopener">Mysql中事务ACID实现原理</a></p><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>Read Uncommit（未提交读）</p><p>在事务未提交前，其他事务就可以读。事务可以读取未提交的数据，即脏读。在实际过程中很少使用。</p><p>Read Commint（提交读）</p><p>事务从开始直到提交之前，所做的修改对其他事务都是不可见的。可以解决脏读。但是，不可重复读。</p><p>Repeatable Read（可重复读）</p><p>该级别保证同一个事务<strong>多次读取同样记录</strong>的结果是一致的。但可能出现幻读，即某个事务在读取某个范围类的记录时，另外一个事务又在该范围内插入新的记录。</p><p><strong>MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的</strong></p><p>MySQL默认。</p><p>Serializable（可串行化）</p><p>在读取的每一行加锁，所以可能导致大量的超时和锁争用的问题。实际也很少使用。</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h3><p>对于InnoDB的存储引擎，它的聚簇索引中都包含了两个必要的隐藏列：</p><ul><li>trx_id：事务对记录进行修改时，会将事务的id赋值给trx_id。</li><li>roll_pointer：事务对记录进行修改时，会将旧版本写入undo日志中，然后这个隐藏列指向undo日志。</li></ul><p>随着更新次数的增多，所有的版本都会被<code>roll_pointer</code>属性连接成一个<strong>链表</strong>，我们把这个链表称之为<code>版本链</code>，版本链的头节点就是当前记录最新的值。</p><h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>对于使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务来说，核心问题就是：<strong>需要判断一下版本链中的哪个版本是当前事务可见的</strong>。</p><p>ReadView中有四个重要内容：</p><ul><li>m_ids：表示在生成ReadView时，当前系统中活跃的读写事务的id列表。</li><li>min_trx_id：m_ids最小值。</li><li>max_trx_id：表示在生成ReadView时，应该分配给下一个事务的id值。</li><li>creator_trx_id：表示生成该ReadView的事务的id。</li></ul><blockquote><p>只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。</p></blockquote><p>有了这个<code>ReadView</code>，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p><ul><li>trx_id = creator_trx_id</li><li>被访问版本的trx_id &lt; min_trx_id，表明生成该版本的事务在当前事务生成<code>ReadView</code>前已经提交，所以该版本可以被当前事务访问。</li><li>被访问版本的trx_id &gt; max_trx_id，表明生成该版本的事务在当前事务生成<code>ReadView</code>后才开启，所以该版本不可以被当前事务访问。    </li><li>被访问版本的<code>trx_id</code>属性值在<code>min_trx_id</code>和<code>max_trx_id</code>之间，那就需要判断一下<code>trx_id</code>属性值是不是在<code>m_ids</code>列表中，如果在，说明创建<code>ReadView</code>时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建<code>ReadView</code>时生成该版本的事务已经被提交，该版本可以被访问。</li></ul><p>MVCC指的就是在使用<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两种隔离级别的事务在执行普通的<code>SEELCT</code>操作时<strong>访问记录的版本链的过程</strong>，这样子可以使不同事务的<code>读-写</code>、<code>写-读</code>操作并发执行，从而提升系统性能。<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两个隔离级别的一个很大不同就是：生成ReadView的时机不同，READ COMMITTD在<strong>每一次进行普通SELECT操作前都会生成一个ReadView</strong>，而REPEATABLE READ只在<strong>第一次进行普通SELECT操作前生成一个ReadView</strong>，之后的查询操作都重复使用这个ReadView就好了。</p><h3 id="并发方案"><a href="#并发方案" class="headerlink" title="并发方案"></a>并发方案</h3><p>方案一：读操作利用多版本并发控制（<code>MVCC</code>），写操作进行<code>加锁</code>。</p><p>方案二：读、写操作都采用<code>加锁</code>的方式。</p><p>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本，比方在银行存款的事务中。</p><p>采用<code>MVCC</code>方式的话，<code>读-写</code>操作彼此并不冲突，性能更高，采用<code>加锁</code>方式的话，<code>读-写</code>操作彼此需要排队执行，影响性能。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>共享锁（S锁）</p><p>排他锁（X锁）</p><h3 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h3><p>表级锁、 行级锁</p><h4 id="什么场景加表锁"><a href="#什么场景加表锁" class="headerlink" title="什么场景加表锁"></a>什么场景加表锁</h4><ol><li>全表更新。事务需要更新大部分数据，且表较大。若使用行锁，会导致事务执行效率低，从而可能造成其他事务长时间锁等待和更多的锁冲突。</li><li>多表查询。事务涉及多个表，比较复杂的关联查询，很可能引起死锁，造成大量事务回滚。这种情况若能一次性锁定事务涉及的表，从而可以避免死锁、减少数据库因事务回滚带来的开销。</li></ol><h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><ul><li>意向共享锁，英文名：<code>Intention Shared Lock</code>，简称<code>IS锁</code>。当事务准备在某条记录上加<code>S锁</code>时，需要先在表级别加一个<code>IS锁</code>。</li><li>意向独占锁，英文名：<code>Intention Exclusive Lock</code>，简称<code>IX锁</code>。当事务准备在某条记录上加<code>X锁</code>时，需要先在表级别加一个<code>IX锁</code>。</li></ul><p>IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以<strong>快速判断表中的记录是否被上锁</strong>，以<strong>避免用遍历的方式来查看表中有没有上锁的记录</strong>，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的。</p><h4 id="InnoDB中具体的行锁形式"><a href="#InnoDB中具体的行锁形式" class="headerlink" title="InnoDB中具体的行锁形式"></a>InnoDB中具体的行锁形式</h4><p>Record Lock：单个记录</p><p>GAP：间隙锁（看SQL语句），解决幻读</p><p>Next-Key：Record + GAP</p><h4 id="insert时的加锁"><a href="#insert时的加锁" class="headerlink" title="insert时的加锁"></a>insert时的加锁</h4><p>我们前边说一个事务在执行<code>INSERT</code>操作时，如果即将插入的<code>间隙</code>已经被其他事务加了<code>gap锁</code>，那么本次<code>INSERT</code>操作会阻塞，并且当前事务会在该间隙上加一个<code>插入意向锁</code>，否则一般情况下<code>INSERT</code>操作是不加锁的。</p><p>别的事务在对这条记录加<code>S锁</code>或者<code>X锁</code>时，由于<code>隐式锁</code>的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。</p><p>Reference</p><p>《MySQL是怎样运行的：从根儿上理解MySQL》</p><p><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">Innodb中的事务隔离级别和锁的关系</a></p><p><a href="https://juejin.im/post/5b82e0196fb9a019f47d1823" target="_blank" rel="noopener">全面了解mysql锁机制（InnoDB）与问题排查</a></p><p><a href="https://www.aneasystone.com/archives/2017/12/solving-dead-locks-three.html" target="_blank" rel="noopener">解决死锁之路 - 常见 SQL 语句的加锁分析</a></p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>InnoDB和MyISAM区别</p><ul><li>是否支持行级锁：MyISAM只有表级锁，而InnoDB支持行级锁和表级锁，默认行级锁。</li><li>是否支持事务和崩溃后的安全恢复：MyISAM不支持事务，InnoDB支持事务，崩溃恢复能力好。</li><li>是否支持外键：MyISAM不支持，InnoDB支持。</li><li>是否支持MVCC：仅InnoDB支持。</li></ul><h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>MySQL主从复制的过程概述</p><ol><li>在主库上把数据更改记录到二进制日志（binlog）中（这些记录被称为二进制事件）。</li><li>备库将主库上的日志复制到自己的中继日志（relay log）中。</li><li>备库读取中继日志中的事件，将其重放到备库数据之上。</li></ol><p>基于行和基于语句的复制。</p><p><a href="https://www.cnblogs.com/ivictor/p/5735580.html" target="_blank" rel="noopener">MySQL半同步复制</a></p><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><a href="https://redis.io/topics/data-types" target="_blank" rel="noopener">https://redis.io/topics/data-types</a></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ol><li>string：类似于Java的ArrayList，采用预分配冗余空间来减少内存的频繁分配。</li><li>list：将多个ziplist使用双向指针串起来使用。</li><li>hash：类似于Java的HashMap数组加链表，特别之处是渐进式rehash()。</li><li>set：类似于Java的HashSet。</li><li>zset：一个hash字典加一个跳跃列表。</li></ol><p><a href="https://mp.weixin.qq.com/s/gRtiSNDCuS0c8nF_Q8Tv9A" target="_blank" rel="noopener">面试官：你看过Redis数据结构底层实现吗？</a></p><p><a href="https://juejin.im/post/5d71d3bee51d453b5f1a04f1#heading-9" target="_blank" rel="noopener">深入了解Redis底层数据结构</a></p><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p><a href="https://juejin.im/post/5cf7ca6d6fb9a07ef71062d7" target="_blank" rel="noopener">15个经典的Spring面试常见问题</a></p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><p><a href="https://github.com/wolverinn/Waking-Up/" target="_blank" rel="noopener">https://github.com/wolverinn/Waking-Up/</a></p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p><a href="https://mp.weixin.qq.com/s/KH_Edj1F0FJ9fzEB4aQgew" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/KH_Edj1F0FJ9fzEB4aQgew</a></p><h2 id="HTTPs"><a href="#HTTPs" class="headerlink" title="HTTPs"></a>HTTPs</h2><p><a href="https://segmentfault.com/a/1190000011675421" target="_blank" rel="noopener">HTTPS详解</a></p><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p><a href="https://www.cnblogs.com/anker/p/3271773.html" target="_blank" rel="noopener">孤儿进程与僵尸进程总结</a></p><p><a href="https://www.cnblogs.com/aspirant/p/9166944.html" target="_blank" rel="noopener">select、poll、epoll之间的区别(搜狗面试)</a></p><h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h2 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h2><p><a href="https://juejin.im/post/5d495ad2e51d4561a54b6954" target="_blank" rel="noopener">在「不可靠」硬件上，分布式数据库如何保证数据可靠性和服务可用性？</a></p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p><a href="https://www.jianshu.com/p/fc268327d299" target="_blank" rel="noopener">分布式架构实践——负载均衡</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Algorithm Note</title>
      <link href="/2019/08/21/algorithm/algorithm/"/>
      <url>/2019/08/21/algorithm/algorithm/</url>
      
        <content type="html"><![CDATA[<p>一些算法归纳：</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> low = start, high = end + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pivot = a[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; a[--high] &gt; pivot) ;</span><br><span class="line">        a[low] = a[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; a[++low] &lt; pivot) ;</span><br><span class="line">        a[high] = a[low];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    a[low] = pivot;</span><br><span class="line"></span><br><span class="line">    quickSort(a, start, low - <span class="number">1</span>);</span><br><span class="line">    quickSort(a, low + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>自顶向下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mergeSort(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> high)&#123;</span><br><span class="line">    <span class="keyword">if</span>(high&lt;=low) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mid=low+(high-low)/<span class="number">2</span>;</span><br><span class="line">    mergeSort(a,low,mid);</span><br><span class="line">    mergeSort(a,mid+<span class="number">1</span>,high);</span><br><span class="line">    merge(a,low,mid,high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">merge(<span class="keyword">int</span>[] a,<span class="keyword">int</span> low,<span class="keyword">int</span> mid,<span class="keyword">int</span> high)&#123;</span><br><span class="line">    <span class="comment">//归并排序需要一个辅助数组</span></span><br><span class="line">    System.arraycopy(a,low,aux,low,high-low+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i=low,j=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=low;k&lt;=high;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;mid) a[k]=aux[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j&gt;high) a[k]=aux[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(aux[j]&lt;aux[i]) a[k]=aux[j++];</span><br><span class="line">        <span class="keyword">else</span> a[k]=aux[i++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>自底向上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mergeSort(<span class="keyword">int</span>[] a)&#123;</span><br><span class="line">    <span class="keyword">int</span> N=a.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> sz=<span class="number">2</span>;sz&lt;N;sz=sz+sz)&#123;</span><br><span class="line">        <span class="comment">// 当low=N-sz ，low+sz-1=N-1，只有一个区间</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> low=<span class="number">0</span>; low&lt;N-sz; low+=sz+sz)&#123;</span><br><span class="line">            merge(a,low,low+sz-<span class="number">1</span>,min(low+sz+sz-<span class="number">1</span>,N-<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表归并</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    ListNode dummy=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    dummy.next=head;</span><br><span class="line">    <span class="keyword">int</span> N=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        head=head.next;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> sz=<span class="number">1</span>; sz&lt;N; sz&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        ListNode prev=dummy,cur=dummy.next;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode left=cur;</span><br><span class="line">            ListNode right=split(left,sz);</span><br><span class="line">            cur=split(right,sz);</span><br><span class="line">            prev=merge(left,right,prev);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode <span class="title">split</span><span class="params">(ListNode head, <span class="keyword">int</span> sz)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; head.next!=<span class="keyword">null</span> &amp;&amp; i&lt;sz; i++) head=head.next;</span><br><span class="line">    ListNode right=head.next;</span><br><span class="line">    head.next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode <span class="title">merge</span><span class="params">(ListNode left, ListNode right, ListNode prev)</span></span>&#123;</span><br><span class="line">    ListNode cur=pre;</span><br><span class="line">    <span class="keyword">while</span>(left!=<span class="keyword">null</span> &amp;&amp; right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left.val &lt; right.val)&#123;</span><br><span class="line">            cur.next =left;</span><br><span class="line">            left=left.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur.next =right;</span><br><span class="line">            right=right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur=cur.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(left!=<span class="keyword">null</span>) cur.next=left;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(right!=<span class="keyword">null</span>) cur.next=right;</span><br><span class="line">    <span class="keyword">while</span>(cur.next!=<span class="keyword">null</span>) cur=cur.next;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>基本思想：将数组arr分成若干个等大的子区间（桶），分别对每个桶排序，再合并。</p><p>一般可以利用 [max(arr)-min(arr)] / arr.length来划分区间。</p><p>数据最好均匀分布，使得各个桶的数据均匀。</p><p>简版：将每个子区间大小为1，统计每个子区间个数，依次输出即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里假定数据均匀分布于0.0和1.0之间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">float</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.length;</span><br><span class="line">    List&lt;ArrayList&lt;Float&gt;&gt; buckets = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        buckets.add(i, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// (int)n*arr[i] 映射到桶中 </span></span><br><span class="line">        buckets.get((<span class="keyword">int</span>) (n * arr[i])).add(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        Collections.Sort(buckets.get(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; buckets.get(i).size(); j++)</span><br><span class="line">            arr[index++] = buckets.get(i).get(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//---- 折半查找变种 -----</span></span><br><span class="line"><span class="comment">// 第一个大于等于target</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowerBound</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 可能位于arr.length处</span></span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> low</span>=<span class="number">0</span>,high=arr.length;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=low+((high-low)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// high保证了arr[high]&gt;=mid,</span></span><br><span class="line">        <span class="keyword">if</span>(arr[mid]&lt;target) low=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> high=mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个大于target</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upperBound</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low=<span class="number">0</span>,high=arr.length;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=low+((high-low)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// high保证了arr[high]&gt;mid,</span></span><br><span class="line">        <span class="keyword">if</span>(arr[mid]&lt;=target) low=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> high=mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="链表一类距离算法"><a href="#链表一类距离算法" class="headerlink" title="链表一类距离算法"></a>链表一类距离算法</h3><p>1、求共用节点。</p><p>思想 S1 + S3 + S2 = S3 + S2 + S1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    ListNode pa=headA,pb=headB;</span><br><span class="line">    <span class="keyword">while</span>(pa!=pb)&#123;</span><br><span class="line">        pa=pa.next;</span><br><span class="line">        pb=pb.next;</span><br><span class="line">        <span class="keyword">if</span>(pa==pb) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(pa==<span class="keyword">null</span>) pa=headB;</span><br><span class="line">        <span class="keyword">if</span>(pb==<span class="keyword">null</span>) pb=headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pa;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、求环开始时的节点。</p><h3 id="快慢指针思想"><a href="#快慢指针思想" class="headerlink" title="快慢指针思想"></a>快慢指针思想</h3><p>链表回文</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast=head, slow=head;</span><br><span class="line">    <span class="keyword">while</span>(fast!=<span class="keyword">null</span> &amp;&amp; fast.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        fast=fast.next.next;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fast!=<span class="keyword">null</span>) slow=slow.next;</span><br><span class="line">    slow = reverse(slow);</span><br><span class="line">    fast= head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(slow!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast.val != slow.val)  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 链表逆序</span></span><br><span class="line"><span class="function">ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode next= head.next;</span><br><span class="line">        head.next = pre;</span><br><span class="line">        pre = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h3><h3 id="链表对折"><a href="#链表对折" class="headerlink" title="链表对折"></a>链表对折</h3><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>LeetCode  155 最小栈</p><p>用一个栈实现最小栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=min)&#123;</span><br><span class="line">        stack.push(min);</span><br><span class="line">        min = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.push(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(stack.pop() == min) min = stack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>去掉AAA、AABB，从左往右匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> n = Integer.parseInt(sc.nextLine());</span><br><span class="line">    <span class="keyword">while</span>(n--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(sc.nextLine());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=sb.length();)&#123;</span><br><span class="line">            <span class="comment">// AAA</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">3</span></span><br><span class="line">               &amp;&amp;sb.charAt(i-<span class="number">3</span>)==sb.charAt(i-<span class="number">2</span>)</span><br><span class="line">               &amp;&amp;sb.charAt(i-<span class="number">2</span>)==sb.charAt(i-<span class="number">1</span>)) &#123;</span><br><span class="line">                sb.deleteCharAt(i-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//AABB</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">4</span></span><br><span class="line">               &amp;&amp;sb.charAt(i-<span class="number">4</span>)==sb.charAt(i-<span class="number">3</span>)</span><br><span class="line">               &amp;&amp;sb.charAt(i-<span class="number">2</span>)==sb.charAt(i-<span class="number">1</span>)) &#123;</span><br><span class="line">                sb.deleteCharAt(i-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><strong>树的算法，除层次遍历外，一律优先考虑递归算法。</strong></p><p>在分析递归时，画出递归树。</p><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">floorOrder(TreeNode root)&#123;</span><br><span class="line">    Queue queue = ...;</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode p=queue.poll();</span><br><span class="line">        print(p.value);</span><br><span class="line">        <span class="keyword">if</span>(p.left!=<span class="keyword">null</span>) queue.offer(p.left);</span><br><span class="line">        <span class="keyword">if</span>(p.right!=<span class="keyword">null</span>) queue.offer(p.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归遍历"><a href="#非递归遍历" class="headerlink" title="非递归遍历"></a>非递归遍历</h3><p>递归转非递归，考虑栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">preOrder(TreeNode root)&#123;</span><br><span class="line">    TreeNode p=root;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            print(p.val);</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p=p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当p=null时，则根和左子树都遍历完了</span></span><br><span class="line">        p=stack.pop();</span><br><span class="line">        p=p.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">inOrder(TreeNode root)&#123;</span><br><span class="line">    TreeNode p=root;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p=p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当p=null，则已到达最左叶子节点，访问它并问其右子树；</span></span><br><span class="line">        <span class="comment">// 如果右子树不为空，则继续递归访问；</span></span><br><span class="line">        <span class="comment">// 如果右子树为空，则当前节点已访问完，那么访问其父节点，即出栈。</span></span><br><span class="line">        p=stack.pop();</span><br><span class="line">        print(p.val);</span><br><span class="line">        p=p.right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">postOrder(TreeNode root)&#123;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="keyword">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(p);</span><br><span class="line">            p=p.left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 考虑右子树是否为空和前序及后序遍历的思想一致，</span></span><br><span class="line">        <span class="comment">// 关键在于如何访问父节点</span></span><br><span class="line">        p = stack.peek();</span><br><span class="line">        <span class="keyword">if</span>(p.right==<span class="keyword">null</span> || p.right==last)&#123;</span><br><span class="line">            print(p.val);</span><br><span class="line">            stack.pop();</span><br><span class="line"></span><br><span class="line">            last=p;</span><br><span class="line">            p=<span class="keyword">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p=p.right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Z子形二叉树"><a href="#Z子形二叉树" class="headerlink" title="Z子形二叉树"></a>Z子形二叉树</h3><p>另外，二叉树的右视图与此题思想一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">int</span> floor=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> size=queue.size();</span><br><span class="line">        <span class="comment">// 关键思想：每次循环清空队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;i++)&#123;</span><br><span class="line">            TreeNode node;</span><br><span class="line">            <span class="keyword">if</span>((floor&amp;<span class="number">1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">                node=queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.offer(node.left); </span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.offer(node.right); </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node=queue.pollLast();</span><br><span class="line">                <span class="keyword">if</span>(node.right!=<span class="keyword">null</span>) queue.offerFirst(node.right); </span><br><span class="line">                <span class="keyword">if</span>(node.left!=<span class="keyword">null</span>) queue.offerFirst(node.left); </span><br><span class="line">            &#125;</span><br><span class="line">            tmp.add(node.val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res.add(tmp);</span><br><span class="line">        floor=<span class="number">1</span>-floor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> res=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(root1!=<span class="keyword">null</span> &amp;&amp; root2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1.val==root2.val) res=have(root1,root2);</span><br><span class="line">        <span class="keyword">if</span>(!res) res=HasSubtree(root1.left, root2);</span><br><span class="line">        <span class="keyword">if</span>(!res) res=HasSubtree(root1.right, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">have</span><span class="params">(TreeNode node1, TreeNode node2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node2==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(node1==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(node1.val!=node2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> have(node1.left, node2.left)&amp;&amp;</span><br><span class="line">        have(node1.right, node2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重构二叉树"><a href="#重构二叉树" class="headerlink" title="重构二叉树"></a>重构二叉树</h3><p>已知前序和中序，重构二叉树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">construct</span><span class="params">(<span class="keyword">int</span>[] pre,<span class="keyword">int</span> s1,<span class="keyword">int</span> e1, <span class="keyword">int</span>[] in,<span class="keyword">int</span> s2,<span class="keyword">int</span> e2)</span></span>&#123;</span><br><span class="line">    TreeNode root=<span class="keyword">new</span> TreeNode(pre[s1]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=s2;i&lt;=e2;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i]==pre[s1])&#123; </span><br><span class="line">            <span class="keyword">if</span>(i!=s2) </span><br><span class="line">                <span class="comment">// 递归构造左子树</span></span><br><span class="line">                root.left=construct(pre,s1+<span class="number">1</span>, s1+i-s2, in,s2,i-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(i!=e2)</span><br><span class="line">                <span class="comment">// 递归构造右子树</span></span><br><span class="line">                root.right=construct(pre,s1+i-s2+<span class="number">1</span>,e1, in,i+<span class="number">1</span>, e2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已知二叉树的前序和中序，直接求出后序。思想同重构二叉树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s1.length() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> root = s2.indexOf(s1.charAt(<span class="number">0</span>));</span><br><span class="line">    post(s1.substring(<span class="number">1</span>, root + <span class="number">1</span>), s2.substring(<span class="number">0</span>, root));</span><br><span class="line">    post(s1.substring(root + <span class="number">1</span>), s2.substring(root + <span class="number">1</span>));</span><br><span class="line">    System.out.print(s1.charAt(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树的轮廓"><a href="#树的轮廓" class="headerlink" title="树的轮廓"></a>树的轮廓</h3><p>lintcode878</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">boundaryOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    boundary.add(root.val);</span><br><span class="line">    collectLeftBoundary(root.left, boundary);</span><br><span class="line">    collectLeaves(root, boundary);</span><br><span class="line">    collectRightBoundary(root.right, boundary);</span><br><span class="line">    <span class="keyword">return</span> boundary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collectLeftBoundary</span><span class="params">(TreeNode node, List&lt;Integer&gt; boundary)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span> || isLeaf(node)) <span class="keyword">return</span>;</span><br><span class="line">    boundary.add(node.val);</span><br><span class="line">    collectLeftBoundary(node.left != <span class="keyword">null</span> ? node.left : node.right, boundary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collectRightBoundary</span><span class="params">(TreeNode node, List&lt;Integer&gt; boundary)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span> || isLeaf(node)) <span class="keyword">return</span>;</span><br><span class="line">    collectRightBoundary(node.right != <span class="keyword">null</span> ? node.right : node.left, boundary);</span><br><span class="line">    boundary.add(node.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collectLeaves</span><span class="params">(TreeNode node, List&lt;Integer&gt; boundary)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (isLeaf(node)) &#123;</span><br><span class="line">        boundary.add(node.val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        collectLeaves(node.left, boundary);</span><br><span class="line">        collectLeaves(node.right, boundary);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的宽度"><a href="#二叉树的宽度" class="headerlink" title="二叉树的宽度"></a>二叉树的宽度</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dfs(root, <span class="number">0</span>, <span class="number">1</span>, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode node, <span class="keyword">int</span> d, <span class="keyword">int</span> index, List&lt;Integer&gt; lefts)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// the index of leftmost node</span></span><br><span class="line">    <span class="keyword">if</span>(d==lefts.size()) lefts.add(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(index+<span class="number">1</span>-lefts.get(d), </span><br><span class="line">                    Math.max(dfs(node.left, d+<span class="number">1</span>, index*<span class="number">2</span>, lefts),</span><br><span class="line">                             dfs(node.right, d+<span class="number">1</span>, index*<span class="number">2</span>+<span class="number">1</span>, lefts)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>性质：中序遍历是排序的。 那么逆中序遍历呢？</p><h3 id="二叉树的最近公共父节点"><a href="#二叉树的最近公共父节点" class="headerlink" title="二叉树的最近公共父节点"></a>二叉树的最近公共父节点</h3><p>思路：从根节点<strong>递归</strong>搜索，左子树中有子节点，右子树中也有子节点，那么根节点即为最近的父节点。</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>dfs和bfs</p><p>LintCode 863</p><p>先通过dfs标记父节点（相当于把树转换为无向连通图），然后通过bfs找到距离目标为K的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    dfs(root, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(<span class="keyword">null</span>);</span><br><span class="line">    queue.add(target);</span><br><span class="line"></span><br><span class="line">    Set&lt;TreeNode&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    visited.add(target);</span><br><span class="line">    visited.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> dis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis == K)&#123;</span><br><span class="line">                List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;(queue.size());</span><br><span class="line">                <span class="keyword">for</span>(TreeNode n: queue) ans.add(n.val);</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            queue.offer(<span class="keyword">null</span>);</span><br><span class="line">            dis++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited.contains(node.left)) &#123;</span><br><span class="line">                visited.add(node.left);</span><br><span class="line">                queue.offer(node.left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!visited.contains(node.right)) &#123;</span><br><span class="line">                visited.add(node.right);</span><br><span class="line">                queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!visited.contains(parents.get(node))) &#123;</span><br><span class="line">                visited.add(parents.get(node));</span><br><span class="line">                queue.offer(parents.get(node));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node, TreeNode parent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    parents.put(node, parent);</span><br><span class="line">    dfs(node.left, node);</span><br><span class="line">    dfs(node.right, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归回溯"><a href="#递归回溯" class="headerlink" title="递归回溯"></a>递归回溯</h2><p>找到二叉树中所有路径和等于目标值的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> target,ArrayList&lt;Integer&gt; tmp,</span></span></span><br><span class="line"><span class="function"><span class="params">         ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    tmp.add(root.val);</span><br><span class="line">    target-=root.val;</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>) res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tmp));</span><br><span class="line">        tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    dfs(root.left,target,tmp, res);</span><br><span class="line">    dfs(root.right,target, tmp, res);</span><br><span class="line">    tmp.remove(tmp.size()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正则表达式匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p.isEmpty()) <span class="keyword">return</span> s.isEmpty();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> first = (!s.isEmpty() &amp;&amp; </span><br><span class="line">                     (s.charAt(<span class="number">0</span>)==p.charAt(<span class="number">0</span>)|| p.charAt(<span class="number">0</span>)==<span class="string">'.'</span>));</span><br><span class="line">    <span class="keyword">if</span>(p.length()&gt;=<span class="number">2</span> &amp;&amp; p.charAt(<span class="number">1</span>)==<span class="string">'*'</span>)</span><br><span class="line">        <span class="keyword">return</span> isMatch(s, p.substring(<span class="number">2</span>)) ||</span><br><span class="line">        (first&amp;&amp; isMatch(s.substring(<span class="number">1</span>), p));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> first &amp;&amp; isMatch(s.substring(<span class="number">1</span>), p.substring(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Leetcode 93</p><p>返回所有合理的IP地址。</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>最长无重复字符的字串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一直滑动到set中相同字符前</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lls</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    Set&lt;Character&gt; set=<span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;s.length())&#123;</span><br><span class="line">        <span class="keyword">if</span>(!set.contains(s.charAt(j)))&#123;</span><br><span class="line">            set.add(s.charAt(j++));</span><br><span class="line">            res=max(res, j-i);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            set.remove(s.charAt(i++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化，使用Map索引，直接定位</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lls</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">    Map&lt;Character,Integer&gt; map=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;s.length())&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.contains(s.charAt(j)))&#123;</span><br><span class="line">            <span class="comment">//防止回头</span></span><br><span class="line">            i=max(map.get(s.charAt(j)),i);</span><br><span class="line">        &#125;</span><br><span class="line">        res=max(res,j-i);</span><br><span class="line">        map.put(s.charAt(j),j+<span class="number">1</span>);</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Pass"><a href="#2-Pass" class="headerlink" title="2-Pass"></a>2-Pass</h2><p>Q1  给定一个字符串S，返回字符串中所有字符距离指定字符C 的最短距离。</p><p>A1 从左至右扫描一次，记下 dis[i]=disLeft；再从右至左扫描一次，dis[i]=min(dis[i], disRight)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] shortestToChar(String s,<span class="keyword">char</span> c)&#123;</span><br><span class="line">    <span class="keyword">int</span> n=s.length();</span><br><span class="line">    <span class="keyword">int</span>[] ans=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">// 在c第一次出现，将c前面的字符设置为距离c“无穷远”</span></span><br><span class="line">    <span class="keyword">int</span> pos=-n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==c) pos=i;</span><br><span class="line">        ans[i]=i-pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i)==c) pos=i;</span><br><span class="line">        ans[i]=min(ans[i], abs(i-pos));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q2 有一个数组，数组中每个元素为一个分数。给每个元素分配一个值，要求：</p><p>1、每个元素分配的值至少为1；</p><p>2、若元素的分数大于相邻元素，分配的值也要大于相邻元素。求最小分配的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minValue</span><span class="params">(<span class="keyword">int</span>[] ratings)</span></span>&#123;</span><br><span class="line">    Arrays.fill(ratings, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> n=ratings.length;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings[i]&gt; ratings[i-<span class="number">1</span>])</span><br><span class="line">            cnt[i]=cnt[i-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res=cnt[n-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n-<span class="number">1</span>; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ratings[i-<span class="number">1</span>]&gt; ratings[i])</span><br><span class="line">            cnt[i-<span class="number">1</span>]=max(cnt[i-<span class="number">1</span>] ,cnt[i]+<span class="number">1</span>);</span><br><span class="line">        res+=cnt[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="Max-1D-Range-Sum"><a href="#Max-1D-Range-Sum" class="headerlink" title="Max 1D Range Sum"></a>Max 1D Range Sum</h3><p>description：Give an integer array A containing n non-zero integers, find the max Range Sum Query(RSQ) between two indices i and j in [0…n-1].</p><p>dp[i]代表以A[i]结尾的最大范围和。 </p><p>对于dp[i]：dp[i]= max(dp[i-1], 0) + A[i].</p><p>最大范围和即dp[i]中的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="keyword">int</span> A[])&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length,i++)&#123;</span><br><span class="line">        sum+=A[i];</span><br><span class="line">        ans=max(ans,sum);</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) sum=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LIS"><a href="#LIS" class="headerlink" title="LIS"></a>LIS</h3><p>最长递增子序列。</p><p>例子 ｛-7, 10 , 9 ,  2,  3 , 8,  8 , 1｝</p><p>1）LIS[i]= max(LIS[j])+1 (j∈[0,i-1] ,A[j]&lt;A[i] )</p><p>2）L={-7} ,  L={-7, 10}, L={-7, 9}…</p><p>Q: 假如袋子里共有5个积木分别为 (2, 2), (2, 4), (3, 3), (2, 5), (4, 5), 则不难判断这些积木最多可以搭成4层, </p><p>因为(2, 2) &lt; (2, 4) &lt; (2, 5) &lt; (4, 5)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Arrays.sort(a, (p,q)-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> p[<span class="number">0</span>]!=q[<span class="number">0</span>]?p[<span class="number">0</span>]-q[<span class="number">0</span>]:p[<span class="number">1</span>]-q[<span class="number">1</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">0</span>;</span><br><span class="line">    dp[k++]=a[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i][<span class="number">1</span>]&gt;=dp[k-<span class="number">1</span>])</span><br><span class="line">            dp[k++]=a[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> pos=upperBound(dp,<span class="number">0</span>,k,a[i][<span class="number">1</span>]);</span><br><span class="line">            dp[pos]=a[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-1-Knapsack"><a href="#0-1-Knapsack" class="headerlink" title="0-1 Knapsack"></a>0-1 Knapsack</h3><p>top-down</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==N || w==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(dp[i][w]!= -<span class="number">1</span>) <span class="keyword">return</span> dp[i][w];</span><br><span class="line">    <span class="keyword">if</span>(W[i]&gt;w) <span class="keyword">return</span> dp[i][w]= value(i+<span class="number">1</span>, w）;</span><br><span class="line">    <span class="keyword">return</span> dp[i][w]=max(value(i+<span class="number">1</span>, w), V[i]+ value(i+<span class="number">1</span>, w-W[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bottom-up</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> W)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp=<span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>][W+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=W;j++)</span><br><span class="line">            <span class="keyword">if</span>(W[i]&gt;j) dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">    <span class="keyword">else</span> dp[i][j]=max(dp[i-<span class="number">1</span>][j], V[i]+dp[i-<span class="number">1</span>][j-W[i]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以优化，一维数组解决。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">(<span class="keyword">int</span> N; <span class="keyword">int</span> W)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] dp=<span class="keyword">new</span> <span class="keyword">int</span>[W+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=W;j&gt;=V[i];j--)</span><br><span class="line">            dp[j]=max(dp[j],dp[j- W[i]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Subset-Sum"><a href="#Subset-Sum" class="headerlink" title="Subset Sum"></a>Subset Sum</h3><p>1）给定一个非负数整数集S，判断是否有S的非空子集之和等于给定的Sum。</p><p>top-down</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">solve(i,sum) 表示从i开始是否有子集和等于Sum。</span><br><span class="line"></span><br><span class="line">base <span class="keyword">case</span>:</span><br><span class="line">solve(n,sum)=<span class="keyword">false</span> (sum&gt;<span class="number">0</span> &amp;&amp; i==n);</span><br><span class="line">solve(i,<span class="number">0</span>)=<span class="keyword">true</span> (sum==<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//若S[i]&gt;sum，则跳过S[i]</span></span><br><span class="line"><span class="keyword">if</span>(S[i]&gt;sum) <span class="keyword">return</span> solve(i+<span class="number">1</span>,sum);</span><br><span class="line">solve(i,sum)=solve(i+<span class="number">1</span>,sum) || solve(i+<span class="number">1</span>,sum-S[i]);</span><br></pre></td></tr></table></figure><p>bottom-up</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp[i][j] 表示到前i个数中，是否有sum=j；</span></span><br><span class="line"><span class="keyword">boolean</span>[][] dp=<span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>][sum+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) dp[i][<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=sum;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;S[i]) dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span> dp[i][j]=dp[i-<span class="number">1</span>][j] || dp[i-<span class="number">1</span>][j-S[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以优化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=sum;j&gt;=S[i];j--)</span><br><span class="line">        dp[j]=dp[j] || dp[j-S[i]];</span><br></pre></td></tr></table></figure><p>变种1 给定一个非负数的数组，是否可以将其分成两个和相等的数组？</p><p>Q： 搜索该数组中是否有部分和等于数组和的一半。</p><p>​    1 用Subset Sum。</p><p>​    2 回溯（见下面变种2）。</p><p>变种2 给定一个非负数的数组， 是否可以将其分为 k 个和相等的数组？</p><p>Q：回溯搜索该数组，目标为 sum/k。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">backtract</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span>[] a, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span> k, <span class="keyword">int</span> sum, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//只剩下最后一组</span></span><br><span class="line">    <span class="keyword">if</span>(sum&gt;target) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(sum==target)</span><br><span class="line">        <span class="keyword">return</span> backtract(<span class="number">0</span>,a,visited,k-<span class="number">1</span>,<span class="number">0</span>,target);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">            visited[i]=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(backtract(i+<span class="number">1</span>,a,visited,k, sum+a[i], target))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            visited[i]=<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Coin-Change"><a href="#Coin-Change" class="headerlink" title="Coin Change"></a>Coin Change</h3><p>例子 N=2,  币种 {1,5},  V=10</p><p>1 求最少使用多少个硬币。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">change(0)=0;</span><br><span class="line">change(&lt;0) = INF;</span><br><span class="line">change(i) = min(change(i- coinValue[j])) + 1</span><br></pre></td></tr></table></figure><p>2 求有多少种换法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(j&lt;coinValue[i]) dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line"><span class="keyword">else</span> dp[i][j] = dp[i-<span class="number">1</span>][j]+dp[i][j- coinValue[i]];</span><br></pre></td></tr></table></figure><h3 id="K个非负数加到N"><a href="#K个非负数加到N" class="headerlink" title="K个非负数加到N"></a>K个非负数加到N</h3><p>例如，K=2， N=20，有21种：0+20, … , 20+0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ways(n,k);</span><br><span class="line"></span><br><span class="line">ways(i,<span class="number">1</span>)=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=k;j++;)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>;x&lt;=i;x++)</span><br><span class="line">            dp[i][j]+=dp[i-x][j-<span class="number">1</span>];</span><br></pre></td></tr></table></figure><h3 id="Cutting-Sticks"><a href="#Cutting-Sticks" class="headerlink" title="Cutting Sticks"></a>Cutting Sticks</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cut(i,i+<span class="number">1</span>)=<span class="number">0</span>；</span><br><span class="line"></span><br><span class="line">cut(i,j)=min(cut(i,k) + cut(k,j) + A[j]-A[i]) k∈[i+<span class="number">1</span>,j)</span><br></pre></td></tr></table></figure><p>dp一般思路：State Expressions –&gt; Base Case –&gt; General Case（Top-down , Bottom-up）</p><h3 id="String-Processing-With-DP"><a href="#String-Processing-With-DP" class="headerlink" title="String Processing With DP"></a>String Processing With DP</h3><h4 id="LCS-最长公共子序列"><a href="#LCS-最长公共子序列" class="headerlink" title="LCS(最长公共子序列)"></a>LCS(最长公共子序列)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a[i]== b[j]) dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> dp[i][j]=max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>另外：最长公共子串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a[i]==b[j]) dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> dp[i][j]=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="Longest-Palindrome-回文"><a href="#Longest-Palindrome-回文" class="headerlink" title="Longest Palindrome(回文)"></a>Longest Palindrome(回文)</h4><p>搜索回文串可用“中心向两边扩散算法”。</p><p>一个变种：可删除的情况下，某字符串中最长回文串长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dp[l][r] 表示 A[l...r] 最长回文串的长度。</span><br><span class="line"></span><br><span class="line">Base Case: </span><br><span class="line"><span class="keyword">if</span>(l== r) dp[l][r]= <span class="number">1</span></span><br><span class="line">Recurrent:</span><br><span class="line"><span class="keyword">if</span>(l&lt;r)</span><br><span class="line">    <span class="keyword">if</span>(A[l]==A[r]) dp[l][r]=dp[l+<span class="number">1</span>][r-<span class="number">1</span>]+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> dp[l][r]= max(dp[l+<span class="number">1</span>,r] , dp[l][r-<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><h3 id="最大连续乘积"><a href="#最大连续乘积" class="headerlink" title="最大连续乘积"></a>最大连续乘积</h3><p>解法一：暴力破解。遍历所有子数组，求最大值。</p><p>解法二：存储到某个位置为止的所有子数组的最大值和最小值。</p><h3 id="House-Robber"><a href="#House-Robber" class="headerlink" title="House Robber"></a>House Robber</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> rob=<span class="number">0</span>, nrob=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        rob=nrob+nums[i];</span><br><span class="line">        nrob=res;</span><br><span class="line">        res=Math.max(res,rob);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TSP"><a href="#TSP" class="headerlink" title="TSP"></a>TSP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span>[][] dis,memo;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    n = sc.nextInt();</span><br><span class="line">    dis=<span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">            dis[i][j]=sc.nextInt();</span><br><span class="line">    memo=<span class="keyword">new</span> <span class="keyword">int</span>[n][<span class="number">1</span>&lt;&lt;n];</span><br><span class="line">    System.out.println(tsp(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tsp</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> mask)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 例如，mask=1111</span></span><br><span class="line">    <span class="keyword">if</span>(mask==(<span class="number">1</span>&lt;&lt;n)-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dis[pos][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(memo[pos][mask]!=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> memo[pos][mask];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans=Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i!=pos &amp;&amp; (mask&amp;(<span class="number">1</span>&lt;&lt;i))==<span class="number">0</span>)</span><br><span class="line">            ans=Math.min(ans, dis[pos][i]+tsp(i, mask|(<span class="number">1</span>&lt;&lt;i)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> memo[pos][mask]=ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大m段子段和"><a href="#最大m段子段和" class="headerlink" title="最大m段子段和"></a>最大m段子段和</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">now[j]以a[j]结尾的i段子段最大值</span></span><br><span class="line"><span class="comment">pre[j]前j个数的i-1段子段最大值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    res=Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)&#123;</span><br><span class="line">        now[j]=Math.max(now[j-<span class="number">1</span>], pre[j-<span class="number">1</span>])+a[j];</span><br><span class="line">        pre[j-<span class="number">1</span>]=res;</span><br><span class="line">        res=Math.max(res,now[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/double215726/article/details/9283181" target="_blank" rel="noopener">经典动态规划——HDU1024 m段子段和的最大值</a></p><h3 id="股票问题"><a href="#股票问题" class="headerlink" title="股票问题"></a>股票问题</h3><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems" target="_blank" rel="noopener">Most consistent ways of dealing with the series of stock problems</a></p><h3 id="单词分割"><a href="#单词分割" class="headerlink" title="单词分割"></a>单词分割</h3><p>LeetCode 139</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n =  s.length();</span><br><span class="line">    <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;i ; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[j] &amp;&amp; wordDict.contains(s.substring(j, i)))&#123;</span><br><span class="line">                dp[i] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>贪心策略，多用反证法证明。</p><p>漂流船问题：每个船载两人，最少的船载完。</p><p>贪心策略：尽可能载最大和最小者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(a);</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>,j=a.length-<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i]+a[j]&lt;= limit)&#123;</span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    res++;</span><br><span class="line">&#125;</span><br><span class="line">res+=i==j?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">System.out.println(res);</span><br></pre></td></tr></table></figure><h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><p>LeetCode 496、503下一个大的数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路：维护一个递减序列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums2.length; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek()&lt; nums2[i])&#123;</span><br><span class="line">            map.put(stack.pop(), nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(nums2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><h3 id="约瑟夫环"><a href="#约瑟夫环" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h3><p>1） 循环链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span>||m&lt;<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    LinkedList&lt;Integer&gt; list=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) list.add(i);</span><br><span class="line">    <span class="keyword">int</span> nxt=(m-<span class="number">1</span>)%n;</span><br><span class="line">    <span class="keyword">while</span>(list.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        list.remove(nxt);</span><br><span class="line">        nxt=(nxt+m-<span class="number">1</span>)%list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list.get(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）数学规律<br>$$<br>f(n,m)=\begin{cases}<br>0, &amp; \text{ if } n=1 \cr<br>[f(n-1,m)+m]\%n, &amp; \text{ if } n&gt;1<br>\end{cases}<br>$$</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>字典中只含n个“a”和m个“z”，按字典序排列，第k个是什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有点像分治法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=sc.nextInt(),m=sc.nextInt(),k=sc.nextInt();</span><br><span class="line">    StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>&amp;&amp;m&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">long</span> cnt=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            cnt*=n-<span class="number">1</span>+m-i;</span><br><span class="line">            cnt/=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(cnt&gt;k) <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(k&lt;=cnt)&#123;</span><br><span class="line">            sb.append(<span class="string">"a"</span>);</span><br><span class="line">            n--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sb.append(<span class="string">"z"</span>);</span><br><span class="line">            m--;</span><br><span class="line">            k-=cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k!=<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n--&gt;<span class="number">0</span>) sb.append(<span class="string">"a"</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--&gt;<span class="number">0</span>) sb.append(<span class="string">"z"</span>);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><p>方法一：基于交换的全排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">permutation(a, <span class="number">0</span>, res);</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">Collections.sort(res);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">permutationWithSwap</span><span class="params">(<span class="keyword">char</span>[] a,<span class="keyword">int</span> s, ArrayList&lt;String&gt; res)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s==a.length-<span class="number">1</span>)&#123; res.add(String.valueOf(a)); <span class="keyword">return</span>; &#125;</span><br><span class="line">    Set&lt;Character&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=s; i&lt;a.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 去重</span></span><br><span class="line">        <span class="keyword">if</span>(i==s || !set.contains(a[i]))&#123;</span><br><span class="line">            set.add(a[i]);</span><br><span class="line">            swap(a,i,start);</span><br><span class="line">            permutation(a,start+<span class="number">1</span>);</span><br><span class="line">            swap(a,i,satrt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：基于字典序的全排列。</p><p>找下一个的思想如下：</p><ol><li><p>从后向前扫描，找到第一个非递增的位置p，保证了p之后序列的逆序递增；</p></li><li><p>从p+1开始向后扫描，找到最后一个大于p的位置q，结合第1步，可知这个q是大于p的最小位置；</p></li><li>交换p、q，然后对p+1之后的非递减序列逆序。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ArrayList&lt;String&gt; <span class="title">permutationWithDict</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(str==<span class="keyword">null</span>||str.length==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">char</span>[] a=str.toCharArray();</span><br><span class="line">    Arrays.sort(a);</span><br><span class="line">    res.add(String.valueOf(a));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">int</span> p=a.length-<span class="number">1</span>, q;</span><br><span class="line">        <span class="keyword">while</span>(p&gt;<span class="number">0</span> &amp;&amp; a[p-<span class="number">1</span>]&gt;=a[p]) p--;</span><br><span class="line">        <span class="comment">//跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        q= p--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(q&lt;a.length &amp;&amp; a[q]&gt;a[p]) q++;</span><br><span class="line">        q--;</span><br><span class="line">        swap(a,p,q);</span><br><span class="line">        reverse(a,p+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(exponent==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n=Math.abs(exponent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> res=<span class="number">1</span>, cur=base;</span><br><span class="line">    <span class="comment">// 如何处理一个数的二进制形式</span></span><br><span class="line">    <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>((n&amp;<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">            res*=cur;</span><br><span class="line">        cur*=cur;</span><br><span class="line">        n&gt;&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exponent&gt;<span class="number">0</span>? res:<span class="number">1</span>/res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="素数筛"><a href="#素数筛" class="headerlink" title="素数筛"></a>素数筛</h3><p><a href="https://www.cnblogs.com/grubbyskyer/p/3852421.html" target="_blank" rel="noopener">https://www.cnblogs.com/grubbyskyer/p/3852421.html</a></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="二叉搜索树（递归）"><a href="#二叉搜索树（递归）" class="headerlink" title="二叉搜索树（递归）"></a>二叉搜索树（递归）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E elem;</span><br><span class="line">        Node&lt;E&gt; left, right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(E elem, Node&lt;E&gt; left, Node&lt;E&gt; right)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.elem = elem;</span><br><span class="line">            <span class="keyword">this</span>.left = left;</span><br><span class="line">            <span class="keyword">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node&lt;T&gt; root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">insert</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> root = insert(x, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node&lt;T&gt; <span class="title">insert</span><span class="params">(T x, Node&lt;T&gt; root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(x, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> comp = x.compareTo(root.elem);</span><br><span class="line">        <span class="keyword">if</span> (comp &gt; <span class="number">0</span>) root.right = insert(x, root.right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (comp &lt; <span class="number">0</span>) root.left = insert(x, root.left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> contains(x, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(T x, Node&lt;T&gt; root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> comp = x.compareTo(root.elem);</span><br><span class="line">        <span class="keyword">if</span> (comp &gt; <span class="number">0</span>) <span class="keyword">return</span> contains(x, root.right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (comp &lt; <span class="number">0</span>) <span class="keyword">return</span> contains(x, root.left);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node&lt;T&gt; <span class="title">remove</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> root = remove(x, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node&lt;T&gt; <span class="title">remove</span><span class="params">(T x, Node&lt;T&gt; root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> comp = x.compareTo(root.elem);</span><br><span class="line">        <span class="keyword">if</span> (comp &gt; <span class="number">0</span>) root.right = remove(x, root.right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (comp &lt; <span class="number">0</span>) root.left = remove(x, root.left);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// two child</span></span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                root.elem = findMin(root.right).elem;</span><br><span class="line">                root.right = remove(root.elem, root);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// one child or leaf</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                root = root.left != <span class="keyword">null</span> ? root.left : root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node&lt;T&gt; <span class="title">findMin</span><span class="params">(Node&lt;T&gt; root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (root.left != <span class="keyword">null</span>)</span><br><span class="line">            root = root.left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组实现堆进而实现优先队列"><a href="#数组实现堆进而实现优先队列" class="headerlink" title="数组实现堆进而实现优先队列"></a>数组实现堆进而实现优先队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxPQ</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    T[] pq;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pq[i].compareTo(pq[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">exch</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        T t = pq[i];</span><br><span class="line">        pq[i] = pq[j];</span><br><span class="line">        pq[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k / <span class="number">2</span>, k)) &#123;</span><br><span class="line">            exch(k, k / <span class="number">2</span>);</span><br><span class="line">            k /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; n &amp;&amp; less(j, j + <span class="number">1</span>)) j++;</span><br><span class="line">            <span class="keyword">if</span> (!less(k, j)) <span class="keyword">break</span>;</span><br><span class="line">            exch(k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        pq[++n] = x;</span><br><span class="line">        swim(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">delMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T max = pq[<span class="number">1</span>];</span><br><span class="line">        exch(<span class="number">1</span>, n);</span><br><span class="line">        pq[n--] = <span class="keyword">null</span>;</span><br><span class="line">        sink(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 双向链表，便于删除和插入</span></span><br><span class="line">    Node head,tail;</span><br><span class="line">    HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="keyword">int</span> capacity,size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        head=<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        tail=<span class="keyword">new</span> Node(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        head.next=tail;</span><br><span class="line">        tail.pre=head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.capacity=capacity;</span><br><span class="line">        map=<span class="keyword">new</span> HashMap&lt;&gt;(capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Node target=map.get(key);</span><br><span class="line">        remove(target);</span><br><span class="line">        add(target);</span><br><span class="line">        <span class="keyword">return</span> target.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            Node node=map.get(key);</span><br><span class="line">            node.value=value;</span><br><span class="line">            remove(node);</span><br><span class="line">            add(node);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123; </span><br><span class="line">            Node node=<span class="keyword">new</span> Node(key,value);</span><br><span class="line">            <span class="keyword">if</span>(size==capacity)&#123;</span><br><span class="line">                Node old=tail.pre;</span><br><span class="line">                remove(old);</span><br><span class="line">                map.remove(old.key);</span><br><span class="line">            &#125;<span class="keyword">else</span> size++;</span><br><span class="line"></span><br><span class="line">            add(node); </span><br><span class="line">            map.put(key,node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        node.next.pre=node.pre;</span><br><span class="line">        node.pre.next=node.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        head.next.pre=node;</span><br><span class="line">        node.next=head.next;</span><br><span class="line">        head.next=node;</span><br><span class="line">        node.pre=head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">        Character keyword;</span><br><span class="line">        Map&lt;Character, TrieNode&gt; subNodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> isKeyWordEnd;</span><br><span class="line"></span><br><span class="line">        <span class="function">TrieNode <span class="title">getSubNode</span><span class="params">(Character c)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> subNodes.get(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">putSubNode</span><span class="params">(Character c, TrieNode node)</span> </span>&#123;</span><br><span class="line">            subNodes.put(c, node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isKeyWordEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isKeyWordEnd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKeyWordEnd</span><span class="params">(<span class="keyword">boolean</span> keyWordEnd)</span> </span>&#123;</span><br><span class="line">            isKeyWordEnd = keyWordEnd;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TrieNode root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    <span class="keyword">final</span> String REPLACE = <span class="string">"***"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode tempNode = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = word.charAt(i);</span><br><span class="line">            TrieNode subNode = tempNode.getSubNode(c);</span><br><span class="line">            <span class="keyword">if</span> (subNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                subNode = <span class="keyword">new</span> TrieNode();</span><br><span class="line">                tempNode.putSubNode(c, subNode);</span><br><span class="line">            &#125;</span><br><span class="line">            tempNode = subNode;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == word.length() - <span class="number">1</span>) tempNode.setKeyWordEnd(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">filter</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        TrieNode subNode = root;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>, position = <span class="number">0</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (position &lt; text.length()) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = text.charAt(position);</span><br><span class="line">            subNode = subNode.getSubNode(c);</span><br><span class="line">            <span class="keyword">if</span> (subNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(text.charAt(begin));</span><br><span class="line">                position = ++begin;</span><br><span class="line">                subNode = root;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subNode.isKeyWordEnd()) &#123;</span><br><span class="line">                sb.append(REPLACE);</span><br><span class="line">                begin = ++position;</span><br><span class="line">                subNode = root;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                position++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (begin &lt; text.length()) &#123;</span><br><span class="line">            sb.append(text.substring(begin));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line">    Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            items[putptr] = x;</span><br><span class="line">            <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">            ++count;</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            Object x = items[takeptr];</span><br><span class="line">            <span class="keyword">if</span> (++takeptr == items.length) takeptr = putptr;</span><br><span class="line">            --count;</span><br><span class="line">            notFull.signal();</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="赛马问题"><a href="#赛马问题" class="headerlink" title="赛马问题"></a>赛马问题</h3><p><a href="https://www.iteye.com/blog/hxraid-662643" target="_blank" rel="noopener">https://www.iteye.com/blog/hxraid-662643</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Netty新连接接入过程</title>
      <link href="/2019/08/02/java/netty1/"/>
      <url>/2019/08/02/java/netty1/</url>
      
        <content type="html"><![CDATA[<p>Netty的NioEventLoop线程中的循环可以分为以下几个步骤：</p><ol><li>轮询注册在selector上的IO事件（select）</li><li>处理IO事件（processSelectedKey，unsafe.read() 开启事件传播）</li><li>执行异步task (runAllTasks)</li></ol><a id="more"></a><p>通常有两类NioEventLoop线程：boss和worker。</p><p>对于boss线程来说，轮询出来的基本都是 accept 事件，表示有新的连接，而worker线程轮询出来的基本都是read/write事件，表示网络的读写事件。</p><p>服务端在用户进程（main线程）中启动，并将处理新连接的过程封装成一个channel，对应的pipeline为：</p><p><code>HeadContext -&gt; ServerBootStrapAcceptor -&gt; TailContext</code></p><h2 id="新连接的建立"><a href="#新连接的建立" class="headerlink" title="新连接的建立"></a>新连接的建立</h2><h3 id="检测到有新连接接入"><a href="#检测到有新连接接入" class="headerlink" title="检测到有新连接接入"></a>检测到有新连接接入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> </span><br><span class="line">        || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//NioServerSocketChannel对应NioMessageUnsafe, NioSocketChannel对应NioByteUnsafe</span></span><br><span class="line">        unsafe.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是NioMessageUnsafe.read()。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; readBuf = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给每条连接创建NioSocketChannel,感兴趣的事件是read</span></span><br><span class="line">    doReadMessages(readBuf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">        pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是<strong>pipeline.fireChannelRead</strong>的调用过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultChannelPipeline.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">    AbstractChannelHandlerContext.invokeChannelRead(head, msg);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AbstractChannelHandlerContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 是当前channel的事件循环线程</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(()-&gt;&#123;</span><br><span class="line">            next.invokeChannelRead(m);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 在服务端通过HeadContext -&gt; ServerBootstrapAcceptor</span></span><br><span class="line">    ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ServerBootstrapAcceptor.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line">    <span class="comment">// 将用户代码中服务端定义的childHandler添加到NioSocketChannel,通常为ChannelInitializer</span></span><br><span class="line">    child.pipeline().addLast(childHandler);</span><br><span class="line">    </span><br><span class="line">    childGroup.register(child)...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addLast()</code>在添加完成后，会回调相应handler的<code>handlerAdded(DefaultChannelHandlerContext)</code>。其中，ChannelInitializer对应的handlerAdded会调用抽象方法initChannel()，这个方法就是我们实现来添加自定义handler的地方。(并且ChannelInitizer后在添加完成后删除自己)</p><p>这样之后，NioSocketChannel的pipeline对应为：HeadContext -&gt; 用户自定义ChannelHandler -&gt; TailContext。</p><h3 id="将新的连接注册到NioEventLoop线程"><a href="#将新的连接注册到NioEventLoop线程" class="headerlink" title="将新的连接注册到NioEventLoop线程"></a>将新的连接注册到NioEventLoop线程</h3><p>接着，ServerBoostrapAcceptor中channelRead调用到register(child)。这个方法最终从workerGroup中循环选择一个NioEventLoop线程，然后将child注册到对应的selector上。若当前线程不是child对应的NioEventLoop线程，则启动NioEventLoop线程。若是，则直接执行注册逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractChannel.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        eventLoop.execute(()-&gt;&#123;register0(promise);&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    doRegister();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">            pipeline.fireChannelActive();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">            beginRead();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">beginRead()&#123;</span><br><span class="line">    doBeginRead();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractNioChannel.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">    <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实就是将 <code>SelectionKey.OP_READ</code>事件注册到selector中去，表示这条通道已经可以开始处理read事件了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO模型</title>
      <link href="/2019/07/23/java/io/"/>
      <url>/2019/07/23/java/io/</url>
      
        <content type="html"><![CDATA[<h2 id="基于IO多路复用的并发编程"><a href="#基于IO多路复用的并发编程" class="headerlink" title="基于IO多路复用的并发编程"></a>基于IO多路复用的并发编程</h2><p>基于思想是使用select函数，要求内核挂起进程，只有一个或多个I/O事件发生后，才将控制返回给应用程序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪码</span></span><br><span class="line">listenfd = Open_listenfd(); <span class="comment">//打开一个监听描述符，监听客户端IO事件</span></span><br><span class="line">FD_ZREO(&amp;read_set);  <span class="comment">//创建一个空的读集合</span></span><br><span class="line">FD_SET(STDIN, listenfd, &amp;read_set); <span class="comment">//添加描述符到读集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 典型服务器循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123; </span><br><span class="line">ready_set = read_set;</span><br><span class="line">select(listenfd+<span class="number">1</span> , &amp;ready_set, ...); <span class="comment">//阻塞直到有描述符可读</span></span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(STDIN, &amp;ready_set))&#123;</span><br><span class="line"><span class="comment">// 处理描述符1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(listenfd, &amp;ready_set))&#123;</span><br><span class="line"><span class="comment">// 处理描述符2</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="基于IO多路复用的并发事件驱动服务器"><a href="#基于IO多路复用的并发事件驱动服务器" class="headerlink" title="基于IO多路复用的并发事件驱动服务器"></a>基于IO多路复用的并发事件驱动服务器</h3><p>事件驱动模型基本逻辑图</p><p><img src="https://i.loli.net/2019/07/24/5d37cafb798a377131.jpg" alt=""></p><p>参考：</p><p><a href="https://kab13098832.weebly.com/event-loops.html" target="_blank" rel="noopener">key features of event driven programs</a></p><p>一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">listenfd = Open_listenfd();</span><br><span class="line">init_pool(listenfd, &amp;pool); <span class="comment">// 初始化客户端连接池，设置读集合</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">pool.ready_set = pool.read_set;</span><br><span class="line">pool.nready = Select(.., &amp;pool.ready_set, ...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(FD_ISSET(listenfd, &amp;pool.ready_set))&#123; <span class="comment">//如果监听描述符准备好，添加到连接池</span></span><br><span class="line">add_client();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理事件</span></span><br><span class="line">check_clients(&amp;pool);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>硬编码事件驱动是难以维护的。</p><p>参考《深入理解计算机系统（第三版）》12.2</p><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><h3 id="Reactor模型"><a href="#Reactor模型" class="headerlink" title="Reactor模型"></a>Reactor模型</h3><p>基于事件驱动IO模型</p><p><img src="https://i.loli.net/2019/07/24/5d38121e026a580893.jpg" alt=""></p><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p><img src="https://i.loli.net/2019/07/24/5d380991489cc11685.jpg" alt=""></p><p>个人理解相应代码的逻辑如下图所示。</p><p><img src="https://i.loli.net/2019/07/24/5d381e749edb069803.png" alt=""></p><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p><img src="https://i.loli.net/2019/07/24/5d381eecc15c669653.jpg" alt=""></p><h4 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h4><p><img src="https://i.loli.net/2019/07/24/5d381f2b41d2570261.jpg" alt=""></p><p>与Netty线程模型类似。</p><p>参考：</p><p><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">DL’s NIO</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring框架的一些理解</title>
      <link href="/2019/04/22/java/spring/"/>
      <url>/2019/04/22/java/spring/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-Annotation"><a href="#Java-Annotation" class="headerlink" title="Java Annotation"></a>Java Annotation</h1><p>对于注解而言，若没有相应处理器，那它和注释没什么区别。</p><p>Java注解示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明注解使用的地方。 这里是方法级。</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明注解的生命时长。 这里是在运行时被虚拟机获得，所以可以使用反射来读。</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UseCase&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> "no description"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">   <span class="meta">@UseCase</span>(id=<span class="number">1</span>,description=<span class="string">"......"</span>)</span><br><span class="line">    <span class="keyword">void</span> methodA&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseCaseTracker</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trackUseCases</span><span class="params">(List&lt;Integer&gt; useCases, Class&lt;?&gt; cl)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Method m: cl.getDeclaredMethods())&#123;</span><br><span class="line">            UseCase uc=m.getAnnonation(UseCase.class);</span><br><span class="line">            <span class="keyword">if</span>(uc!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                print(uc.id(), uc.description());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>另外，注解特别适用于生成框架的“样板文件”（boilerplate）代码。如Hibernate、Spring Boot等。</p><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p>IoC 的一种类型是依赖注入。</p><p>ApplicationContext接口代表了Spring IoC容器，它负责实例化、配置并装配beans。</p><p>而容器是通过读配置metadata来获取配置的指令，其中，metadata包括XML、Java 注解或Java 代码。</p><p>@Configuration 表明该类可声明@Bean方法，并可Spring容器处理而产生Bean定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等价于&lt;bean id="provider", class="..."/&gt;</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageProvider <span class="title">provider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloWorldMassgeProvider();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageRenderer <span class="title">renderer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MessageRenderer renderer = <span class="keyword">new</span> StandardOutMessageRenderer();</span><br><span class="line">        renderer.setMessageProvider(provider());</span><br><span class="line">        <span class="keyword">return</span> renderer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldSpringAnnotated</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext</span><br><span class="line">                (HelloWorldConfiguration.class);</span><br><span class="line">        MessageRenderer renderer = ctx.getBean(<span class="string">"renderer"</span>, MessageRenderer.class);</span><br><span class="line">        renderer.render();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码也可以将Bean定义到外面，然后通过@ComponentScan来引入，如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ch3.annotated</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"provider"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConfigurableMessageProvider</span> <span class="keyword">implements</span> <span class="title">MessageProvider</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">//基于构造器的注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConfigurableMessageProvider</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">       @Value(<span class="string">"Cofigurable message"</span>)</span> String message) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------</span></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"renderer"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandardOutMessageRenderer</span> <span class="keyword">implements</span> <span class="title">MessageRenderer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MessageProvider messageProvider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(messageProvider.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基于Setter注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessageProvider</span><span class="params">(MessageProvider provider)</span> </span>&#123;</span><br><span class="line">        messageProvider = provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageProvider <span class="title">getMessageProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageProvider;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------</span></span><br><span class="line"><span class="comment">//启动 @Component的扫描</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"ch3.annotated"</span>)</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldSpringAnnotated</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext</span><br><span class="line">            (HelloWorldSpringAnnotated.class);</span><br><span class="line">        MessageRenderer renderer = ctx.getBean(<span class="string">"renderer"</span>, MessageRenderer.class);</span><br><span class="line">        renderer.render();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上，可以引出Spring Boot中的 @SpringBootApplication。</p><p>它等价于 @ComponentScan、@Configuration、@EnableAutoConfiguration。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DynamicProxy</title>
      <link href="/2019/03/10/java/DynamicProxy/"/>
      <url>/2019/03/10/java/DynamicProxy/</url>
      
        <content type="html"><![CDATA[<h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Interface</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSth</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealObject</span> <span class="title">implments</span> <span class="title">Interface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSth</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="title">implments</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object proxied;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(Object proxied)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxied = proxied;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method m, Object[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        在此插入代理逻辑</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> m.invoke(proxied, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDynamicProxy</span> </span>&#123;</span><br><span class="line"> Interface proxy = (Interface) Proxy.newInstance(</span><br><span class="line">    Interface.class.getClassLoader(), <span class="comment">//一般传这个已加载的类加载器就行</span></span><br><span class="line">        <span class="keyword">new</span> Class[]&#123;Interface.class&#125;, <span class="comment">//实现的接口</span></span><br><span class="line">        <span class="keyword">new</span> DynamicProxyHandler(<span class="keyword">new</span> RealObject())</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    proxy.doSth();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p> 可能生成如下代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="title">implments</span> <span class="title">Interface</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">(String var)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 这里的h即上文传入的 new DynamicProxyHandler(new RealObject())</span></span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m4, <span class="keyword">new</span> Object[]&#123;var&#125;);</span><br><span class="line">        &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            m4=Class.forName(<span class="string">"ProxyDemo$Interface"</span>).getMethod(<span class="string">"doSth"</span>, Class.forName(<span class="string">"java.lang.String"</span>))</span><br><span class="line">        &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Proxy 类的源码简单说：先是生成构造器，再用构造器newInstance生成动态代理对象。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark Streaming base on Kafka</title>
      <link href="/2018/12/17/bigdata/SparkStreaming/"/>
      <url>/2018/12/17/bigdata/SparkStreaming/</url>
      
        <content type="html"><![CDATA[<p>实时计算</p><p>任务：计算每秒的买、卖数，买或卖总量前五的客户端及最近一小时前五的证券。</p><a id="more"></a><blockquote><p>《Spark in Action》 chapter 6</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/005wR1ytgy1fy4tls234tj30s30hkabf.jpg" alt=""></p><p>Spark流处理概念图。</p><p>Spark是面向批处理的，以mini-batches来在实时计算中应用Spark的批处理特性。</p><p>以下用以Kafka作为数据源为例。</p><p>一、数据源</p><p>1、启动Kafka</p><p>zookeeper-server-start .\zookeeper.properties（Kafka依赖zookeeper）</p><p>kafka-server-start .\server.properties</p><p>2、Kafka topic</p><p>kafka-topics –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic orders</p><p>kafka-topics –create –zookeeper localhost:2181 –replication-factor 1 –partitions 1 –topic metrics</p><p>以上创建orders和metrics两topic。</p><p>3、做好发送数据的准备</p><p>可以用一个脚本模拟数据发送。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat orders.txt | <span class="keyword">while</span> <span class="built_in">read</span> line; <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"<span class="variable">$line</span>"</span></span><br><span class="line">        sleep 0.1</span><br><span class="line"><span class="keyword">done</span> | kafka-console-producer.bat --broker-list <span class="variable">$BROKER</span> --topic orders</span><br></pre></td></tr></table></figure><p>每隔0.1s向orders生产数据，<code>$BROKER=&#39;localhost:9092&#39;</code>（9092kafka默认端口）。</p><p>1、创建StreamingContext上下文，设为ssc。本地模式。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>)</span><br><span class="line">      .setAppName(<span class="string">"Orders"</span>)</span><br><span class="line"><span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf, <span class="type">Seconds</span>(<span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>第二个参数，指定了Streaming分割输入数据和创建mini-batch的时间间隔。时间间隔暂定为5s，再详谈。</p><p>2、连接Kafka</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> kafkaParams = <span class="type">Map</span>[<span class="type">String</span>, <span class="type">Object</span>](</span><br><span class="line">  <span class="string">"bootstrap.servers"</span> -&gt; <span class="string">"localhost:9092"</span>,</span><br><span class="line">  <span class="string">"key.deserializer"</span> -&gt; classOf[<span class="type">StringDeserializer</span>],</span><br><span class="line">  <span class="string">"value.deserializer"</span> -&gt; classOf[<span class="type">StringDeserializer</span>],</span><br><span class="line">  <span class="string">"group.id"</span> -&gt; <span class="string">"group1"</span>,</span><br><span class="line">  <span class="string">"auto.offset.reset"</span> -&gt; <span class="string">"latest"</span>,</span><br><span class="line">  <span class="string">"enable.auto.commit"</span> -&gt; (<span class="literal">false</span>: java.lang.<span class="type">Boolean</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> topics = <span class="type">Array</span>(<span class="string">"orders"</span>)</span><br><span class="line"><span class="keyword">val</span> kafkaStream = <span class="type">KafkaUtils</span></span><br><span class="line">  .createDirectStream[<span class="type">String</span>, <span class="type">String</span>](ssc,</span><br><span class="line">  <span class="type">PreferBrokers</span>, <span class="type">Subscribe</span>[<span class="type">String</span>, <span class="type">String</span>](topics, kafkaParams))</span><br></pre></td></tr></table></figure><p>kafka流中数据结构是key-value型。访问：.key() .value()</p><p>3、处理数据orders.txt</p><p>每行是一笔交易。Schema如下：</p><p>Order timestamp —Format yyyy-mm-dd hh:MM:ss<br>Order ID  —Serially incrementing integer<br>Client ID  —Integer randomly picked from the range 1 to 100<br>Stock symbol —Randomly picked from a list of 80 stock symbols<br>Number of stocks to be bought or sold —Random number from 1 to 1,000<br>Price at which to buy or sell—Random number from 1 to 100<br>Character B or S —Whether the event is an order to buy or sell</p><p>按以上构造一个case class。</p><p>case适用于Bean</p><p>编译器会添加 1、工厂方法。 2、域访问。 3、 toString, hashCode, and equals。4、copy方法。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span>(<span class="params">time:<span class="type">Timestamp</span>, orderId: <span class="type">Long</span>, cliendId: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">                     symbol: <span class="type">String</span>, amount: <span class="type">Int</span>, price: <span class="type">Double</span>, buy: <span class="type">Boolean</span></span>)</span></span><br></pre></td></tr></table></figure><p>然后处理Kafka中的value()。(kafka中的key()只是标识，不是我们所需的key()，要自己构造key-value)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val orders = kafkaStream.flatMap(....)</span><br></pre></td></tr></table></figure><p>4、构造key-value型DStream</p><p>由于二元组DStream隐式转换成PairDStreamFunctions的实例。这样，xxxByKey，flatMapValues这些都能派上用场了。</p><p>任务一：要计算每秒的买、卖数，做法：以order.buy类型为参数，构造key-value…</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> numPerType = orders.map(o =&gt; (o.buy, <span class="number">1</span>L)).reduceByKey(_ + _)</span><br></pre></td></tr></table></figure><p>任务二：前五…</p><p>任务一只需要当前批处理的数据，但任务二需要追踪时间和不同的mini-batches。</p><p><img src="https://ws1.sinaimg.cn/large/005wR1ytgy1fy4xsu32kwj30nd0irdh3.jpg" alt=""></p><p>使用updateStateByKey方法。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> amountPerClient = orders.map(o =&gt; (o.clientId, o.amount * o.price))</span><br><span class="line"></span><br><span class="line"><span class="comment">//累加</span></span><br><span class="line"><span class="keyword">val</span> amountState = amountPerClient.updateStateByKey(</span><br><span class="line">      (vals, totalOpt: <span class="type">Option</span>[<span class="type">Double</span>]) =&gt; &#123;</span><br><span class="line">        totalOpt <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Some</span>(total) =&gt; <span class="type">Some</span>(vals.sum + total)</span><br><span class="line">          <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="type">Some</span>(vals.sum)</span><br><span class="line">        &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后提取前五客户端ID。</p><p>为了每个Batch处理间隔只写一次结果，将以上结果倍合并。</p><p>使用mapWithState</p><p>此方法是updateStateByKey的性能改善。此方法只有一个参数，即StateSpec的实例。</p><p>StateSpec的函数签名</p><p><code>(Time, KeyType, Option[ValueType], State[StateType]) =&gt; Option[MappedType]</code></p><p>State对象的方法：</p><p>exsits()——若状态已定义，则返回true</p><p>get()——获得状态值</p><p>remove()——移除</p><p>update()——更新或设置键的状态值</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> updateAmountState = (cliendId: <span class="type">Long</span>, amount: <span class="type">Option</span>[<span class="type">Double</span>],</span><br><span class="line">                         state: <span class="type">State</span>[<span class="type">Double</span>]) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> total = amount.getOrElse(<span class="number">0.</span>toDouble)</span><br><span class="line">  <span class="keyword">if</span> (state.exists())</span><br><span class="line">    total += state.get()</span><br><span class="line">    </span><br><span class="line">  state.update(total) <span class="comment">//total设置为状态</span></span><br><span class="line">  <span class="type">Some</span>((cliendId, total))<span class="comment">//Option有两种类型：Some()和None</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> amountState = amountPerClient.mapWithState(<span class="type">StateSpec</span></span><br><span class="line">      .function(updateAmountState)).stateSnapshots()</span><br></pre></td></tr></table></figure><blockquote><p>Without that last method, stateSnapshots , you’d get a DStream with client ID s and<br>their total amounts, but only for the clients whose orders arrived during the current<br>mini-batch. stateSnaphots gives you a DStream with the whole state (all clients), just<br>like updateStateByKey.</p></blockquote><p>使用window操作来处理限制时间的计算</p><p><img src="https://ws1.sinaimg.cn/large/005wR1ytgy1fy59nnk0chj30qg0ih75y.jpg" alt=""></p><p>任务三：每小时前五</p><p>这里的窗口时间是一小时，滑动时间间隔可以设为批处理时间间隔（5s），这样可以在每个批处理间隔与其它指标一起产生。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//滑动时间间隔默认是mini-batch时间间隔</span></span><br><span class="line"><span class="keyword">val</span> stocksPerWindow = orders.map(x =&gt; (x.symbol, x.amount))</span><br><span class="line">  .window(<span class="type">Minutes</span>(<span class="number">60</span>)).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> top5ClList = top5Clients.repartition(<span class="number">1</span>)</span><br><span class="line">      .map(_._1.toString)</span><br><span class="line">      .glom() <span class="comment">//每个RDD中的partition聚合成Array</span></span><br><span class="line">      .map(arr =&gt; (<span class="string">"TOPCLIENTS"</span>, arr.toList))</span><br></pre></td></tr></table></figure><p>以上三类：每个批处理、批处理叠加、时间限制。</p><p>5、写回kafka。</p><p>方式：Producer.send()</p><p>最佳模式：每个JVM只创建一个Producer实例（单例模式）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaProducerWrapper</span>(<span class="params">brokerList: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> producerProps: <span class="type">Properties</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> prop = <span class="keyword">new</span> <span class="type">Properties</span>()</span><br><span class="line">    prop.put(<span class="string">"bootstrap.servers"</span>, brokerList)</span><br><span class="line">    prop.put(<span class="string">"key.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.ByteArraySerializer"</span>)</span><br><span class="line">    prop.put(<span class="string">"value.serializer"</span>, <span class="string">"org.apache.kafka.common.serialization.ByteArraySerializer"</span>)</span><br><span class="line">    prop</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> producer = <span class="keyword">new</span> <span class="type">KafkaProducer</span>[<span class="type">Array</span>[<span class="type">Byte</span>], <span class="type">Array</span>[<span class="type">Byte</span>]](producerProps)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">send</span></span>(topic: <span class="type">String</span>, key: <span class="type">String</span>, value: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    producer.send(<span class="keyword">new</span> <span class="type">ProducerRecord</span>[<span class="type">Array</span>[<span class="type">Byte</span>], <span class="type">Array</span>[<span class="type">Byte</span>]](topic,</span><br><span class="line">      key.toCharArray.map(_.toByte),</span><br><span class="line">      value.toCharArray.map(_.toByte)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">KafkaProducerWrapper</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> brokerList = <span class="string">""</span></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> instance = <span class="keyword">new</span> <span class="type">KafkaProducerWrapper</span>(brokerList)<span class="comment">//首次使用时实例化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在metrics主题下消费数据：</p><p>kafka-console-consumer –bootstrap-server localhost:9092 –topic metrics –property print.key=true</p>]]></content>
      
      
      
        <tags>
            
            <tag> bigdata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark API in Depth</title>
      <link href="/2018/11/30/bigdata/SparkInDepth/"/>
      <url>/2018/11/30/bigdata/SparkInDepth/</url>
      
        <content type="html"><![CDATA[<blockquote><p>《Spark in Action》Chapter4 </p></blockquote><p>个人总结： </p><ul><li>DStream &lt;- a seq of RDDs &lt;- Partitions</li><li>key-value RDD = pair RDD  manipulated by <code>funtionByKey()</code></li></ul><a id="more"></a><p><img src="http://ww1.sinaimg.cn/large/005wR1ytgy1fxpu01vvarj30gk07ydg6.jpg" alt=""></p><h3 id="pair-RDDs"><a href="#pair-RDDs" class="headerlink" title="pair RDDs"></a>pair RDDs</h3><p>key-value 模型是一种简单、通用的数据模型。</p><h4 id="Creating"><a href="#Creating" class="headerlink" title="Creating"></a>Creating</h4><p>利用map将RDD中数据转换成二元组（f(element), element)，即RDD-&gt;pair RDD。</p><p>原理：二元组形式的RDD会隐式转换为PairRDDFunctions的实例(Scala语法)。</p><h4 id="Basic-pair-RDD-functions"><a href="#Basic-pair-RDD-functions" class="headerlink" title="Basic pair RDD functions"></a>Basic pair RDD functions</h4><h5 id="getting-keys-and-values"><a href="#getting-keys-and-values" class="headerlink" title="getting keys and values"></a>getting keys and values</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pRDD.keys.distinct.count()</span><br></pre></td></tr></table></figure><h5 id="counting-values-per-key"><a href="#counting-values-per-key" class="headerlink" title="counting values per key"></a>counting values per key</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pRDD.countByKey()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最值</span></span><br><span class="line"><span class="keyword">val</span> (cid, purch) = transByCust.countByKey.toSeq.maxBy(_._2)</span><br></pre></td></tr></table></figure><h5 id="looking-up-values-for-a-single-key"><a href="#looking-up-values-for-a-single-key" class="headerlink" title="looking up values for a single key"></a>looking up values for a single key</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transByCust.lookup(<span class="number">53</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">transByCust.lookup(<span class="number">53</span>).foreach(tran =&gt; println(tran.mkString(<span class="string">", "</span>)))</span><br></pre></td></tr></table></figure><h5 id="using-the-mapValues-transformation-to-change-values-in-a-pair-RDD"><a href="#using-the-mapValues-transformation-to-change-values-in-a-pair-RDD" class="headerlink" title="using the mapValues transformation to change values in  a pair RDD"></a>using the mapValues transformation to change values in  a pair RDD</h5><p>只改变值</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">transByCust = transByCust.mapValues(tran =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (tran(<span class="number">3</span>).toInt == <span class="number">25</span> &amp;&amp; tran(<span class="number">4</span>).toDouble &gt; <span class="number">1</span>)</span><br><span class="line">        tran(<span class="number">5</span>) = (tran(<span class="number">5</span>).toDouble * <span class="number">0.95</span>).toString</span><br><span class="line"></span><br><span class="line">      tran</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h5 id="using-the-flatMapValues-transformation-to-add-values-to-keys"><a href="#using-the-flatMapValues-transformation-to-add-values-to-keys" class="headerlink" title="using the flatMapValues transformation to add values to keys"></a>using the flatMapValues transformation to add values to keys</h5><p>此函数可以给一个键添加多个值或一起移除某个键（键的数量会增减）。</p><blockquote><p>From each of the values in the return collection, a new key-value pair is created for the corresponding key.</p></blockquote><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">transByCust = transByCust.flatMapValues(tran =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (tran(<span class="number">3</span>).toInt == <span class="number">81</span> &amp;&amp; tran(<span class="number">4</span>).toDouble &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> cloned = tran.clone()</span><br><span class="line">        cloned(<span class="number">5</span>) = <span class="string">"0.00"</span></span><br><span class="line">        cloned(<span class="number">3</span>) = <span class="string">"70"</span></span><br><span class="line">        cloned(<span class="number">4</span>) = <span class="string">"1"</span></span><br><span class="line">        <span class="type">List</span>(tran, cloned)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">List</span>(tran)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)s</span><br></pre></td></tr></table></figure><h5 id="using-reduceByKey-transformation-to-merge-all-values-of-a-key"><a href="#using-reduceByKey-transformation-to-merge-all-values-of-a-key" class="headerlink" title="using reduceByKey transformation to merge all values of a key"></a>using reduceByKey transformation to merge all values of a key</h5><p>foldByKey 与 reduceByKey 类似，区别在于需要一个额外的 zeroValue 参数。</p><p><code>foldByKey(zeroValue: V)(func: (V, V) =&gt; V): RDD[(K, V)]</code></p><p> 由于RDD的并行特性，zeroValues可能被多次使用。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> amounts = transByCust.mapValues(t =&gt; t(<span class="number">5</span>).toDouble)</span><br><span class="line"><span class="keyword">val</span> totals = amounts.foldByKey(<span class="number">0</span>)(_ + _).collect()</span><br></pre></td></tr></table></figure><h5 id="using-aggregateByKey-to-group-all-values-of-a-key"><a href="#using-aggregateByKey-to-group-all-values-of-a-key" class="headerlink" title="using aggregateByKey to group all values of a key"></a>using aggregateByKey to group all values of a key</h5><h4 id="data-partition-and-reducing-data-shuffling"><a href="#data-partition-and-reducing-data-shuffling" class="headerlink" title="data partition and reducing data shuffling"></a>data partition and reducing data shuffling</h4><p>例如，当从本地文件系统加载文件到Spark时，文件内容被分割成分片，最终被分配到集群的结点上。这些分片形成了RDD，同一结点上可能不止一个分片。每个RDD维护一个分片列表。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(transByProd.partitions.length)</span><br></pre></td></tr></table></figure><blockquote><p>The number of RDD partitions is important because, in addition to influencing data distribution throughout the cluster, it also directly determines the number of tasks that will be running RDD transformations. If this number is too small, the cluster will be underutilized. Furthermore, memory problems could result, because working sets might get too big to fit into the memory of executors. We recommend using three to four times more partitions than there are cores in your cluster. Moderately larger values shouldn’t pose a problem, so feel free to experiment. But don’t get too crazy,because management of a large number of tasks could create a bottleneck.</p></blockquote><h5 id="using-Spark’s-data-partitioners"><a href="#using-Spark’s-data-partitioners" class="headerlink" title="using Spark’s data partitioners"></a>using Spark’s data partitioners</h5><p>两种：HashPartitioner、RangePartitioner。也可定制。</p><p>默认是HashPartitioner。</p><p>partitionIndex = hashCode % numberOfPartitions</p><h5 id="Understanding-and-avoiding-unnecessary-shuffling"><a href="#Understanding-and-avoiding-unnecessary-shuffling" class="headerlink" title="Understanding and avoiding unnecessary shuffling"></a>Understanding and avoiding unnecessary shuffling</h5><blockquote><p>Physical movement of data between partitions is called shuffling. </p><p>It occurs when data from multiple partitions needs to be combined in order to build partitions <strong>for a new RDD</strong> .When grouping elements by key，shuffling occurs.</p></blockquote><p>When grouping elements by key，shuffling occurs.</p><h5 id="Shuffling-when-explicitly-显式-changing-partitioners"><a href="#Shuffling-when-explicitly-显式-changing-partitioners" class="headerlink" title="Shuffling when explicitly(显式) changing partitioners"></a>Shuffling when explicitly(显式) changing partitioners</h5><blockquote><p>Because changing the partitioner provokes shuffles, the safest approach,performance-wise(性能优先), is to use a default partitioner as much as possible and avoidinadvertently causing a shuffle.</p></blockquote><h5 id="shuffing-caused-by-partitions-removal"><a href="#shuffing-caused-by-partitions-removal" class="headerlink" title="shuffing caused by partitions removal"></a>shuffing caused by partitions removal</h5><p>详细等学Spark优化再看。</p><h4 id="Repartitioning-RDDs"><a href="#Repartitioning-RDDs" class="headerlink" title="Repartitioning RDDs"></a>Repartitioning RDDs</h4><h5 id="partitionBy"><a href="#partitionBy" class="headerlink" title="partitionBy"></a>partitionBy</h5><p>只有pair RDD可用，接受一个Partitioner作为参数；当此Partition与原先的不一样时，shuffle发生，重新分片。</p><h5 id="collecting-partition-data-with-a-glom-transfotamtion"><a href="#collecting-partition-data-with-a-glom-transfotamtion" class="headerlink" title="collecting partition data with a glom transfotamtion"></a>collecting partition data with a glom transfotamtion</h5><p>glom(意思同 grab)，即将每个分片合成一个数组，用返回的RDD将这些数组作为元素。新RDD的数组数量等于之前的分片数量。这个过程中，partitioner被移除。</p><h4 id="Joining-sorting-and-grouping-data"><a href="#Joining-sorting-and-grouping-data" class="headerlink" title="Joining, sorting, and grouping data"></a>Joining, sorting, and grouping data</h4><p>join((K, (V, W))) 非空</p><p>leftOuterJoin  (K, (V, Option(W)))</p><p>rightOuterJoin (K, (Option(V), W))</p><p>fullOuterJoin (K, (Option(V), Option(W))</p><h5 id="using-subtract-差集"><a href="#using-subtract-差集" class="headerlink" title="using subtract(差集)"></a>using subtract(差集)</h5><p>…</p><h4 id="Using-accumulators-and-broadcast-variables-to-communicate-with-Spark-executors"><a href="#Using-accumulators-and-broadcast-variables-to-communicate-with-Spark-executors" class="headerlink" title="Using accumulators and broadcast variables to communicate with Spark executors"></a>Using accumulators and broadcast variables to communicate with Spark executors</h4><p>作用：维护全局状态或在任务和分片之间共享数据。</p><h5 id="sending-data-to-executors-using-broadcast-variables-bv"><a href="#sending-data-to-executors-using-broadcast-variables-bv" class="headerlink" title="sending data to executors using broadcast variables(bv)"></a>sending data to executors using broadcast variables(bv)</h5><p>能在集群间共享，与accumulators不同的是，其不能被执行器修改。驱动创造bv，然后执行器读取它。</p><p>当有一个大集合数据需要被绝大多数执行器使用时，应使用bv。</p><p>创建：<code>SparkContext.broadcast(value)</code>，读<code>Broadcast.value</code>。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li><p>pair RDD含二元组：keys 和 values。</p></li><li><p>scala中pair RDD隐式转换为pairRDDFuctions的实例，它有专有的pair RDD操作。</p></li><li><p>countByKey返回map，含每个键出现的次数。</p></li><li><p>mapValues，只改变pair RDD的值。</p></li><li><p>flatMapValues，一个键能对应零个或多个值（键的总数增加）。</p></li><li><p>reduceByKey和foldByKey，归约同一个键的所有值到一个值，值类型不变。</p></li><li><p>aggregateByKey，聚合值，但转换值到其它类型。</p></li><li><p>Data Partition，是Spark的一种在一个集群的多个结点间分数据的机制。</p></li><li><blockquote><p>The number of RDD partitions is important because, in addition to influencing<br>data distribution throughout the cluster, it also directly determines the number<br>of tasks that will be running RDD transformations.</p></blockquote></li><li><p>shffuling时，数据不仅被写到硬盘，而且在网络之间传输。因此，使Spark作业中的shuffle数最小化是重要的。</p></li><li><blockquote><p>Every Spark job is divided into stages based on the points where shuffles occur.</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> bigdata </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python编程中邂逅的问题</title>
      <link href="/2018/11/20/python/problem/"/>
      <url>/2018/11/20/python/problem/</url>
      
        <content type="html"><![CDATA[<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    print(i)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="comment"># output </span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><p>for 循环中的 循环变量 不会被修改，此时应使用 while。</p><a id="more"></a><h4 id="with表达式"><a href="#with表达式" class="headerlink" title="with表达式"></a>with表达式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'output/0.txt'</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    <span class="comment"># 这里的f2是动态变化的</span></span><br><span class="line">    f2 = open(<span class="string">'output/2.txt'</span>)</span><br><span class="line">    <span class="comment"># f2.close()</span></span><br><span class="line">    </span><br><span class="line">print(f2.readline())</span><br><span class="line">print(f1.readline())</span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line"><span class="number">2016</span><span class="number">-03</span><span class="number">-22</span> <span class="number">20</span>:<span class="number">25</span>:<span class="number">28</span>,<span class="number">20001</span>,<span class="number">89</span>,NQ,<span class="number">396</span>,<span class="number">58.00</span>,S</span><br><span class="line">        </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"D:/0hadoop/python/pystudy/action/test.py"</span>, line <span class="number">7</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line"></span><br><span class="line">    print(f1.readline())</span><br><span class="line">ValueError: I/O operation on closed file.</span><br></pre></td></tr></table></figure><p>with表达式建立的上下文会自动关闭IO。</p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = []</span><br><span class="line"><span class="comment"># return None,不应该作为参数,应该 fun(l + ["sth"]) </span></span><br><span class="line">l.append(<span class="string">"sth"</span>)</span><br></pre></td></tr></table></figure><h4 id=""><a href="#" class="headerlink" title="%"></a>%</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 7</span></span><br><span class="line">print(<span class="number">-123</span>%<span class="number">10</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -3</span></span><br><span class="line">System.out.println(-<span class="number">123</span>%<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="Python-IO"><a href="#Python-IO" class="headerlink" title="Python IO"></a>Python IO</h4><p>读text data</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读整个文件为一个字符串</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.txt'</span>)  <span class="keyword">as</span> f:</span><br><span class="line">data=f.read()</span><br><span class="line">    </span><br><span class="line"><span class="comment">#迭代处理文件    </span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br></pre></td></tr></table></figure><p>  写text data，会覆盖。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(text1)</span><br><span class="line">    f.write(text2)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'somefile.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment">#输出重定向到f，覆盖</span></span><br><span class="line">    print(line1,file=f)</span><br><span class="line">    print(line2,file=f)</span><br></pre></td></tr></table></figure><p>追加文本文件，open(… , ‘at’)</p><p>binary data</p><p>such as images、sound files等等。 </p><h4 id="Infinite"><a href="#Infinite" class="headerlink" title="Infinite"></a>Infinite</h4><p>如果只需要一个表示无限的数，可以用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float(<span class="string">'inf'</span>)</span><br><span class="line">float(<span class="string">'-inf'</span>)</span><br></pre></td></tr></table></figure><p>全局变量不要命名太简单，例如 i，j；否则容易与局部变量冲突。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 Learn</title>
      <link href="/2018/11/12/java/java8/"/>
      <url>/2018/11/12/java/java8/</url>
      
        <content type="html"><![CDATA[<p>行为参数化</p><ul><li>行为参数化，就是一个方法接受多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力。</li><li>行为参数化让代码更好地适应不断变化的要求，减轻未来的工作量。</li><li>传递代码，就是将新行为作为参数传递给方法。Java API中包括排序、线程和GUI处理。</li></ul><a id="more"></a><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p><strong>在哪里使用Lambda?</strong></p><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>函数式接口即只定义一个抽象方法的接口。</p><p><strong>Lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例（具体说来，是函数式接口一个具体实现的实例）。</strong></p><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BufferedReaderProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">process</span><span class="params">(BufferedReader b)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">processFile</span><span class="params">(BufferedReaderProcessor p)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader br =</span><br><span class="line">                     <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"data.txt"</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> p.process(br);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String oneLine = processFile((BufferedReader br) -&gt; br.readLine());</span><br><span class="line">        <span class="comment">// String oneLine = processFile(BufferedReader::readLine);</span></span><br><span class="line">        String twoLines = processFile(</span><br><span class="line">                (BufferedReader br) -&gt; br.readLine() + br.readLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用函数式接口"><a href="#使用函数式接口" class="headerlink" title="使用函数式接口"></a>使用函数式接口</h4><p>函数式接口很有用，因为抽象方法的签名可以描述Lambda表达式的签名。函数式接口的抽象方法的签名称为函数描述符。</p><p>Java API中已经有了几个函数式接口，比如 Comparable 、 Runnable 和Callable 。</p><p>Java 8 中有Predicate 、 Consumer 和 Function。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; nonEmptyStringPredicate = (String s) -&gt; !s.isEmpty();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(List&lt;T&gt; list, Consumer&lt;T&gt; c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(T i: list)&#123;</span><br><span class="line">    c.accept(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">forEach(</span><br><span class="line">    Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>),(Integer i) -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt;</span>&#123;</span><br><span class="line"><span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, R&gt; <span class="function">List&lt;R&gt; <span class="title">map</span><span class="params">(List&lt;T&gt; list,Function&lt;T, R&gt; f)</span></span>&#123;</span><br><span class="line">List&lt;R&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(T s: list)&#123;</span><br><span class="line">    result.add(f.apply(s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [7, 2, 6]</span></span><br><span class="line">List&lt;Integer&gt; l = map(Arrays.asList(<span class="string">"lambdas"</span>,<span class="string">"in"</span>,<span class="string">"action"</span>),(String s) -&gt; s.length());</span><br></pre></td></tr></table></figure><h4 id="原始类型特化"><a href="#原始类型特化" class="headerlink" title="原始类型特化"></a>原始类型特化</h4><p>比如，在下面的代码中，使用 IntPredicate 就避免了对值 1000 进行装箱操作，但要是用 <code>Predicate&lt;Integer&gt;</code> 就会把参数 1000 装箱到一个 Integer 对象中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntPredicate</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">IntPredicate evenNumbers = (<span class="keyword">int</span> i) -&gt; i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">evenNumbers.test(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">Predicate&lt;Integer&gt; oddNumbers = (Integer i) -&gt; i % <span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line">oddNumbers.test(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/11/06/5be0f72e8cebf.png" alt="funinter.PNG"></p><p><img src="https://i.loli.net/2018/11/09/5be538c6a377b.png" alt="funinter2.png"></p><p>因函数式接口都不允许抛出受检异常。如果需要Lambda表达式抛出异常，有两种方法：定义一个自己的函数式接口，并声明受检异常，或把Lambda包在一个try/catch块中。</p><h3 id="类型检查、类型推断以及限制"><a href="#类型检查、类型推断以及限制" class="headerlink" title="类型检查、类型推断以及限制"></a>类型检查、类型推断以及限制</h3><h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><p>Java编译器会从上下文（<strong>目标类型</strong>）推断出用什么函数式接口来配合Lambda表达式，这意味着它也可以推断出适合Lambda的签名，因为函数描述符可以通过目标类型来得到。这样做的好处在于，编译器可以了解Lambda表达式的参数类型，这样就可以在Lambda语法中<strong>省去标注</strong>参数类型。</p><h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>可以视为某些Lambda的快捷写法。可以重复使用现有的方法定义，并像Lambda一样传递它们。</p><p>如果一个Lambda表达式只是“直接调用这个方法”，那最好还是用名称来调用它，而不是去描述如何调用它。</p><h3 id="复合Lambda表达式的有用方法"><a href="#复合Lambda表达式的有用方法" class="headerlink" title="复合Lambda表达式的有用方法"></a>复合Lambda表达式的有用方法</h3><h4 id="比较器复合"><a href="#比较器复合" class="headerlink" title="比较器复合"></a>比较器复合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort(comparing(Apple::getWeight).reversed());</span><br></pre></td></tr></table></figure><h4 id="比较器链"><a href="#比较器链" class="headerlink" title="比较器链"></a>比较器链</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort(comparing(Apple::getWeight)</span><br><span class="line">    .reversed()</span><br><span class="line">    .thenComparing(Apple::getCountry));</span><br></pre></td></tr></table></figure><h4 id="谓词复合"><a href="#谓词复合" class="headerlink" title="谓词复合"></a>谓词复合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;Apple&gt; redAndHeavyAppleOrGreen =</span><br><span class="line">    redApple.and(a -&gt; a.getWeight() &gt; <span class="number">150</span>)</span><br><span class="line">    .or(a -&gt; <span class="string">"green"</span>.equals(a.getColor()));</span><br></pre></td></tr></table></figure><h4 id="函数复合"><a href="#函数复合" class="headerlink" title="函数复合"></a>函数复合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; f = x -&gt; x + <span class="number">1</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; g = x -&gt; x * <span class="number">2</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; h = f.andThen(g);</span><br><span class="line"><span class="keyword">int</span> result = h.apply(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>它允许以声明性方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。 </p><p><strong>只能遍历一次。</strong></p><h4 id="内部迭代与外部迭代"><a href="#内部迭代与外部迭代" class="headerlink" title="内部迭代与外部迭代"></a>内部迭代与外部迭代</h4><p>Java Collection外部迭代，Stream内部迭代。</p><p>内部迭代优点：可以透明地并行处理， 或者用更优化的顺序进行处理。</p><h4 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h4><p>诸如 filter 或 sorted 等中间操作会返回另一个流。这让多个操作可以连接起来形成一个查询。重要的是，除非流水线上触发一个终端操作，否则中间操作不会执行任何处理——它们很懒。</p><h4 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h4><p>终端操作会从流的流水线生成结果。其结果是任何不是流的值，比如 List 、 Integer ，甚至 void 。</p><h4 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h4><p>三件事：一数据源、二中间操作链、三终端操作。</p><p>流的流水线理念类似于构建器模式。</p><p><img src="https://i.loli.net/2018/11/06/5be14723ab807.png" alt="stream.PNG"></p><h3 id="筛选和切片"><a href="#筛选和切片" class="headerlink" title="筛选和切片"></a>筛选和切片</h3><h4 id="用谓词筛选"><a href="#用谓词筛选" class="headerlink" title="用谓词筛选"></a>用谓词筛选</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dish&gt; vegetarianMenu = menu.stream()</span><br><span class="line">.filter(Dish::isVegetarian)</span><br><span class="line">.collect(toList());</span><br></pre></td></tr></table></figure><p>流还支持一个叫作 distinct 的方法，它会返回一个元素各异（根据流所生成元素的hashCode 和 equals 方法实现）的流。</p><h4 id="截短流"><a href="#截短流" class="headerlink" title="截短流"></a>截短流</h4><p>流支持 limit(n) 方法，该方法会返回一个不超过给定长度的流。</p><h4 id="跳过元素"><a href="#跳过元素" class="headerlink" title="跳过元素"></a>跳过元素</h4><p>流还支持 skip(n) 方法，返回一个扔掉了前 n 个元素的流。</p><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><h4 id="流的扁平化"><a href="#流的扁平化" class="headerlink" title="流的扁平化"></a>流的扁平化</h4><p> Arrays.stream() 的方法可以接受一个数组并产生一个流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; uniqueCharacters =</span><br><span class="line">    words.stream()</span><br><span class="line">    .map(w -&gt; w.split(<span class="string">""</span>))</span><br><span class="line">    .flatMap(Arrays::stream)</span><br><span class="line">    .distinct()</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>flatMap合并为一个流。</p><h4 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h4><p>allMatch、anyMatch、noneMatch、findFirst、findAny</p><h5 id="短路求值"><a href="#短路求值" class="headerlink" title="短路求值"></a>短路求值</h5><p>对于流而言，某些操作（例如 allMatch 、 anyMatch 、 noneMatch 、 findFirst 和 findAny ）不用处理整个流就能得到结果。只要找到一个元素，就可以有结果了。同样， limit 也是一个短路操作：它只需要创建一个给定大小的流，而用不着处理流中所有的元素。在碰到无限大小的流的时候，这种操作就有用了：它们可以把无限流变成有限流。</p><h4 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h4><h5 id="算术"><a href="#算术" class="headerlink" title="算术"></a>算术</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = numbers.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a + b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = numbers.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure><h5 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; max = numbers.stream().reduce(Integer::max);</span><br></pre></td></tr></table></figure><h4 id="原始类型流特化"><a href="#原始类型流特化" class="headerlink" title="原始类型流特化"></a>原始类型流特化</h4><p>IntStream、DoubleStream、LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本。还带来了进行常用数值归约的新方法，如sum、max。</p><p> IntStream 还支持其他的方便方法，如max 、 min 、 average 等。</p><h5 id="映射到数值流"><a href="#映射到数值流" class="headerlink" title="映射到数值流"></a>映射到数值流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> calories = menu.stream()</span><br><span class="line">    .mapToInt(Dish::getCalories)</span><br><span class="line">    .sum();</span><br></pre></td></tr></table></figure><h5 id="转换回对象流"><a href="#转换回对象流" class="headerlink" title="转换回对象流"></a>转换回对象流</h5><p>IntStream 上的操作只能产生原始整数： IntStream 的 map 操作接受的Lambda必须接受 int 并返回 int。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = intStream.boxed();</span><br></pre></td></tr></table></figure><h5 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h5><p>Java 8引入了两个可以用于 IntStream 和 LongStream 的静态方法，帮助生成这种范围：range 和 rangeClosed 。这两个方法都是第一个参数受起始值，第二个参数接受结束值。但range 是不包含结束值的，而 rangeClosed 则包含结束值。</p><h3 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h3><h4 id="由值创建流"><a href="#由值创建流" class="headerlink" title="由值创建流"></a>由值创建流</h4><p>静态方法Stream.of，通过显示值创建流。可接受任意数量的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Java 8 "</span>, <span class="string">"Lambdas "</span>, <span class="string">"In "</span>, <span class="string">"Action"</span>);</span><br></pre></td></tr></table></figure><p>可使用empty得到一个空流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; emptyStream = Stream.empty();</span><br></pre></td></tr></table></figure><h4 id="由数组创建流"><a href="#由数组创建流" class="headerlink" title="由数组创建流"></a>由数组创建流</h4><p>Arrays.stream接受数组作为参数，例如，可将一个原始类型int转换成IntStream。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] numbers = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = Arrays.stream(numbers).sum();</span><br></pre></td></tr></table></figure><h4 id="由文件生成流"><a href="#由文件生成流" class="headerlink" title="由文件生成流"></a>由文件生成流</h4><p>Java NIO（非阻塞IO）</p><h4 id="由函数生成流：创建无限流"><a href="#由函数生成流：创建无限流" class="headerlink" title="由函数生成流：创建无限流"></a>由函数生成流：创建无限流</h4><p>Stream API提供了两个静态方法来从函数生成流： Stream.iterate 和 Stream.generate 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>)</span><br><span class="line">    .limit(<span class="number">10</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>都是按需生成，但generate不是依次对每个新生成的值应用函数。它接受一个<code>Supplier&lt;T&gt;</code>类型的Lambda提供新的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(Math::random)</span><br><span class="line">    .limit(<span class="number">5</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="用流-lt-收集-gt-数据"><a href="#用流-lt-收集-gt-数据" class="headerlink" title="用流&lt;收集&gt;数据"></a>用流&lt;收集&gt;数据</h3><p>函数式编程相对于指令式编程一个主要的优势：只需指出希望的结果——“做什么”，而不用操心执行的步骤——“如何做”。</p><h4 id="预定义收集器"><a href="#预定义收集器" class="headerlink" title="预定义收集器"></a>预定义收集器</h4><p>三大功能：</p><ul><li>将流元素归约和汇总为一个值</li><li>元素分组</li><li>元素分区</li></ul><h4 id="归约和汇总"><a href="#归约和汇总" class="headerlink" title="归约和汇总"></a>归约和汇总</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> howManyDishes = menu.stream().count()；</span><br><span class="line"><span class="keyword">int</span> howManyDishes = menu.size();</span><br></pre></td></tr></table></figure><h5 id="查找流中的最大值和最小值"><a href="#查找流中的最大值和最小值" class="headerlink" title="查找流中的最大值和最小值"></a>查找流中的最大值和最小值</h5><p>Collectors.maxBy 和Collectors.minBy ，用来计算流中的最大或最小值。这两个收集器接收一个 Comparator 参数来比较流中的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Dish&gt; dishCaloriesComparator =</span><br><span class="line">Comparator.comparingInt(Dish::getCalories);</span><br><span class="line"></span><br><span class="line">Optional&lt;Dish&gt; mostCalorieDish =</span><br><span class="line">    menu.stream()</span><br><span class="line">    .collect(maxBy(dishCaloriesComparator));</span><br><span class="line"></span><br><span class="line">Optional&lt;Dish&gt; mostCalorieDish =</span><br><span class="line">                menu.stream()</span><br><span class="line">                        .max(dishCaloriesComp);</span><br></pre></td></tr></table></figure><h5 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求和</span></span><br><span class="line"><span class="keyword">int</span> totalCalories =</span><br><span class="line">menu.stream().collect(summingInt(Dish::getCalories));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> totalCalories =</span><br><span class="line">                menu.stream()</span><br><span class="line">                        .mapToInt(Dish::getCalories).sum();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求平均值</span></span><br><span class="line"><span class="keyword">double</span> avgCalories =</span><br><span class="line">menu.stream().collect(averagingInt(Dish::getCalories));</span><br><span class="line"></span><br><span class="line">OptionalDouble avgCalories2 =</span><br><span class="line">                menu.stream()</span><br><span class="line">                        .mapToDouble(Dish::getCalories)</span><br><span class="line">                        .average();</span><br></pre></td></tr></table></figure><p>有时候，我们可能希望得到两个或更多这样的结果，而且只需要一次操作就可以完成。此时，可以使用summarizingInt工厂方法返回收集器。例如，通过一次summarinzing操作，即可得到菜肴热量的总和、平均值、最大值、最小值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics menuStatistics =</span><br><span class="line">menu.stream().collect(summarizingInt(Dish::getCalories));</span><br></pre></td></tr></table></figure><p>收集到一个IntSummaryStatisics中，它提供了一个取值方法来访问结果。</p><h5 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h5><p>joining工厂方法返回一个收集器会把对流中的每一个对象应用toString方法得到的字符串连接成一个字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String shortMeu = menu.stream().map(Dish::getName).collect(joining());</span><br></pre></td></tr></table></figure><p>joining内部使用StringBuilder。如果Dish类有一个toString方法来返回菜肴的名称，那无需用提取每一道菜名称的函数来对原流做映射，就能得到相同的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String shortMenu = menu.stream().collect(joining());</span><br></pre></td></tr></table></figure><p>joining()工厂方法有一个重载版本，可接受分界符，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String shortMenu = menu.stream().map(Dish::getName).collect(joining(<span class="string">", "</span>));</span><br></pre></td></tr></table></figure><h4 id="广义的归约汇总"><a href="#广义的归约汇总" class="headerlink" title="广义的归约汇总"></a>广义的归约汇总</h4><p>以上所有的收集器，都可以用reducing方法定义归约过程。以上方法只是方便程序员而已。</p><p><strong>collect与reduce</strong>: collect()适合表达可变容器上的归约，更关键的是它适合并行操作。</p><p><strong>根据情况选择最佳方案</strong></p><h4 id="以下开始发挥collect的作用"><a href="#以下开始发挥collect的作用" class="headerlink" title="以下开始发挥collect的作用"></a>以下开始发挥collect的作用</h4><h5 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h5><p><code>Collections.groupingBy(Function)</code></p><p>Function称为分类函数。分组操作的结果是一个Map。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, List&lt;Dish&gt;&gt; dishesByType =</span><br><span class="line">menu.stream().collect(groupingBy(Dish::getType));</span><br></pre></td></tr></table></figure><p>可用Lambda编写复杂的分类函数。</p><p><code>Collections.groupingBy(Function,Collector)</code></p><p>接受collector类型的第二个参数，进行二级分组。可把一个内层的groupingBy传递给外层的groupingBy，作为二级分类标准。</p><p>这里的collector可以是任意类型，例如counting()，maxBy()。</p><p><code>maxBy(Comparator)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Optional&lt;Dish&gt;&gt; mostCaloricByType =</span><br><span class="line">    menu.stream()</span><br><span class="line">    .collect(groupingBy(Dish::getType,</span><br><span class="line">    maxBy(comparingInt(Dish::getCalories))));</span><br></pre></td></tr></table></figure><p> groupingBy 收集器只有在应用分组条件后，第一次在流中找到某个键对应的元素时才会把键加入分组 Map 中。这意味着 Optional 包装器在这里不是很有用。</p><p>把收集器返回的结果转换为另一种类型，你可以使用Collectors.collectingAndThen 工厂方法返回的收集器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Dish&gt; mostCaloricByType =</span><br><span class="line">menu.stream()</span><br><span class="line">        .collect(groupingBy(Dish::getType,</span><br><span class="line">        collectingAndThen(</span><br><span class="line">            maxBy(comparingInt(Dish::getCalories)),</span><br><span class="line">            Optional::get)));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Integer&gt; totalCaloriesByType =</span><br><span class="line">    menu.stream().collect(groupingBy(Dish::getType,</span><br><span class="line">    summingInt(Dish::getCalories)));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Set&lt;CaloricLevel&gt;&gt; caloricLevelsByType =</span><br><span class="line">    menu.stream().collect(</span><br><span class="line">    groupingBy(Dish::getType, mapping(</span><br><span class="line">    dish -&gt; &#123; <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT; &#125;,</span><br><span class="line">        toSet() )));</span><br></pre></td></tr></table></figure><p>注意在上一个示例中，对于返回的 Set 是什么类型并没有任何保证。但通过使用 toCollection ，你就可以有更多的控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Set&lt;CaloricLevel&gt;&gt; caloricLevelsByType =</span><br><span class="line">    menu.stream().collect(</span><br><span class="line">    groupingBy(Dish::getType, mapping(</span><br><span class="line">    dish -&gt; &#123; <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT; &#125;,</span><br><span class="line">    toCollection(HashSet::<span class="keyword">new</span>) )));</span><br></pre></td></tr></table></figure><h5 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h5><p>它是分组的特殊情况：由一个谓词（返回布尔值的函数）作为分类函数，称为分区函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Dish&gt;&gt; partitionedMenu =</span><br><span class="line">                menu.stream()</span><br><span class="line">                      .collect(partitioningBy(Dish::isVegetarian));</span><br><span class="line"></span><br><span class="line">List&lt;Dish&gt; vegetarianDishes = partitionedMenu.get(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>分区的好处在于保留了分区函数返回 true 或 false 的两套流元素列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, Dish&gt; mostCaloricPartitionedByVegetarian =</span><br><span class="line">menu.stream().collect(</span><br><span class="line">        partitioningBy(Dish::isVegetarian,</span><br><span class="line">        collectingAndThen(</span><br><span class="line">        maxBy(comparingInt(Dish::getCalories)),</span><br><span class="line">        Optional::get)));</span><br></pre></td></tr></table></figure><p>可以仿造groupingBy多级分区。</p><p><img src="http://ww1.sinaimg.cn/large/005wR1ytgy1fx53bfox7aj30wg0cqmyx.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005wR1ytgy1fx53bfsibxj30v00tdn2l.jpg" alt=""></p><h3 id="收集器接口"><a href="#收集器接口" class="headerlink" title="收集器接口"></a>收集器接口</h3><p>可为collector接口提供自己的实现，从而自由地创建自定义归约操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Supplier&lt;A&gt; <span class="title">supplier</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">BiConsumer&lt;A, T&gt; <span class="title">accumulator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Function&lt;A, R&gt; <span class="title">finisher</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">BinaryOperator&lt;A&gt; <span class="title">combiner</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h3><p>对顺序流调用parallel方法，并不意味着流本身有任何实际的变化。它在内部实际上就是设了一个 boolean 标志，表示你想让调用 parallel 之后进行的所有操作都并行执行。</p><p>并行流内部使用了默认的ForkJoinPool，它默认的线程数量是处理器的数量，可由Runtime.getRuntime().availableProcessors()得到。</p><p><strong>避免共享可变状态，确保并行 Stream 得到正确的结果。</strong></p><p><img src="http://ww1.sinaimg.cn/large/005wR1ytgy1fx54gljrqpj30ua08rdg5.jpg" alt=""></p><p>并行流无需显式地处理线程和同步问题。</p><h4 id="自定义Spliterator"><a href="#自定义Spliterator" class="headerlink" title="自定义Spliterator"></a>自定义Spliterator</h4><p>因为原始的 String 在任意位置拆分，所以有时一个词会被分为两个词，然后数了两次。这就说明，拆分流会影响结果，而把顺序流换成并行流就可能使结果出错。</p><p>如何解决这个问题呢？解决方案就是要确保 String 不是在随机位置拆开的，而只能在尾<br>拆开。要做到这一点，你必须为 Character 实现一个 Spliterator ，它只能在两个词之间拆开String （如下所示），然后由此创建并行流。</p><h3 id="Optional替代Null"><a href="#Optional替代Null" class="headerlink" title="Optional替代Null"></a>Optional替代Null</h3><h4 id="如何为缺失的对象建模？"><a href="#如何为缺失的对象建模？" class="headerlink" title="如何为缺失的对象建模？"></a>如何为缺失的对象建模？</h4><p>Optional：当变量存在时，Optional类只是对类的简单封装。当变量不存在时，缺失的值被建模成一个“空”的Optional对象，由方法Optional.empty返回。 Optional.empty() 方法是一个静态工厂方法，它返回 Optional 类的特定单一实例。</p><p>Optional.empty()用处：</p><p><img src="http://ww1.sinaimg.cn/large/005wR1ytgy1fx5b99awl1j30t60b3mym.jpg" alt=""></p><h4 id="应用Optional"><a href="#应用Optional" class="headerlink" title="应用Optional"></a>应用Optional</h4><h5 id="创建Optional对象："><a href="#创建Optional对象：" class="headerlink" title="创建Optional对象："></a>创建Optional对象：</h5><ol><li><p>声明一个空的Optional</p><p><code>Optional&lt;Car&gt; optCar= Optional.empty();</code></p></li><li><p>依据一个非空值创建Optional</p><p><code>Optional&lt;Car&gt; optCar = Optional.of(car);</code></p><p>若car是null，抛出NPE。</p></li><li><p>可接受null的Optional</p><p><code>Optional&lt;Car&gt; optCar = Optional.ofNullable(car);</code>    </p></li></ol><p>Optional提供的get方法在遭遇空的Optional对象时，也会抛出异常。</p><p>怎么办？</p><h5 id="使用map从Optional对象中提取和转换值"><a href="#使用map从Optional对象中提取和转换值" class="headerlink" title="使用map从Optional对象中提取和转换值"></a>使用map从Optional对象中提取和转换值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCarInsuranceName</span><span class="params">(Optional&lt;Person&gt; person)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> person.flatMap(Person::getCar)</span><br><span class="line">        .flatMap(Car::getInsurance)</span><br><span class="line">        .map(Insurance::getName)</span><br><span class="line">        .orElse(<span class="string">"Unknown"</span>); <span class="comment">// Optional为空时，设置默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Optional 类设计时就没特别考虑将其作为类的字段使用，所以它也并未实现<br>Serializable 接口。</p><p>若要实现序列化的域模型，作为替代方案，提供一个能访问声明为 Optional 、变量值可能缺失的接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;Car&gt; <span class="title">getCarAsOptional</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(car);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CompleptableFuture-组合式异步编程"><a href="#CompleptableFuture-组合式异步编程" class="headerlink" title="CompleptableFuture:组合式异步编程"></a>CompleptableFuture:组合式异步编程</h3><h4 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h4><p>它设计初衷是为将来某个时刻会发生的结果进行建模。</p><p><img src="http://ww1.sinaimg.cn/large/005wR1ytgy1fx5deji7d2j30q90ao0um.jpg" alt=""></p><p>这种编程方式让你的线程可以在 ExecutorService 以并发方式调用另一个线程执行耗时操作的同时，去执行一些其他的任务。接着，如果你已经运行到没有异步操作的结果就无法继续任何有意义的工作时，可以调用它的 get 方法去获取操作的结果。如果操<br>作已经完成，该方法会立刻返回操作的结果，否则它会阻塞你的线程，直到操作完成，返回相应的结果。</p><p>Future 接口的局限性：很难表述 Future 结果之间的依赖性。</p><p>于是CompletableFuture，CompletableFuture 和 Future 的关系就跟 Stream 和 Collection 的关系一样。</p><h4 id="使用-CompletableFuture-构建异步应用"><a href="#使用-CompletableFuture-构建异步应用" class="headerlink" title="使用 CompletableFuture 构建异步应用"></a>使用 CompletableFuture 构建异步应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Double&gt; <span class="title">getPriceAsync</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">CompletableFuture&lt;Double&gt; futurePrice = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> Thread( () -&gt; &#123;</span><br><span class="line">    <span class="keyword">double</span> price = calculatePrice(product);</span><br><span class="line">    futurePrice.complete(price);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无需等待尚未结束的计算，直接返回Future对象</span></span><br><span class="line">    <span class="keyword">return</span> futurePrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用工厂方法-supplyAsync-创建-CompletableFuture"><a href="#使用工厂方法-supplyAsync-创建-CompletableFuture" class="headerlink" title="使用工厂方法 supplyAsync 创建 CompletableFuture"></a>使用工厂方法 supplyAsync 创建 CompletableFuture</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Double&gt; <span class="title">getPriceAsync</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; calculatePrice(product));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>supplyAsync 方法接受一个生产者（ Supplier ）作为参数，返回一个CompletableFuture对象，该对象完成异步执行后会读取调用生产者方法的返回值。</p><p>生产者方法会交由 ForkJoinPool池中的某个执行线程（ Executor ）运行，但是你也可以使用 supplyAsync 方法的重载版本，传递第二个参数指定不同的执行线程执行生产者方法。一般而言，向 CompletableFuture 的工厂方法传递可选参数，指定生产者方法的执行线程是可行的。</p><h5 id="使用-CompletableFuture-发起异步请求"><a href="#使用-CompletableFuture-发起异步请求" class="headerlink" title="使用 CompletableFuture 发起异步请求"></a>使用 CompletableFuture 发起异步请求</h5><p><img src="http://ww1.sinaimg.cn/large/005wR1ytgy1fx5drh2b6uj30u608k3zg.jpg" alt=""></p><p>这里使用两个不同的Stream流水线的原因是：流操作之间存在延迟。如果在单一的流水线中处理流，发向不同商家的请求只能以同步、顺序执行的方式才会成功。</p><h3 id="寻找更好的方案"><a href="#寻找更好的方案" class="headerlink" title="寻找更好的方案"></a>寻找更好的方案</h3><p> 当任务数超过四个时，定制执行器。</p><p>N(threads) = N(CPU) <em> U(CPU) </em> (1 + W/C)<br>其中：</p><ul><li>N CPU 是处理器的核的数目，可以通过 Runtime.getRuntime().availableProce-<br>ssors() 得到</li><li>U CPU 是期望的CPU利用率（该值应该介于0和1之间）</li><li>W/C是等待时间与计算时间的比率</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor executor =</span><br><span class="line">    Executors.newFixedThreadPool(Math.min(shops.size(), <span class="number">100</span>),</span><br><span class="line">        <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">            t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>Java程序无法终止或者退出一个正在运行中的线程，所以最后剩下的那个线程会由于一直等待无法发生的事件而引发问题。与此相反，如果将线程标记为守护进程，意味着程序退出时它也会被回收。这二者之间没有性能上的差异。</p><h4 id="并行——使用流还是-CompletableFutures-？"><a href="#并行——使用流还是-CompletableFutures-？" class="headerlink" title="并行——使用流还是 CompletableFutures ？"></a>并行——使用流还是 CompletableFutures ？</h4><ul><li>如果进行的是计算密集型的操作，并且没有IO，推荐使用Stream接口，因为实现简单，同时效率也可能是最高的（如果所有线程都是计算密集型，根据以上估算公式，就没有必要创建比处理器核数更多的线程）。</li><li>反之，如果你并行的工作单元还涉及等待I/O的操作（包括网络连接等待），那么使用CompletableFuture 灵活性更好，你可以像前文讨论的那样，依据等待/计算，或者W/C的比率设定需要使用的线程数。这种情况不使用并行流的另一个原因是，处理流的流水线中如果发生I/O等待，流的延迟特性会让我们很难判断到底什么时候触发了等待。</li></ul><h4 id="对多个异步任务进行流水线操作"><a href="#对多个异步任务进行流水线操作" class="headerlink" title="对多个异步任务进行流水线操作"></a>对多个异步任务进行流水线操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findDiscountFuture</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">        List&lt;CompletableFuture&lt;String&gt;&gt; futureList = shops.stream()</span><br><span class="line">                .map(shop -&gt;</span><br><span class="line">                        CompletableFuture.supplyAsync(</span><br><span class="line">                                () -&gt; shop.getName() + <span class="string">" price is "</span> + shop.getPrice(product),executor))</span><br><span class="line">                .map(future -&gt; future.thenApply(Quote::parse))</span><br><span class="line">                .map(future -&gt; future.thenCompose(quote -&gt;</span><br><span class="line">                        CompletableFuture.supplyAsync(</span><br><span class="line">                                () -&gt; Discount.applyDiscount(quote), executor)))</span><br><span class="line">                .collect(toList());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> futureList.stream()</span><br><span class="line">                .map(CompletableFuture::join)</span><br><span class="line">                .collect(toList());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>thenCompose方法允许对两个异步操作进行流水线，第一个操作完成时，将其结果作为参数传递给第二个操作。换句话说，即创建两个CompletableFuture对象调用thenCompose，并向其传递一个Function。当第一个CompletableFuture执行完毕后，它的结果结果将作为该函数的参数， 这个函数返回值是以第一个 CompletableFuture 的返回做输入计算出的第二个 CompletableFuture 对象。</p><p> thenCompose 方法像 CompletableFuture 类中的其他方法一<br>样，也提供了一个以 Async 后缀结尾的版本 thenComposeAsync 。通常而言，名称中不带 Async的方法和它的前一个任务一样，在同一个线程中运行；而名称以 Async 结尾的方法会将后续的任务提交到一个线程池，所以每个任务是由不同的线程处理的。就这个例子而言，第二个CompletableFuture 对象的结果取决于第一个CompletableFuture ，所以无论你使用哪个版本的方法来处理 CompletableFuture 对象，对于最终的结果，或者大致的时间而言都没有多少差别。我们选择 thenCompose 方法的原因是因为它更高效一些，因为少了很多线程切换的开销。</p><p>主线程还能执行其它重要的操作，如响应UI。</p><p>另一种比较常见的情况是，你需要将两个完全不相干的 CompletableFuture 对象的结果整合起来，而且你也不希望等到第一个任务完全结束才开始第二项任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Double&gt; futurePriceInUSD =</span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; shop.getPrice(product))</span><br><span class="line">    .thenCombine(</span><br><span class="line">    CompletableFuture.supplyAsync(</span><br><span class="line">    () -&gt; exchangeService.getRate(Money.EUR, Money.USD)),</span><br><span class="line">    (price, rate) -&gt; price * rate</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>这里thenCombine方法，它接受BiFunction作为第二个参数，这个参数定义了两个CompletableFuture 对象完成计算后，如何合并结果。它的Async版本是：导致BiFunction中定义的合并操作被提交到线程池中，由另一个任务以异步的方式执行。<strong>其中的两个CompletableFuture 对象是在不同的线程执行的。</strong></p><p><strong>CompletableFuture 利用Lambda表达式以声明式的API提供了一种机制，能够用最有效的方式，非常容易地将多个以同步或异步方式执行复杂操作的任务结合到一起。</strong></p><h4 id="响应-CompletableFuture-的-completion-事件"><a href="#响应-CompletableFuture-的-completion-事件" class="headerlink" title="响应 CompletableFuture 的 completion 事件"></a>响应 CompletableFuture 的 completion 事件</h4><p>避免的首要的问题是，等待创建一个包含了所有价格的List创建完成。应该直接处理CompletableFuture。这样每个 CompletableFuture 都在为某个商店执行必要的操<br>作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Stream&lt;CompletableFuture&lt;String&gt;&gt; findDiscountStream(String product) &#123;</span><br><span class="line">        <span class="keyword">return</span> shops.stream()</span><br><span class="line">                .map(shop -&gt;</span><br><span class="line">                        CompletableFuture.supplyAsync(</span><br><span class="line">                                () -&gt; shop.getName() + <span class="string">" price is "</span> + shop.getPrice(product),</span><br><span class="line">                                executor))</span><br><span class="line">                .map(future -&gt; future.thenApply(Quote::parse))</span><br><span class="line">                .map(future -&gt; future.thenCompose(quote -&gt;</span><br><span class="line">                        CompletableFuture.supplyAsync(</span><br><span class="line">                                () -&gt; Discount.applyDiscount(quote), executor)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">findPricesStream(<span class="string">"myPhone"</span>).map(f -&gt; f.thenAccept(System.out::println));</span><br></pre></td></tr></table></figure><p>thenAccept方法也有Async版本。异步版本会对处理结果的消费者进行调度，从线程池中选择一个新的线程继续执行，不再由同一个线程完成CompletableFuture的所有任务。</p><p>如果想避免不必要的上下文切换，避免在等待线程上浪费时间，尽快响应CompletableFuture的completion事件，可以不使用异步版本。</p><p>由于 thenAccept 方法已经定义了如何处理 CompletableFuture 返回的结果，一旦<br>CompletableFuture 计算得到结果，它就返回一个<code>CompletableFuture&lt;Void&gt;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture[] futures = findPricesStream(<span class="string">"myPhone"</span>)</span><br><span class="line">    .map(f -&gt; f.thenAccept(System.out::println))</span><br><span class="line">    .toArray(size -&gt; <span class="keyword">new</span> CompletableFuture[size]);</span><br><span class="line">CompletableFuture.allOf(futures).join();</span><br></pre></td></tr></table></figure><p>allOf 工厂方法接收一个由 CompletableFuture 构成的数组，数组中的所有CompletableFuture 对象执行完成之后，它返回一个<code>CompletableFuture&lt;Void&gt;</code> 对象。这意味着，如果你需要等待最初 Stream 中的所有 CompletableFuture 对象执行完毕，对 allOf 方法返回的CompletableFuture 执行 join 操作是个不错的主意。</p><p>然而在另一些场景中，你可能希望只要 CompletableFuture 对象数组中有任何一个执行完毕就不再等待，比如，你正在查询两个汇率服务器，任何一个返回了结果都能满足你的需求。在这种情况下，你可以使用一个类似的工厂方法 anyOf 。该方法接收一个 CompletableFuture 对象构成的数组，返回由第一个执行完毕的 CompletableFuture 对象的返回值构成的<code>CompletableFuture&lt;Object&gt;</code> 。</p><h3 id="新的日期和时间API"><a href="#新的日期和时间API" class="headerlink" title="新的日期和时间API"></a>新的日期和时间API</h3>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FluentPy Note（2）</title>
      <link href="/2018/11/02/python/fluentpy2/"/>
      <url>/2018/11/02/python/fluentpy2/</url>
      
        <content type="html"><![CDATA[<h3 id="可迭代对象、迭代器和生成器"><a href="#可迭代对象、迭代器和生成器" class="headerlink" title="可迭代对象、迭代器和生成器"></a>可迭代对象、迭代器和生成器</h3><p>迭代器模式：惰性获取数据项的方式。</p><a id="more"></a><p>所有生成器都是迭代器，因为生成器完全实现了迭代器接口。在 Python社区中，大多数时候都把迭代器和生成器视作同一概念。</p><p>生成器应用广泛，即使是内置的range()也返回类似生成器对象，如果一定要返回列表，必须明确指明（例如，list(range(100))）。</p><p>序列可以迭代的原因：iter函数。</p><p>内置的iter函数有以下作用。</p><ol><li>检查对象是否实现了<code>__iter__</code>方法，如果实现了即调用，获取一个迭代器。</li><li>如果没有实现<code>__iter__</code>方法，但实现了<code>__getitem__</code>方法。Python会创建一个迭代器，尝试按顺序（从索引0开始）获取元素。</li><li>失败，抛出TypeError异常。</li></ol><p>任何 Python 序列都可迭代的原因是，它们都实现了<code>__getitem__</code> 方法。其实，标准的序列也都实现了 <code>__iter__</code>方法，因此你也应该这么做。之所以对 <code>__getitem__</code> 方法做特殊处理，是为了向后兼容，而未来可能不会再这么做（不过，写作本书时还未弃用）。</p><p>检查对象 x 能否迭代，最准确的方法是：调用 iter(x) 函数，如果不可迭代，再处理 TypeError 异常。</p><h4 id="实现标准的可迭代协议"><a href="#实现标准的可迭代协议" class="headerlink" title="实现标准的可迭代协议"></a>实现标准的可迭代协议</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sentence</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.words = RE_WORD.findall(text)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Sentence(%s)'</span> % reprlib.repr(self.text)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span> </span><br><span class="line">    <span class="keyword">return</span> SentenceIterator(self.words) </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SentenceIterator</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, words)</span>:</span></span><br><span class="line">        self.words = words </span><br><span class="line">        self.index = <span class="number">0</span> </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">        word = self.words[self.index] </span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration() </span><br><span class="line">        self.index += <span class="number">1</span> </span><br><span class="line">        <span class="keyword">return</span> word</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span> </span><br><span class="line">        <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure><p>Python函数中有yield生成器函数，返回生成器。</p><p>生成器表达式可以理解为列表推导的惰性版本：不会迫切地构建列表，而是返回一个生成器，按需惰性生成元素。</p><h4 id="标准库中的生成器函数"><a href="#标准库中的生成器函数" class="headerlink" title="标准库中的生成器函数"></a>标准库中的生成器函数</h4><p>按用途可分为以下几类：</p><ul><li>过滤</li><li>映射</li><li>合并</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">vowel</span><span class="params">(c)</span>:</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">return</span> c.lower() <span class="keyword">in</span> <span class="string">'aeiou'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(vowel, <span class="string">'Aardvark'</span>))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> itertools</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.filterfalse(vowel, <span class="string">'Aardvark'</span>))</span><br><span class="line">[<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'v'</span>, <span class="string">'r'</span>, <span class="string">'k'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.dropwhile(vowel, <span class="string">'Aardvark'</span>))</span><br><span class="line">[<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'v'</span>, <span class="string">'a'</span>, <span class="string">'r'</span>, <span class="string">'k'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.takewhile(vowel, <span class="string">'Aardvark'</span>))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.compress(<span class="string">'Aardvark'</span>, (<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>)))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.islice(<span class="string">'Aardvark'</span>, <span class="number">4</span>))</span><br><span class="line">[<span class="string">'A'</span>, <span class="string">'a'</span>, <span class="string">'r'</span>, <span class="string">'d'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.islice(<span class="string">'Aardvark'</span>, <span class="number">4</span>, <span class="number">7</span>))</span><br><span class="line">[<span class="string">'v'</span>, <span class="string">'a'</span>, <span class="string">'r'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.islice(<span class="string">'Aardvark'</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>))</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>]</span><br></pre></td></tr></table></figure><p> yield from 语句。这个语句的作用就是把不同的生成器结合在一起使用。</p><h3 id="上下文管理器和-else-块"><a href="#上下文管理器和-else-块" class="headerlink" title="上下文管理器和 else 块"></a>上下文管理器和 else 块</h3><p>with open 创建文件不创建路径。</p><p>仅当 try 块中没有异常抛出时才运行 else 块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">dangerous_call()</span><br><span class="line"><span class="keyword">except</span> OSError:</span><br><span class="line">log(<span class="string">'OSError...'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">after_call()</span><br></pre></td></tr></table></figure><p>with语句的目的是简化try/finally模式。</p><p>与函数和模块不同，with 块没有定义新的作用域。</p><h3 id="多线程与协程"><a href="#多线程与协程" class="headerlink" title="多线程与协程"></a>多线程与协程</h3><p>标准库中所有执行阻塞型 I/O 操作的函数，在等待操作系统返回结果时都会释放 GIL。这意味着在 Python 语言这个层次上可以使用多线程，而 I/O 密集型 Python 程序能从中受益：一个 Python 线程等待网络响应时，阻塞型 I/O 函数会释放 GIL，再运行一个线程。</p><blockquote><p> <strong>Concurrency</strong> is when two or more tasks can start, run, and complete in overlapping time periods. It doesn’t necessarily mean they’ll ever both be running at the same instant. For example, <em>multitasking</em>on a single-core machine.</p><p><strong>Parallelism</strong> is when tasks <em>literally</em> run at the same time, e.g., on a multicore processor.</p></blockquote><blockquote><p>异步库依赖于低层线程（直至内核级线程），但是这些库的用户无需创建线程，也无需知道用到了基础设施中的低层线程。在应用中，我们只需确保没有阻塞的代码，事件循环会在背后处理并发。异步系统能避免用户级线程的开销，这是它能比多线程系统管理更多并发连接的主要原因。</p></blockquote><p>并发：充分运用CPU资源，主要是针对线程。</p><h4 id="Coroutines"><a href="#Coroutines" class="headerlink" title="Coroutines"></a>Coroutines</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">say_after</span><span class="params">(delay, what)</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    print(what)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">f"started at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">1</span>, <span class="string">'hello'</span>)</span><br><span class="line">    <span class="keyword">await</span> say_after(<span class="number">2</span>, <span class="string">'world'</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"finished at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><h5 id="asyncio-run-coro-debug-False"><a href="#asyncio-run-coro-debug-False" class="headerlink" title="asyncio.run(coro,*,debug=False)"></a>asyncio.run(coro,*,debug=False)</h5><p>当前线程存在一个事件循环时，该函数不能调用。</p><p>该函数调用时新建一个事件循环并在结束时关闭循环。它应该被用作异步程序的主入口并且理想情况下，应该只调用一次。</p><h4 id="Task-Object"><a href="#Task-Object" class="headerlink" title="Task Object"></a>Task Object</h4><h5 id="class-asyncio-Task-coro-loop-None"><a href="#class-asyncio-Task-coro-loop-None" class="headerlink" title="class asyncio.Task(coro,*,loop=None)"></a>class asyncio.Task(coro,*,loop=None)</h5><p>Task用于在事件循环中运行协程。当一个协程等待一个Future时，Task中断协程的执行并等待Future完成。当Future完成，协程恢复。</p><p>事件循环使用竞争调度：一个事件循环同一时间只运行一个任务。然而，当一任务等待Future的完成时，事件循环运行其他任务等。</p><h5 id="asyncio-create-task-coro"><a href="#asyncio-create-task-coro" class="headerlink" title="asyncio.create_task(coro)"></a>asyncio.create_task(coro)</h5><p>把协程包装成Task并调度其执行。Task在事件循环中执行，这个循环通过get_running_loop()获得，若当前线程没有事件循环，抛出RuntimeError。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">say_after</span><span class="params">(delay, what)</span>:</span></span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay)</span><br><span class="line">    print(what)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task1 = asyncio.create_task(say_after(<span class="number">1</span>, <span class="string">'hello'</span>))</span><br><span class="line">    task2 = asyncio.create_task(say_after(<span class="number">2</span>, <span class="string">'world'</span>))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"started at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"><span class="comment"># 并发执行</span></span><br><span class="line">    <span class="keyword">await</span> task1</span><br><span class="line">    <span class="keyword">await</span> task2</span><br><span class="line"></span><br><span class="line">    print(<span class="string">f"finished at <span class="subst">&#123;time.strftime(<span class="string">'%X'</span>)&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><h4 id="Awaitables"><a href="#Awaitables" class="headerlink" title="Awaitables"></a>Awaitables</h4><blockquote><p>There are three main types of <em>awaitable</em> objects: <strong>coroutines</strong>, <strong>Tasks</strong>, and <strong>Futures</strong>.</p></blockquote><blockquote><p><em>Tasks</em> are used to schedule coroutines <em>concurrently</em>.</p></blockquote><blockquote><p>A Future is a special low-level awaitable object that represents an eventual result of an asynchronous operation.</p><p>Normally <strong>there is no need</strong> to create Future objects at the application level code.</p></blockquote><h4 id="coroutine-asyncio-sleep-delay-result-None-loop-None"><a href="#coroutine-asyncio-sleep-delay-result-None-loop-None" class="headerlink" title="coroutine asyncio.sleep(delay, result=None, *, loop=None)"></a>coroutine asyncio.sleep(delay, result=None, *, loop=None)</h4><blockquote><p><code>sleep()</code> always suspends the current task, allowing other tasks to run.</p></blockquote><h4 id="Running-Tasks-Concurrently"><a href="#Running-Tasks-Concurrently" class="headerlink" title="Running Tasks Concurrently"></a>Running Tasks Concurrently</h4><h5 id="awaitable-asyncio-gather-aws-loop-None-return-exceptions-False"><a href="#awaitable-asyncio-gather-aws-loop-None-return-exceptions-False" class="headerlink" title="awaitable asyncio.gather(*aws, loop=None, return_exceptions=False)"></a>awaitable asyncio.gather(*aws, loop=None, return_exceptions=False)</h5><p>并发执行aws序列中的awaitable对象。</p><p>如果aws中有协程，自动当作Task调度。</p><blockquote><p>If all awaitables are completed successfully, the result is an aggregate list of returned values. The order of result values corresponds to the order of awaitables in <em>aws</em>.</p></blockquote><blockquote><p>If return_exceptions is False (default), the first raised exception is immediately propagated to the task that awaits on gather(). Other awaitables in the aws sequence won’t be cancelled and will continue to run.</p><p>If return_exceptions is True, exceptions are treated the same as successful results, and aggregated in the result list.</p><p>If gather() is cancelled, all submitted awaitables (that have not completed yet) are also cancelled.</p><p>If any Task or Future from the aws sequence is cancelled, it is treated as if it raised CancelledError – the gather() call is not cancelled in this case. This is to prevent the cancellation of one submitted Task/Future to cause other Tasks/Futures to be cancelled.</p></blockquote><h3 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h3><p>使用点号访问属性时，Python解释器会调用特殊方法（<code>__getattr__</code>和<code>__setattr__</code>）计算属性。</p><p><strong>特性：在不改变类接口的前提下，使用存取方法（即读值方法和设值方法）修改数据属性。</strong></p><h4 id="使用特性验证属性"><a href="#使用特性验证属性" class="headerlink" title="使用特性验证属性"></a>使用特性验证属性</h4><p>@property</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        <span class="comment"># 这里已经使用特性的设值方法了</span></span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subtotal</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight * self.price</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 真正的值存储在私有属性 __weight 中</span></span><br><span class="line">        <span class="keyword">return</span> self.__weight</span><br><span class="line"></span><br><span class="line"><span class="meta">    @weight.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weight</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">            self.__weight = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br></pre></td></tr></table></figure><blockquote><p>被装饰的读值方法有个 .setter 属性，这个属性也是装饰器；这个装饰器把读值方法和设值方法绑定在一起。</p></blockquote><p>虽然property经常被当作装饰器使用，但它其实是一个类。构造方法如下：</p><p><code>property(fget=None, fset=None, fdel=None, doc=None)</code></p><p>老版Python这样用：weight = property(get_weight, set_weight)</p><h5 id="特性会覆盖实例属性"><a href="#特性会覆盖实例属性" class="headerlink" title="特性会覆盖实例属性"></a>特性会覆盖实例属性</h5><p>特性都是类属性，但特性管理的其实是实例属性的存取。</p><p>实例属性遮盖类的数据属性，但实例属性不会遮盖类特性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span>:</span> </span><br><span class="line">    data = <span class="string">'the class data attr'</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">prop</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'the prop value'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Class.prop <span class="comment"># 获取特性对象本身，不会运行特性读值方法</span></span><br><span class="line">&lt;property object at <span class="number">0x1072b7408</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.prop <span class="comment"># 执行特性的读值方法</span></span><br><span class="line"><span class="string">'the prop value'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.prop = <span class="string">'foo'</span> </span><br><span class="line"><span class="comment"># 尝试给obj设置prop实例属性，失败（这实现了只读）</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">AttributeError: can<span class="string">'t set attribute</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">&gt;&gt;&gt; obj.__dict__['</span>prop<span class="string">'] = '</span>foo<span class="string">'</span></span><br><span class="line"><span class="string"># 但是可以直接把 '</span>prop<span class="string">' 存入 obj.__dict__</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; vars(obj) # </span></span><br><span class="line"><span class="string">&#123; '</span>data<span class="string">': '</span>ba<span class="string">r','</span>prop<span class="string">': '</span>foo<span class="string">'&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; obj.prop </span></span><br><span class="line"><span class="string"># 然而，读取 obj.prop 时仍会运行特性的读值方法。特性没被实例属</span></span><br><span class="line"><span class="string"># 性遮盖。 </span></span><br><span class="line"><span class="string">'</span>the prop value<span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt;&gt;&gt; Class.prop = '</span>baz<span class="string">' </span></span><br><span class="line"><span class="string"># 覆盖 Class.prop 特性，销毁特性对象。 </span></span><br><span class="line"><span class="string">&gt;&gt;&gt; obj.prop </span></span><br><span class="line"><span class="string"># 现在，obj.prop 获取的是实例属性。 </span></span><br><span class="line"><span class="string">'</span>foo<span class="string">'</span></span><br></pre></td></tr></table></figure><h4 id="定义特性工厂函数"><a href="#定义特性工厂函数" class="headerlink" title="定义特性工厂函数"></a>定义特性工厂函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantity</span><span class="params">(storage_name)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qty_getter</span><span class="params">(instance)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> instance.__dict__[storage_name]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">qty_setter</span><span class="params">(instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">      <span class="comment"># storage_name确定特性数据存储在哪儿</span></span><br><span class="line">            instance.__dict__[storage_name] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> property(qty_getter, qty_setter)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListItem</span>:</span></span><br><span class="line">    <span class="comment"># 使用工厂函数将自定义特性weight定义为类属性</span></span><br><span class="line">    weight = quantity(<span class="string">'weight'</span>)</span><br><span class="line">    price = quantity(<span class="string">'price'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        <span class="comment"># 这里使用特性设值方法</span></span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br></pre></td></tr></table></figure><h4 id="影响属性处理方式的特殊属性"><a href="#影响属性处理方式的特殊属性" class="headerlink" title="影响属性处理方式的特殊属性"></a>影响属性处理方式的特殊属性</h4><ul><li><code>__class__</code>对象所属类的引用，Python的<code>__getattr__</code>只在类中寻找，而不在实例中寻找。<code>__getattr__</code>只处理不存在的属性名。</li><li><code>__dict__</code>存储对象或类的可写属性。</li></ul><h4 id="特殊方法"><a href="#特殊方法" class="headerlink" title="特殊方法"></a>特殊方法</h4><ul><li><code>__delattr__(self, name)</code> 只要使用 del 语句删除属性，就会调用这个方法。</li><li><code>__getattr__(self, name)</code>仅当获取指定的属性失败，搜索过 obj、Class 和超类之后调用。表达式 obj.no_such_attr、getattr(obj, ‘no_such_attr’) 和hasattr(obj, ‘no_such_attr’) 可能会触发<code>Class.__getattr__(obj, &#39;no_such_attr&#39;)</code>方法，但是，仅当在<br>obj、Class 和超类中找不到指定的属性时才会触发。</li><li><code>__getattribute__(self, name)</code> 点号与 getattr 和 hasattr 内置函数会触发这个方法。尝试获取指定的属性时总会调用这个方法，不过，寻找的属性是特殊属性或特殊方法时除外。调用 <code>__getattribute__</code> 方法且抛出 AttributeError异常时，才会调用 <code>__getattr__</code>方法。</li><li><code>__setattr__(self, name, value)</code> 点号和 setattr 内置函数会触发这个方法。</li></ul><h3 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h3><p>描述符是对<strong>多个</strong>属性运行相同存取逻辑的一种方法。</p><p>描述符是实现了特定协议的类，这个协议包括<code>__get__</code>、<code>__set__</code>和<code>__delete__</code>。其实，我们在真实的代码中见到的大多数描述符只实现了 <code>__get__</code> 和<code>__set__</code> 方法，还有很多只实现了其中的一个。</p><p>property 类实现了完整的描述符协议。</p><p>特性工厂函数借助函数式编程模式避免重复编写读值方法和设值方法。解决这种问题的面向对象的方法是描述符类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span>:</span> <span class="comment">#描述符类基于协议实现</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, storage_name)</span>:</span></span><br><span class="line">        self.storage_name = storage_name </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 尝试为托管属性赋值（weight、price）赋值时，会调用__set__</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span> </span><br><span class="line">        <span class="keyword">if</span> value &gt; <span class="number">0</span>:</span><br><span class="line">        instance.__dict__[self.storage_name] = value </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    weight = Quantity(<span class="string">'weight'</span>) </span><br><span class="line">    price = Quantity(<span class="string">'price'</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span> </span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br></pre></td></tr></table></figure><h3 id="类元编程"><a href="#类元编程" class="headerlink" title="类元编程"></a>类元编程</h3><p>类元编程是指在运行时创建或定制类的技术。</p><p>类装饰器也是函数，不过能够审查、修改，甚至把被装饰的类替换成其他类。</p><p>导入时和运行时区别——是有效使用Python元编程的重要基础。</p><h4 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoStorage</span>:</span></span><br><span class="line">    <span class="comment"># __counter = 0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""初始化工作在类修饰器中"""</span></span><br><span class="line">        <span class="comment"># cls = self.__class__</span></span><br><span class="line">        <span class="comment"># prefix = cls.__name__</span></span><br><span class="line">        <span class="comment"># index = cls.__counter</span></span><br><span class="line">        <span class="comment"># self.storage_name = f"_&#123;prefix&#125;#&#123;index&#125;"</span></span><br><span class="line">        <span class="comment"># cls.__counter += 1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> getattr(instance, self.storage_name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        setattr(instance, self.storage_name, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Validated</span><span class="params">(abc.ABC, AutoStorage)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        value = self.validate(instance, value)</span><br><span class="line">        super().__set__(instance, value)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="string">"""return vaildated value or ValueError"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quantity</span><span class="params">(Validated)</span>:</span></span><br><span class="line">    <span class="string">"""a number greater than zero"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> value &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value must be &gt; 0'</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonBlank</span><span class="params">(Validated)</span>:</span></span><br><span class="line">    <span class="string">"""a string non-space"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validate</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        value = value.strip()</span><br><span class="line">        <span class="keyword">if</span> len(value) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'value cannot be empty or blank'</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">entity</span><span class="params">(cls)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> key, attr <span class="keyword">in</span> cls.__dict__.items():</span><br><span class="line">        <span class="keyword">if</span> isinstance(attr, Validated):</span><br><span class="line">            type_name = type(attr).__name__</span><br><span class="line">            attr.storage_name = <span class="string">f"_<span class="subst">&#123;type_name&#125;</span>#<span class="subst">&#123;key&#125;</span>"</span></span><br><span class="line">    <span class="keyword">return</span> cls</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> model_v5 <span class="keyword">as</span> model</span><br><span class="line"></span><br><span class="line"><span class="meta">@model.entity</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line">    description = model.NonBlank()</span><br><span class="line">    weight = model.Quantity()</span><br><span class="line">    price = model.Quantity()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, description, weight, price)</span>:</span></span><br><span class="line">        self.description = description</span><br><span class="line">        self.weight = weight</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    item1 = LineItem(<span class="string">"something"</span>, <span class="number">15</span>, <span class="number">12</span>)</span><br><span class="line">    print(dir(item1)[:<span class="number">3</span>])</span><br><span class="line">    print(LineItem.description.storage_name)</span><br><span class="line">    print(item1.description)</span><br><span class="line">    print(getattr(item1, <span class="string">'_NonBlank#description'</span>))</span><br></pre></td></tr></table></figure><p>类装饰器以较简单的方式做到以前元类去做的事情——创建类时定制类。</p><p>类装饰器有个重大缺点：只对直接依附的类有效。这意味着，被装饰的类的子类可能继承也可能不继承装饰器所做的改动，具体情况视改动的方式而定。</p><h4 id="元类"><a href="#元类" class="headerlink" title="元类"></a>元类</h4><p>用于构建类的类。Python中，类也是对象，因此类必然是某个类的实例。默认情况下，Python类是type类的实例。也就是说，type 是大多数内置的类和用户定义的类的元类。为了避免无限回溯，type 是其自身的实例。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FluentPy Note（1）</title>
      <link href="/2018/11/02/python/fluentpy/"/>
      <url>/2018/11/02/python/fluentpy/</url>
      
        <content type="html"><![CDATA[<h3 id="python数据模型"><a href="#python数据模型" class="headerlink" title="python数据模型"></a>python数据模型</h3><h4 id="如何创建符合python风格的类？"><a href="#如何创建符合python风格的类？" class="headerlink" title="如何创建符合python风格的类？"></a>如何创建符合python风格的类？</h4><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Card = collections.namedtuple(<span class="string">'Card'</span>, [<span class="string">'rank'</span>, <span class="string">'suit'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span>:</span></span><br><span class="line">    <span class="string">"""扑克牌类"""</span></span><br><span class="line"></span><br><span class="line">    ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">11</span>)] + list(<span class="string">'JQKA'</span>)</span><br><span class="line">    suits = <span class="string">'spades diamonds clubs hearts'</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                      <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, position)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._cards[position]</span><br></pre></td></tr></table></figure><p>因<code>__getitem__</code>方法把 <strong>[ ]</strong> 操作交给self._cards列表，故FrenchDeck自动支持切片。</p><p>实现<code>__getitem__</code>方法，这个类就变成可迭代的；实现<code>__len__</code>，则可调用<code>len()</code></p><p>迭代通常是隐式的，譬如一个集合类型没有实现<code>__contains__</code>方法，那么<strong>in</strong>运算符就会按顺序做一次迭代搜索。于是，in可用在FrenchDeck类上。</p><p>以上，通过实现<code>__len()__</code>和<code>__getitem__</code>，FrenchDeck就跟Python自有的<strong>序列数据类型</strong>一样，可以体现Python语言的核心特性（例如迭代和切片）。</p><h4 id="如何使用特殊方法"><a href="#如何使用特殊方法" class="headerlink" title="如何使用特殊方法"></a>如何使用特殊方法</h4><p>特殊方法是为被解释器调用的，在执行<code>len(my_object)</code>时，若<code>my_object</code>是自定义对象，那么解释器调用其实现的<code>__len__</code></p><p>如果是内置类型，如<code>list</code>、<code>str</code>、<code>bytearray</code>，CPython会抄近路…，快得多。</p><p>很多时候，特殊方法的调用是隐式的，如</p><p><code>for i in x -&gt; iter(x) -&gt; x.__iter__()</code></p><p>通常自己的代码无需<strong>直接</strong>使用特殊方法，除非有大量的元编程存在。</p><h4 id="字符串表现形式"><a href="#字符串表现形式" class="headerlink" title="字符串表现形式"></a>字符串表现形式</h4><p><code>repr()</code>对应<code>__repr__()</code>，<code>str()</code>对应<code>__str__()</code></p><p><code>!r</code>和<code>!s</code>是对应的格式符</p><p>两者的区别在于，<code>__str__</code>是在<code>str()</code>函数被使用，或是在print<strong>打印一个对象</strong>时候调用，且其返回的字符串更友好，没有引号<code>(&#39;&#39;)</code></p><p>如果只想实现这两个特殊方法中的一个，<code>__repr__</code>是更好的选择。用为如果没有<code>__str__</code>，解释器会用<code>__repr__</code>作为替代。</p><h4 id="自定义布尔值"><a href="#自定义布尔值" class="headerlink" title="自定义布尔值"></a>自定义布尔值</h4><p>默认情况下，自定义类的实例总被认为是真，除非这个类对<code>__bool__</code>或者<code>__len__</code></p><p>有自己的实现。<code>bool(x)</code>调用<code>x.__bool__()</code>；若未定义<code>__bool__</code>方法，则尝试调用<code>x.__len__()</code>。若返回0，则为False，否则为True。</p><h4 id="python中为False"><a href="#python中为False" class="headerlink" title="python中为False"></a>python中为False</h4><ul><li>constants defined to be false: <code>None</code> and <code>False</code>.</li><li>zero of any numeric type: <code>0</code>, <code>0.0</code>, <code>0j</code>, <code>Decimal(0)</code>, <code>Fraction(0, 1)</code></li><li>empty sequences and collections: <code>&#39;&#39;</code>, <code>()</code>, <code>[]</code>, <code>{}</code>, <code>set()</code>, <code>range(0)</code></li></ul><h4 id="python特殊方法"><a href="#python特殊方法" class="headerlink" title="python特殊方法"></a>python特殊方法</h4><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">方法名</th></tr></thead><tbody><tr><td style="text-align:center">字符串/字节序列表示形式</td><td style="text-align:center"><code>__repr__  __str__  __format__  __bytes__</code></td></tr><tr><td style="text-align:center">数值转换</td><td style="text-align:center"><code>__abs__ __bool__ __complex__ __int__ __float__ __hash__ __index__</code></td></tr><tr><td style="text-align:center">集合模拟</td><td style="text-align:center"><code>__len__ __getitem__ __setitem__ __delitem__ __contains__</code></td></tr><tr><td style="text-align:center">迭代模拟</td><td style="text-align:center"><code>__iter__ __reversed__ __next__</code></td></tr><tr><td style="text-align:center">可调用模拟</td><td style="text-align:center"><code>__call__</code></td></tr><tr><td style="text-align:center">实例创建和销毁</td><td style="text-align:center"><code>__new__ __init__ __del__</code></td></tr><tr><td style="text-align:center">属性管理</td><td style="text-align:center"><code>__getattr__ __getattribute__ __setattr__ __delattr__ __dir__</code></td></tr><tr><td style="text-align:center">属性描述符</td><td style="text-align:center"><code>__get__ __set__ __delete__</code></td></tr></tbody></table><p>小结：通过实现特殊方法，自定义数据类型可以表现得跟内置类型一样，从而让我们写出更具表达力的代码——或者说，更具 Python 风格的代码。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="python序列类型"><a href="#python序列类型" class="headerlink" title="python序列类型"></a>python序列类型</h4><ul><li>容器序列：list、tuple和collections.deque 这些序列存放不同类型的数据。</li><li>扁平序列：str、bytes、bytearray、memoryview和array.array 这些只能容纳一种类型</li></ul><p>容器序列存放的是任意类型对象的<strong>引用</strong>，而扁平序列存放的是<strong>值</strong>。即，扁平序列其实是一段连续的内存空间。由此可见，扁平序列更加紧凑，但只能存诸如字符、字节和数值这些基础类型。</p><p>序列还能按是否被修改分类：</p><ul><li>可变序列 list、bytearray、array.array、collections.deque和memoryview</li><li>不可变序列 tuple、str和bytes</li></ul><p><img src="https://i.loli.net/2018/10/28/5bd5a17fdbf0a.png" alt="fluentpy1.PNG"></p><h4 id="列表推导"><a href="#列表推导" class="headerlink" title="列表推导"></a>列表推导</h4><p>内置函数 ord() ：返回字符的Unicode码，如ord(‘a’)返回97； 与 chr() 效果相反。</p><p>列表推导同filter和map比较</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">symbols = <span class="string">'$¢£¥€¤'</span></span><br><span class="line">beyond_ascii = [ord(s) <span class="keyword">for</span> s <span class="keyword">in</span> symbols <span class="keyword">if</span> ord(s) &gt; <span class="number">127</span>]</span><br><span class="line">beyond_ascii = list(filter(<span class="keyword">lambda</span> c: c &gt; <span class="number">127</span>, map(ord, symbols)))</span><br></pre></td></tr></table></figure><h4 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h4><p>虽然也能用列表推导来初始化元组、数组和其他序列类型，但生成器是更好的选择。</p><p>因为生成器表达式遵守迭代器协议，可逐个产出元素，而不是建立一个完整的列表，节约内存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple(ord(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols)</span><br></pre></td></tr></table></figure><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>可用作不可变的列表，还可以用于<strong>没有字段名的记录</strong>。</p><p>若将元组理解为数据记录：元组中的每个元素都存放了记录中一个字段的数据，外加这个字段的位置。</p><h5 id="元组拆包"><a href="#元组拆包" class="headerlink" title="元组拆包"></a>元组拆包</h5><p>元组拆包可应用到任何可迭代的对象上（可迭代元素拆包）。</p><ul><li><p>平行赋值<code>latitude, longitude = (33.9425, -118.408056)</code></p></li><li><p>还可以用<code>*</code>运算符把可迭代对象拆开作为函数的参数 </p><p><code>quotient, remainder = divmod(*t)</code>。</p></li><li><p>拆包中，_  为占位符。</p></li><li><p>用<em>来处理剩下的元素 ` a, b, </em>rest = range(5)`</p></li><li><p>嵌套元组拆包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, cc, pop, (latitude, longitude) <span class="keyword">in</span> metro_areas:</span><br></pre></td></tr></table></figure></li></ul><h5 id="具名元组"><a href="#具名元组" class="headerlink" title="具名元组"></a>具名元组</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Card = collections.namedtuple(<span class="string">'Card'</span>, [<span class="string">'rank'</span>, <span class="string">'suit'</span>])</span><br></pre></td></tr></table></figure><p>namedtuple构建的类的实例所消耗的内存跟元组一样，因字段名都被存在对应的类里。</p><p>这个实例跟普通的对象实例比起来也要小一些，因Python不会用<code>__dict__</code>来存放这些实例的属性。</p><p>具名元组的专有属性：</p><ul><li><code>_fields</code>属性是一个包含这个类所有字段的元组</li><li><code>_make()</code>通过接受一个可迭代对象来生成这个类的一个实例</li><li><code>_asdict()</code>把具名元组以collections.OrderedDict形式返回，友好呈现数据</li></ul><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p><code>s[a:b:c]</code>形式对s在a和b之间以c为间隔取值。c也可以为负，意味反向取值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'bicycle'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::<span class="number">3</span>]</span><br><span class="line"><span class="string">'bye'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::<span class="number">-1</span>]</span><br><span class="line"><span class="string">'elcycib'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::<span class="number">-2</span>]</span><br><span class="line"><span class="string">'eccb'</span></span><br></pre></td></tr></table></figure><p>可以把切片放在赋值语句左边，或把它作为del操作的对象。</p><h4 id="对序列使用-和"><a href="#对序列使用-和" class="headerlink" title="对序列使用+和*"></a>对序列使用+和*</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l * <span class="number">5</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>注意在<code>l*n</code>语句中，当序列 <code>l</code>里的元素是对其他可变对象的引用时：</p><p>如 <code>my_list= [[]]*3</code>，此时得到的列表里包含的其实是三个引用，而这三个引用指向的是用一个列表。</p><h4 id="序列的增量赋值"><a href="#序列的增量赋值" class="headerlink" title="序列的增量赋值"></a>序列的增量赋值</h4><p>+=背后的特殊方法是<code>__iadd__</code>（“就地加法”）。但如果一个类没有实现这个方法的话，Python会退一步调用<code>__add__</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a += b</span><br></pre></td></tr></table></figure><p>如果 a 实现了<code>__iadd__</code> 方法，就会调用这个方法。同时对可变序列（例如 list、bytearray 和 array.array）来说，a 会就地改动，就像调用了 a.extend(b) 一样。但是如果 a 没有实现<code>__iadd__</code> 的话，a+= b 这个表达式的效果就变得跟 a = a + b 一样了：首先计算 a +b，得到一个新的对象，然后赋值给 a。</p><h4 id="list-sort-和内置的sorted"><a href="#list-sort-和内置的sorted" class="headerlink" title="list.sort()和内置的sorted()"></a>list.sort()和内置的sorted()</h4><p>参数：reversed 、key</p><p>可用bisect管理已排序的序列</p><h4 id="当列表不是首选时"><a href="#当列表不是首选时" class="headerlink" title="当列表不是首选时"></a>当列表不是首选时</h4><ul><li>存放1000万个浮点数，数组（array）的效率要高得多，因数组背后存放的不是float对象，而是数字的机器翻译，也就是字节表述。</li><li>如果需要频繁对序列做先进先出的操作，deque（双端队列）的速度更快。</li><li>若检查一个元素是否出现的操作频率很高，用set更合适。</li></ul><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>如果需要一个只包含数字的列表，那么 array.array 比 list 更高效。数组支持所有跟可变序列有关的操作，包括 .pop 、.insert 和 .extend。另外，数组还提供从文件读取和存入文件的更快的方法，如 .frombytes 和 .tofile。</p><p>创建数组需要指定类型码，如 </p><ul><li>b 类型码代表有符号的字符（signed char）</li><li>d 代表双精度实数</li><li>h 代表短整型有符号整数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">floats = array(<span class="string">'d'</span>, (random() <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span> ** <span class="number">7</span>)))</span><br><span class="line">print(floats[<span class="number">-1</span>])</span><br><span class="line"><span class="comment"># 存</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'output/test/floats.bin'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    floats.tofile(fp)</span><br><span class="line"></span><br><span class="line">floats2 = array(<span class="string">'d'</span>)</span><br><span class="line"><span class="comment"># 取</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'output/test/floats.bin'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    floats2.fromfile(fp, <span class="number">10</span> ** <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">print(floats2[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure><p>数组排序，需新建一个数组<code>a = array.array(a.typecode, sorted(a))</code></p><p>memoryview是内置类，它能让用户在不复制内容的情况下操作同一个数组的不同切片。</p><h5 id="双向队列和其他形式队列"><a href="#双向队列和其他形式队列" class="headerlink" title="双向队列和其他形式队列"></a>双向队列和其他形式队列</h5><p>列表利用 .append 和 .pop(0) 合起来，就能模拟队列“先进先出”特点，但是删除列表的第一个元素（在第一个元素前插入元素）之类的操作很耗时，因这些操作牵扯移动列表里所有元素。</p><p>collections.deque（双向队列）是一个线程安全、可以快速从两端添加或删除元素的数据类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq = deque(range(<span class="number">10</span>), maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.rotate(<span class="number">3</span>) <span class="comment"># 右移</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.rotate(<span class="number">-4</span>) <span class="comment"># 左移</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.appendleft(<span class="number">-1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.extend([<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>], maxlen=<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq.extendleft([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dq</span><br><span class="line">deque([<span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], maxlen=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>双向队列也付出了一些代价，从队列中间删除元素的操作会慢一些，因为它只对在头尾的操作进行了优化。</p><h3 id="字典和集合"><a href="#字典和集合" class="headerlink" title="字典和集合"></a>字典和集合</h3><h4 id="泛映射类型"><a href="#泛映射类型" class="headerlink" title="泛映射类型"></a>泛映射类型</h4><p><img src="https://i.loli.net/2018/10/29/5bd6aca589c06.png" alt="fluentpy2.PNG"></p><p>以上是形式化的文档，定义了最基本的接口，还可以用来跟 isinstance 做类型判断。非抽象映射类型一般直接对 dict 或是 collections.User.Dict 进行扩展。</p><p>标准库中所有的映射类型都是利用<strong>dict</strong>来实现的，因此有共同的限制，即只有<strong>可散列</strong>的数据类型才能用作这些映射里的键（值不需要可散列）。</p><p>什么是可散列的？</p><p>如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变的。而且这个对象需要实现<code>__hash__()</code>，还要有<code>__qe__()</code>。如果两个可散列的对象是相等的，散列值一定相等。</p><p>原子不可变数据类型（str、bytes 和数值类型）都是可散列类型，frozenset 也是可散列的，因为根据其定义，frozenset 里只能容纳可散列类型。元组的话，只有当一个元组包含的所有元素都是可散列类型的情况下，它才是可散列的。</p><h5 id="字典构造"><a href="#字典构造" class="headerlink" title="字典构造"></a>字典构造</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = dict(one=<span class="number">1</span>, two=<span class="number">2</span>, three=<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = &#123;<span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>, <span class="string">'three'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = dict(zip([<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = dict([(<span class="string">'two'</span>, <span class="number">2</span>), (<span class="string">'one'</span>, <span class="number">1</span>), (<span class="string">'three'</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = dict(&#123;<span class="string">'three'</span>: <span class="number">3</span>, <span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b == c == d == e</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><h5 id="字典推导"><a href="#字典推导" class="headerlink" title="字典推导"></a>字典推导</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">country_code = &#123;country: code <span class="keyword">for</span> code, country <span class="keyword">in</span> DIAL_CODES&#125;</span><br></pre></td></tr></table></figure><h5 id="用setdefault处理找不到的键"><a href="#用setdefault处理找不到的键" class="headerlink" title="用setdefault处理找不到的键"></a>用setdefault处理找不到的键</h5><p>可以用 <code>d.get(k, default)</code> 来代替 <code>d[k]</code>，给找不到的键一个默认的返回值（这比处理 KeyError 要方便不少）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_dict.setdefault(key, []).append(new_value)</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> my_dict:</span><br><span class="line">my_dict[key] = []</span><br><span class="line">my_dict[key].append(new_value)</span><br></pre></td></tr></table></figure><h5 id="映射的弹性键查询"><a href="#映射的弹性键查询" class="headerlink" title="映射的弹性键查询"></a>映射的弹性键查询</h5><p>有时候为了方便起见，就算某个键在映射里不存在，我们也希望在通过这个键读取值的时候能得到一个默认值。</p><p>一个是通过 defaultdict 这个类型而不是普通的 dict，另一个是给自己定义一个 dict 的子类，然后在子类中实现 <code>__missing__</code> 方法。</p><p>对于defaultdict:</p><p>如 dd = defaultdict(list)，这里将 list 指定为 default_factory，它是defaultdict用来生成默认值的实例属性，需要存放可调用对象。</p><p>这里，若<code>dd[&#39;new_key&#39;]</code>中键 ‘new_key’ 不存在的话，按以下处理：</p><ol><li>调用 list() 来建立一个新列表。</li><li>把这个新列表作为值，’new-key’ 作为它的键，放到 dd 中。</li><li>返回这个列表的引用。</li></ol><p>defaultdict 里的 default_factory 只会在<code>__getitem__</code>里被调用，也就是dd[k]会调用default_factory，而dd.get(k)则会返回None。</p><p>所有这一切背后的功臣其实是特殊方法 <code>__missing__</code>。它会在defaultdict 遇到找不到的键的时候调用 default_factory，而实际上这个特性是所有映射类型都可以选择去支持的。</p><h5 id="特殊方法-missing"><a href="#特殊方法-missing" class="headerlink" title="特殊方法__missing__"></a>特殊方法<code>__missing__</code></h5><p>如果有一个类继承了 dict，然后这个继承类提供了<code>__missing__</code>方法，那么在 <code>__getitem__</code> 碰到找不到的键的时候，Python 就会自动调用它，而不是抛出一个 KeyError 异常。</p><p><code>__missing__</code> 方法只会被 <code>__getitem__</code> 调用（比如在表达式 d[k] 中）</p><h5 id="字典的变种"><a href="#字典的变种" class="headerlink" title="字典的变种"></a>字典的变种</h5><ul><li><p>collections.OrderedDict</p><p>这个类型添加键时会保持顺序，因此键的迭代次序总是一致的。</p></li><li><p>collections.ChainMap</p><p>该类型可容纳数个不同的映射对象，然后查找时，会当作一个整体查找，直到键被找到为止。如Python变量查找规则：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line">pylookup = ChainMap(locals(), globals(), vars(builtins))</span><br></pre></td></tr></table></figure><ul><li><p>collections.Counter</p><p>这个类会给键设置一个整数计数器。更新键时会增加这个计数器，可用来计数。</p></li></ul><h5 id="不可变映射类型"><a href="#不可变映射类型" class="headerlink" title="不可变映射类型"></a>不可变映射类型</h5><p>types 模块中引入了一个封装类名叫MappingProxyType。如果给这个类一个映射，它会返回一个只读的映射视图。虽然是个只读视图，但是它是动态的。这意味着如果对原映射做出了改动，我们通过这个视图可以观察到，但是无法通过这个视图对原映射做出修改。</p><h4 id="集合论"><a href="#集合论" class="headerlink" title="集合论"></a>集合论</h4><p>集合中的元素必须是可散列的，set类型本身是不可散列的，但是frozenset可以。因此可以创建一个包含不同frozenset的set。</p><p>集合中缀表达式： a | b : 并集、 a &amp; b : 交集、a - b : 差集</p><p>如：needles 的元素在 haystack 里出现的次数，两个变量都是 set 类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">found = len(needles &amp; haystack)</span><br></pre></td></tr></table></figure><p>以上代码可以用在任何可迭代对象上：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">found = len(set(needles) &amp; set(haystack))</span><br><span class="line"><span class="comment"># 另一种写法：</span></span><br><span class="line">found = len(set(needles).intersection(haystack))</span><br></pre></td></tr></table></figure><h5 id="集合字面量"><a href="#集合字面量" class="headerlink" title="集合字面量"></a>集合字面量</h5><p>集合字面量 ： {…}，空集：set()</p><p>集合推导 <code>{func(i) for i in iterable}</code></p><h5 id="dict与散列表"><a href="#dict与散列表" class="headerlink" title="dict与散列表"></a>dict与散列表</h5><p>由于字典使用了散列表，而散列表又必须是稀疏的，这导致它在空间上的效率低下。</p><p>用<br>元组取代字典就能节省空间的原因有两个：其一是避免了散列表所耗费的空间，其二是无需把记录中字段的名字在每个元素里都存一遍。</p><h5 id="set与散列表"><a href="#set与散列表" class="headerlink" title="set与散列表"></a>set与散列表</h5><p>set 和 frozenset 的实现也依赖散列表，但在它们的散列表里存放的只有元素的引用（就像在字典里只存放键而没有相应的值）。在 set 加入到 Python 之前，我们都是把字典加上无意义的值当作集合来用的。</p><h3 id="一等函数"><a href="#一等函数" class="headerlink" title="一等函数"></a>一等函数</h3><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>接受函数为参数，或者把函数作为结果返回的函数是高阶函数。</p><h4 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h4><ul><li>用户定义的函数：使用 def 语句或 lambda 表达式创建。</li><li>内置函数：使用 C 语言（CPython）实现的函数，如 len 或 time.strftime。</li><li>内置方法：使用 C 语言实现的方法，如 dict.get。</li><li>方法：在类的定义体中定义的函数。</li><li>类：调用类时会运行类的<code>__new__</code>方法创建一个实例，然后运行<code>__init__</code> 方法，初始化实例，最后把实例返回给调用方。因为 Python没有 new 运算符，所以调用类相当于调用函数。</li><li>类的实例：如果类定义了 <code>__call__</code> 方法，那么它的实例可以作为函数调用。</li><li>生成器函数：使用yield关键字的函数或方法。调用生成器函数返回的是生成器对象。</li></ul><p><code>callable()</code>判断对象是否可以调用。</p><h4 id="从定位参数到仅限关键字参数"><a href="#从定位参数到仅限关键字参数" class="headerlink" title="从定位参数到仅限关键字参数"></a>从定位参数到仅限关键字参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tag</span><span class="params">(name, *content, cls=None, **attrs)</span>:</span></span><br><span class="line">...</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 调用</span></span><br><span class="line">tag(<span class="string">'br'</span>)</span><br><span class="line">tag(<span class="string">'p'</span>,<span class="string">'hello'</span>)</span><br><span class="line">tag(<span class="string">'p'</span>,<span class="string">'hello'</span>,id=<span class="number">33</span>)</span><br><span class="line">tag(<span class="string">'p'</span>,<span class="string">'hello'</span>,<span class="string">'world'</span>,cls=<span class="string">'sidebar'</span>)</span><br><span class="line">tag(content=<span class="string">'testing'</span>,name=<span class="string">'img'</span>)</span><br><span class="line">my_tag = &#123;<span class="string">'name'</span>: <span class="string">'img'</span>, <span class="string">'title'</span>: <span class="string">'Sunset Boulevard'</span>,</span><br><span class="line"><span class="string">'src'</span>: <span class="string">'sunset.jpg'</span>, <span class="string">'cls'</span>: <span class="string">'framed'</span>&#125;</span><br><span class="line">tag(**my_tag)</span><br></pre></td></tr></table></figure><p>以上 cls参数 只能通过关键字指定，它一定不会捕获未命名的定位参数。</p><p>定义函数时若想指定关键字参数，要把它们放到有 <em> 的参数后面。如果不想支持数量不定的定位参数，但想支持仅限关键字参数，在签名中放一个 </em> ，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a,*,b)</span>:</span></span><br><span class="line"><span class="keyword">return</span> a,b</span><br><span class="line">print(f(<span class="number">1</span>,b=<span class="number">2</span>))</span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>注意，仅限关键字参数不一定要有默认值，可以像上例中 b 那样，强制必须传入实参。</p><h4 id="内省：获取关于参数的信息"><a href="#内省：获取关于参数的信息" class="headerlink" title="内省：获取关于参数的信息"></a>内省：获取关于参数的信息</h4><p>与内省有关的函数对象</p><ul><li><code>__defaults__</code>属性，它的值是一个元组，保存着定位参数和关键字参数的默认值。</li><li><code>__kwdefaults__</code>属性，保存仅限关键字参数默认值。</li><li><code>__code__</code>属性，保存参数的名称，它的值是一个code对象的引用，自身也有很多属性。</li></ul><p>相关模块：inspect</p><h4 id="支持函数式编程的包"><a href="#支持函数式编程的包" class="headerlink" title="支持函数式编程的包"></a>支持函数式编程的包</h4><p>operator模块为多个算术运算符提供了对应的函数，从而避免编写平凡的匿名函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> mul</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="keyword">return</span> reduce(mul, range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>operator模块中的itemgetter、attrgetter能从序列中取出元素或读取对象属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> city <span class="keyword">in</span> sorted(metro_data, key=itemgetter(<span class="number">1</span>)):</span><br><span class="line">print(city)</span><br><span class="line"></span><br><span class="line">cc_name = itemgetter(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> city <span class="keyword">in</span> metro_data:</span><br><span class="line">print(cc_name(city))</span><br></pre></td></tr></table></figure><p>itemgetter使用[]运算符，因此它不仅支持序列，还支持映射和任何实现<code>__getitem__</code>方法的类。</p><p>attrgetter 与 itemgetter 作用类似，它创建的函数根据名称提取对象的属性。如果把多个属性名传给 attrgetter，它也会返回提取的值构成的元组。此外，如果参数名中包含 .（点号），attrgetter 会深入嵌套对象，获取指定的属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> attrgetter</span><br><span class="line">name_lat = attrgetter(<span class="string">'name'</span>, <span class="string">'coord.lat'</span>) </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> city <span class="keyword">in</span> sorted(metro_areas, key=attrgetter(<span class="string">'coord.lat'</span>)): </span><br><span class="line">print(name_lat(city))</span><br></pre></td></tr></table></figure><h5 id="functools-partial冻结参数"><a href="#functools-partial冻结参数" class="headerlink" title="functools.partial冻结参数"></a>functools.partial冻结参数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple = partial(mul, <span class="number">3</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>triple(<span class="number">7</span>) </span><br><span class="line"><span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 partial 构建一个便利的 Unicode 规范化函数</span></span><br><span class="line">nfc = functools.partial(unicodedata.normalize, <span class="string">'NFC'</span>)</span><br></pre></td></tr></table></figure><h3 id="使用函数实现设计模式"><a href="#使用函数实现设计模式" class="headerlink" title="使用函数实现设计模式"></a>使用函数实现设计模式</h3><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span> <span class="comment"># 上下文</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, customer, cart, promotion=None)</span>:</span></span><br><span class="line">        self.customer = customer</span><br><span class="line">        self.cart = list(cart)</span><br><span class="line">        self.promotion = promotion</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'__total'</span>):</span><br><span class="line">    self.__total = sum(item.total() <span class="keyword">for</span> item <span class="keyword">in</span> self.cart)</span><br><span class="line">    <span class="keyword">return</span> self.__total</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">due</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> self.promotion <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">    discount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    discount = self.promotion(self) </span><br><span class="line">    <span class="keyword">return</span> self.total() - discount</span><br><span class="line">    </span><br><span class="line">promos = [func <span class="keyword">for</span> name, func <span class="keyword">in</span> inspect.getmembers(promotions, inspect.isfunction)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""选择可用的最佳折扣</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br><span class="line"></span><br><span class="line"><span class="comment"># promotions.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="函数装饰器和闭包"><a href="#函数装饰器和闭包" class="headerlink" title="函数装饰器和闭包"></a>函数装饰器和闭包</h3><p>装饰器是可调用对象，其参数是另一个函数（被装饰的函数）。装饰器可能会处理被装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用的对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">print(<span class="string">'running target()'</span>)</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">print(<span class="string">'running target()'</span>)</span><br><span class="line">target = decorate(target)</span><br></pre></td></tr></table></figure><p>严格来说，装饰器只是语法糖。</p><h4 id="Python在何时执行装饰器？"><a href="#Python在何时执行装饰器？" class="headerlink" title="Python在何时执行装饰器？"></a>Python在何时执行装饰器？</h4><p>函数装饰器在导入模块时<strong>立即执行</strong>，而被装饰的函数只在明确调用时运行。这突出了导入时和运行时的区别。</p><h4 id="使用装饰器改进策略模式"><a href="#使用装饰器改进策略模式" class="headerlink" title="使用装饰器改进策略模式"></a>使用装饰器改进策略模式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">promos = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">promotion</span><span class="params">(promo_func)</span>:</span></span><br><span class="line">    promos.append(promo_func)</span><br><span class="line">    <span class="keyword">return</span> promo_func</span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity_promo</span><span class="params">(order)</span>:</span>  <span class="comment"># 第一个具体策略</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item_promo</span><span class="params">(order)</span>:</span>  <span class="comment"># 第二个具体策略</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_order_promo</span><span class="params">(order)</span>:</span>  <span class="comment"># 第三个具体策略</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span> </span><br><span class="line"><span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br></pre></td></tr></table></figure><h4 id="变量作用域规则"><a href="#变量作用域规则" class="headerlink" title="变量作用域规则"></a>变量作用域规则</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(a)</span>:</span></span><br><span class="line"><span class="meta">... </span>print(a)</span><br><span class="line"><span class="meta">... </span>print(b)</span><br><span class="line"><span class="meta">... </span>b = <span class="number">9</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">UnboundLocalError: local variable <span class="string">'b'</span> referenced before assignment</span><br></pre></td></tr></table></figure><p>Python不要求声明变量，但是假定在函数定义体中的变量是<strong>局部变量</strong>，参数也是。</p><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包是指<strong>延伸了作用域</strong>的函数，其中包含函数定义体中引用、但是<strong>不在定义体</strong>中定义的<strong>非全局变量</strong>。</p><p><a href="https://i.loli.net/2018/10/30/5bd808be8a72b.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/10/30/5bd808be8a72b.png" alt="closure.PNG"></a></p><p>综上，闭包是一种函数，它会保留定义函数时存在的自由变量的绑定。这样调用函数时，虽然定义作用域不可用了，但仍能使用那些绑定。</p><h4 id="nonlocal声明"><a href="#nonlocal声明" class="headerlink" title="nonlocal声明"></a>nonlocal声明</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line">    <span class="keyword">return</span> averager</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = make_averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">UnboundLocalError: local variable <span class="string">'count'</span> referenced before assignment</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> count, total</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        total += new_value</span><br><span class="line">        <span class="keyword">return</span> total / count</span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure><h4 id="实现一个简单的装饰器"><a href="#实现一个简单的装饰器" class="headerlink" title="实现一个简单的装饰器"></a>实现一个简单的装饰器</h4><p>装饰器的典型行为：把被装饰的函数替换成新函数，二者接受相同的参数，而且（通常）返回被装饰函数本该返回的值，同时做些额外的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args)</span>:</span> </span><br><span class="line">        t0 = time.perf_counter()</span><br><span class="line">        result = func(*args) </span><br><span class="line">        elapsed = time.perf_counter() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_str = <span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args)</span><br><span class="line">        print(<span class="string">'[%0.8fs] %s(%s) -&gt; %r'</span> % (elapsed, name, arg_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> clocked</span><br></pre></td></tr></table></figure><p>以上实现的装饰器有缺点：遮盖了被装饰函数的<code>__name__</code>和<code>__doc__</code>属性。</p><p>可使用<code>functools.wraps</code> 装饰器把相关的属性从 func 复制到 clocked 中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        t0 = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        elapsed = time.time() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_lst = []</span><br><span class="line">        <span class="keyword">if</span> args:</span><br><span class="line">        arg_lst.append(<span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args))</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">        pairs = [<span class="string">'%s=%r'</span> % (k, w) <span class="keyword">for</span> k, w <span class="keyword">in</span> sorted(kwargs.items())]</span><br><span class="line">        arg_lst.append(<span class="string">', '</span>.join(pairs))</span><br><span class="line">        arg_str = <span class="string">', '</span>.join(arg_lst)</span><br><span class="line">        print(<span class="string">'[%0.8fs] %s(%s) -&gt; %r '</span> % (elapsed, name, arg_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="comment"># 返回一个被装饰过的函数</span></span><br><span class="line"><span class="keyword">return</span> clocked</span><br></pre></td></tr></table></figure><p>Python 内置了三个用于装饰方法的函数：<code>property</code>、<code>classmethod</code> 和<code>staticmethod</code>。</p><p>另一个常见的装饰器是 <code>functools.wraps</code>，它的作用是协助构建行为<br>良好的装饰器。标准库中最值得关注的两个装饰器是 <code>lru_cache</code> 和全新的 <code>singledispatch</code>。</p><h5 id="functools-lru-cache做备忘"><a href="#functools-lru-cache做备忘" class="headerlink" title="functools.lru_cache做备忘"></a>functools.lru_cache做备忘</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@functools.lru_cache() </span></span><br><span class="line"><span class="meta">@clock </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n<span class="number">-2</span>) + fibonacci(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">$ python3 fibo_demo_lru.py</span><br><span class="line">[0.00000119s] fibonacci(0) -&gt; 0</span><br><span class="line">[0.00000119s] fibonacci(1) -&gt; 1</span><br><span class="line">[0.00010800s] fibonacci(2) -&gt; 1</span><br><span class="line">[0.00000787s] fibonacci(3) -&gt; 2</span><br><span class="line">[0.00016093s] fibonacci(4) -&gt; 3</span><br><span class="line">[0.00001216s] fibonacci(5) -&gt; 5</span><br><span class="line">[0.00025296s] fibonacci(6) -&gt; 8</span><br></pre></td></tr></table></figure><h5 id="functools-singledispatch-装饰器"><a href="#functools-singledispatch-装饰器" class="headerlink" title="functools.singledispatch 装饰器"></a>functools.singledispatch 装饰器</h5><p>它可以把整体方案拆分成多个模块，甚至可以为你无法修改的类提供专门的函数。使用<code>@singledispatch</code>装饰的普通函数会变成泛函数（generic function）：根据第一个参数的类型，以不同方式执行相同操作的一组函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @singledispatch标记处理object类型的基函数</span></span><br><span class="line"><span class="meta">@singledispatch </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">htmlize</span><span class="params">(obj)</span>:</span></span><br><span class="line">    content = html.escape(repr(obj))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;pre&gt;&#123;&#125;&lt;/pre&gt;'</span>.format(content)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmlize.register(str) </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(text)</span>:</span> </span><br><span class="line">    content = html.escape(text).replace(<span class="string">'\n'</span>, <span class="string">'&lt;br&gt;\n'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;p&gt;&#123;0&#125;&lt;/p&gt;'</span>.format(content)</span><br><span class="line"></span><br><span class="line"><span class="meta">@htmlize.register(numbers.Integral) </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;pre&gt;&#123;0&#125; (0x&#123;0:x&#125;)&lt;/pre&gt;'</span>.format(n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 叠放多个register装饰器，让同一个函数支持不同类型</span></span><br><span class="line"><span class="meta">@htmlize.register(tuple) </span></span><br><span class="line"><span class="meta">@htmlize.register(abc.MutableSequence)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(seq)</span>:</span></span><br><span class="line">    inner = <span class="string">'&lt;/li&gt;\n&lt;li&gt;'</span>.join(htmlize(item) <span class="keyword">for</span> item <span class="keyword">in</span> seq)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;ul&gt;\n&lt;li&gt;'</span> + inner + <span class="string">'&lt;/li&gt;\n&lt;/ul&gt;'</span></span><br></pre></td></tr></table></figure><p>以上各个专门函数使用@base_function.register(type)装饰。专门函数的名称无关紧要；使用 _ 简单明了。</p><p>只要可能，注册的专门函数应该处理抽象基类（如 numbers.Integral和 abc.MutableSequence），不要处理具体实现（如 int 和list）。这样，代码支持的兼容类型更广泛。</p><h4 id="参数化装饰器"><a href="#参数化装饰器" class="headerlink" title="参数化装饰器"></a>参数化装饰器</h4><p>怎么让装饰器接受其他参数？</p><p>创建一个装饰器工厂函数，返回装饰器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">registry = set()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(active=True)</span>:</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span> </span><br><span class="line">        print(<span class="string">'running register(active=%s)-&gt;decorate(%s)'</span> % (active, func))</span><br><span class="line">        <span class="keyword">if</span> active: </span><br><span class="line">        registry.add(func)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        registry.discard(func) </span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> decorate</span><br></pre></td></tr></table></figure><h3 id="对象引用、可变性和垃圾回收"><a href="#对象引用、可变性和垃圾回收" class="headerlink" title="对象引用、可变性和垃圾回收"></a>对象引用、可变性和垃圾回收</h3><p>== 运算符比较两个对象的值（对象中保存的数据），而 is 比较对象的标识。</p><h4 id="元组的相对不可变性"><a href="#元组的相对不可变性" class="headerlink" title="元组的相对不可变性"></a>元组的相对不可变性</h4><p>元组与多数Python容器（列表、字典、集）一样，保存的是对象的引用。元组的不可变性其实是指tuple数据结构的物理内容（即保存的引用）不可变，与引用的对象无关。</p><p>元组的相对不变性也是，有些元组不可散列的原因。</p><h4 id="默认做浅复制"><a href="#默认做浅复制" class="headerlink" title="默认做浅复制"></a>默认做浅复制</h4><p>复制列表（或多数内置的可变集合）最简单的方式是使用内置类型的构造方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">3</span>, [<span class="number">55</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = list(l1) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2</span><br><span class="line">[<span class="number">3</span>, [<span class="number">55</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 == l1 </span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 <span class="keyword">is</span> l1 </span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>以上看出，二者指代不同的对象。对列表和其他可变序列来说，还能使用简洁的<code>l2=l1[:]</code>语句来创建副本。</p><p>然而，构造方法或<code>[:]</code>做的是浅复制（即复制了最外层的容器，副本中的元素是源容器中元素的引用）。如果所有的元素都是不可变的，那么这样没问题。但是，如果有可变元素，可能就会导致意想不到的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1 = Bus([<span class="string">'Alice'</span>, <span class="string">'Bill'</span>, <span class="string">'Claire'</span>, <span class="string">'David'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2 = copy.copy(bus1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3 = copy.deepcopy(bus1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(bus1), id(bus2), id(bus3)</span><br><span class="line">(<span class="number">4301498296</span>, <span class="number">4301499416</span>, <span class="number">4301499752</span>) ➊</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus1.drop(<span class="string">'Bill'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus2.passengers</span><br><span class="line">[<span class="string">'Alice'</span>, <span class="string">'Claire'</span>, <span class="string">'David'</span>] ➋</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(bus1.passengers), id(bus2.passengers), id(bus3.passengers)</span><br><span class="line">(<span class="number">4302658568</span>, <span class="number">4302658568</span>, <span class="number">4302657800</span>) ➌</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus3.passengers</span><br><span class="line">[<span class="string">'Alice'</span>, <span class="string">'Bill'</span>, <span class="string">'Claire'</span>, <span class="string">'David'</span>] ➍</span><br></pre></td></tr></table></figure><p>浅复制，不同引用，同一个对象；深复制，不同引用，不同对象。</p><h4 id="函数的参数作为引用时"><a href="#函数的参数作为引用时" class="headerlink" title="函数的参数作为引用时"></a>函数的参数作为引用时</h4><p>Python 唯一支持的参数传递模式是共享传参。共享传参指函数的各个形式参数获得实参中各个引用的副本。也就是说，函数内部的形参是实参的别名。</p><p>Java 的引用类型是这样，基本类型按值传参（函数得到参数的副本）。</p><p>函数可能会修改接收到的任何可变对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b)</span>:</span></span><br><span class="line"><span class="meta">... </span>a += b</span><br><span class="line"><span class="meta">... </span><span class="keyword">return</span> a</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(x, y)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y </span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(a, b)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b </span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = (<span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(t, u)</span><br><span class="line">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t, u </span><br><span class="line">((<span class="number">10</span>, <span class="number">20</span>), (<span class="number">30</span>, <span class="number">40</span>))</span><br></pre></td></tr></table></figure><h4 id="防御可变参数"><a href="#防御可变参数" class="headerlink" title="防御可变参数"></a>防御可变参数</h4><p>不要使用可变类型作为参数的默认值。</p><h4 id="del和垃圾回收"><a href="#del和垃圾回收" class="headerlink" title="del和垃圾回收"></a>del和垃圾回收</h4><p>del 语句删除名称，而不是对象。del 命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时。 重新绑定也可能会导致对象的引用数量归零，导致对象被销毁。</p><h3 id="符合Python风格的对象"><a href="#符合Python风格的对象" class="headerlink" title="符合Python风格的对象"></a>符合Python风格的对象</h3><p>因Python数据模型，自定义类型行为可以像内置类型那样自然。实现如此自然的行为，靠的不是继承，而是鸭子类型（会叫即鸭子）：只需按照预定行为实现对象所需的方法（一般特殊方法）即可。</p><h4 id="classmethod与staticmethod"><a href="#classmethod与staticmethod" class="headerlink" title="classmethod与staticmethod"></a>classmethod与staticmethod</h4><p>classmethod定义操作类，而不是操作实例的方法。classmethod中第一个参数始终是<strong>类本身</strong>。classmethod最常用的用途是定义备选构造方法。staticmethod就是普通函数，只是碰巧在类的定义中。</p><h4 id="格式化显示"><a href="#格式化显示" class="headerlink" title="格式化显示"></a>格式化显示</h4><p><code>&#39;{0.mass:5.3e}&#39;</code> 这样的格式字符串其实包含两部分，冒号左边的 ‘0.mass’ 在代换字段句法中是字段名，冒号后面的 ‘5.3e’ 是格式说明符</p><p>str.format() 格式说明符使用的表示法是格式规范化微语言（formatspec）。</p><p>New in Python3.6</p><p>f-string 真正的运行时计算；双引号</p><p>!r 调用 repr()、!s调用 str()、!a调用ascii()</p><h4 id="Python的私有属性和“受保护的”属性"><a href="#Python的私有属性和“受保护的”属性" class="headerlink" title="Python的私有属性和“受保护的”属性"></a>Python的私有属性和“受保护的”属性</h4><p>为避免子类意外覆盖“私有”属性，以形如<code>__mode</code>的形式（两个前导下划线）命名实例属性，Python会把属性名存入实例的<code>__dict__</code>属性中，而且会在前面加一个下划线和类名，因此有<code>_Class__mode</code>和<code>_Subclass__mode</code>。</p><p>有些Python程序员约定使用一个下划线前缀编写“受保护”的属性（如 self._x）。</p><p>默认情况下，各个实例在名为<code>__dict__</code>的特殊属性中存储实例属性。</p><p><code>__slots__</code>类属性，让解释器在元组中储存实例属性，而不是用字典。这样节省大量内存。在类中定义<code>__slots__</code> 属性的目的是告诉解释器：“这个类中的所有实例属性都在这儿了！”</p><p>仅当权衡当下的需求并仔细搜集资料后证明确实有必要时，才应该使用<code>__slots__</code> 属性。</p><h4 id="覆盖类属性"><a href="#覆盖类属性" class="headerlink" title="覆盖类属性"></a>覆盖类属性</h4><p>Python中：类属性可用于为实例属性提供默认值。</p><p>为不存在的实例属性赋值，会创建新的实例属性。为实例属性赋值后，同名的类属性不受影响。然而自此之后，self.objattr读取的是实例属性objattr，也就把类属性覆盖了。</p><p><strong>在 Python中，我们可以先使用公开属性，然后等需要时再变成特性。</strong></p><h3 id="序列的修改、散列、切片"><a href="#序列的修改、散列、切片" class="headerlink" title="序列的修改、散列、切片"></a>序列的修改、散列、切片</h3><p>序列类型的构造方法应该接受可迭代的对象为参数，因为所有内置的序列类型就是这样做的。</p><h4 id="切片原理"><a href="#切片原理" class="headerlink" title="切片原理"></a>切片原理</h4><p>Python如何把seq[1:3]句法变成传给<code>seq.__getitem__(...)</code>的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">MySeq</span>:</span></span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">return</span> index </span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = MySeq()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>] </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>] </span><br><span class="line">slice(<span class="number">1</span>, <span class="number">4</span>, <span class="keyword">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>] </span><br><span class="line">slice(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>, <span class="number">9</span>] </span><br><span class="line">(slice(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>), <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[<span class="number">1</span>:<span class="number">4</span>:<span class="number">2</span>, <span class="number">7</span>:<span class="number">9</span>] </span><br><span class="line">(slice(<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>), slice(<span class="number">7</span>, <span class="number">9</span>, <span class="keyword">None</span>))</span><br></pre></td></tr></table></figure><p>indices：假设有个长度为 5 的序列，例如 ‘ABCDE’：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>slice(<span class="keyword">None</span>, <span class="number">10</span>, <span class="number">2</span>).indices(<span class="number">5</span>) <span class="comment"># ➊</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>slice(<span class="number">-3</span>, <span class="keyword">None</span>, <span class="keyword">None</span>).indices(<span class="number">5</span>) <span class="comment"># ➋</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>❶ ‘ABCDE’[:10:2] 等同于 ‘ABCDE’[0:5:2]<br>❷ ‘ABCDE’[-3:] 等同于 ‘ABCDE’[2:5:1]</p><p>当没有底层序列类型作为依靠，那么使用此方法能节省大量时间。</p><p>属性查找失败后，解释器会调用<code>__getattr__</code>方法。简单来说，对my_obj.x 表达式，Python 会检查 my_obj 实例有没有名为 x 的属性；如果没有，到类（<code>my_obj.__class__</code>）中查找；如果还没有，顺着继承树继续查找。 如果依旧找不到，调用 my_obj 所属类中定义的<code>__getattr__</code> 方法，传入 self 和属性名称的字符串形式（如 ‘x’）。</p><h5 id="zip函数"><a href="#zip函数" class="headerlink" title="zip函数"></a>zip函数</h5><p>zip函数用于并行迭代两个或多个可迭代对象。当一个可迭代的对象耗尽后，它不发出警告就停止。itertools.zip_longest函数的行为有所不同：使用可选的fillvalue填充缺失的值，直到最长的可迭代对象耗尽。</p><p>为了避免在for循环中手动处理索引变量，还经常使用内置的enumerate生成器函数。</p><h3 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h3><p>抽象基类常见用途：实现接口时作为超类使用。抽象基类如何检查具体子类是否符合接口定义？如何使用注册机制声明一个类实现了某个接口，而不进行子类化操作。最后说明如何让抽象基类自动“识别”任何符合接口的类——不进行子类化或注册。</p><p><strong>Python 是动态语言，因此我们可以在运行时修正一些问题。</strong></p><p>object does not support item assignment 问题：可变的序列还必须提供 <code>__setitem__</code>方法。</p><h4 id="标准库中的抽象基类"><a href="#标准库中的抽象基类" class="headerlink" title="标准库中的抽象基类"></a>标准库中的抽象基类</h4><p>collections.abc中的抽象基类最常用。</p><h4 id="自定义抽象基类"><a href="#自定义抽象基类" class="headerlink" title="自定义抽象基类"></a>自定义抽象基类</h4><p>抽象方法使用@abc.abstractmethod标记，而且定义体中通常只有文档字符串。”是否实现抽象方法”基类检测子类是否符合接口的依据。</p><p>声明抽象基类最简单的方法是继承abc.ABC或其他抽象基类。</p><p>声明抽象类方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyABC</span><span class="params">(abc.ABC)</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">an_abstract_classmethod</span><span class="params">(cls, ...)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>与其他描述符一起使用时，abstractmethod()应放在最里层。</p><h4 id="虚拟子类"><a href="#虚拟子类" class="headerlink" title="虚拟子类"></a>虚拟子类</h4><p>Python新编程风格：使用抽象基类明确声明接口，而且类可以子类化抽象基类或抽象基类注册（无需在继承关系中确立静态的强链接），宣称它实现了某个接口。</p><h3 id="继承的优缺点"><a href="#继承的优缺点" class="headerlink" title="继承的优缺点"></a>继承的优缺点</h3><p>不要子类化内置类型，自定义类应该继承collections模块中的类，例如UserDict、UserList和UserString，它们易于扩展。</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><h4 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h4><p><code>- (__neg__)</code> 、<code>+ (__pos__)</code>、 <code>~(__invert__)</code></p><p>支持一元运算符很简单，只需实现相应的特殊方法。这些特殊方法只有一个参数，self。运算符一个基本规则：始终返回一个新对象。也就是说，不能修改self，要创建并返回合适类型的新实例。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
