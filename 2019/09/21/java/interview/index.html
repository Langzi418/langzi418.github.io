<!DOCTYPE html>
<html lang="zh-Hans">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="知识点总结"/><meta name="keywords" content="Blog" /><link rel="alternate" href="/atom.xml" title="Blog"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="http://yoursite.com/2019/09/21/java/interview/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><link rel="stylesheet" type="text/css" href="/lib/nprogress/nprogress.min.css" /><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":true,"latex":true};
</script>

    <title>知识点总结 - Blog</title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">首页
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">归档
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">关于
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            首页
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            归档
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            标签
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            关于
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">知识点总结
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-09-21
        </span></div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA"><span class="toc-text">JAVA</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础"><span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hashCode-和equals"><span class="toc-text">hashCode()和equals()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO"><span class="toc-text">IO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#容器"><span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap"><span class="toc-text">HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HashMap树化的过程"><span class="toc-text">HashMap树化的过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-text">ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Collections-synchronizedMap-和ConcurrentHashMap区别"><span class="toc-text">Collections.synchronizedMap()和ConcurrentHashMap区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发"><span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile"><span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized"><span class="toc-text">synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁优化"><span class="toc-text">锁优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#重量级锁缺点"><span class="toc-text">重量级锁缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#改进"><span class="toc-text">改进</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java实现原子操作"><span class="toc-text">Java实现原子操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原子类"><span class="toc-text">原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal"><span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS"><span class="toc-text">AQS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock"><span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantReadWriteLock"><span class="toc-text">ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程池"><span class="toc-text">线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Executor"><span class="toc-text">Executor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FixedThreadPool"><span class="toc-text">FixedThreadPool</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SingleThreadExecutor"><span class="toc-text">SingleThreadExecutor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CacheThreadPool"><span class="toc-text">CacheThreadPool</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存模型"><span class="toc-text">内存模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#虚拟机"><span class="toc-text">虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#运行时数据区域"><span class="toc-text">运行时数据区域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#程序计数器"><span class="toc-text">程序计数器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java虚拟机栈"><span class="toc-text">Java虚拟机栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#本地方法栈"><span class="toc-text">本地方法栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java堆"><span class="toc-text">Java堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法区"><span class="toc-text">方法区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#垃圾收集器"><span class="toc-text">垃圾收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial"><span class="toc-text">Serial</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ParNew"><span class="toc-text">ParNew</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-Scavenge"><span class="toc-text">Parallel Scavenge</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Serial-Old"><span class="toc-text">Serial Old</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Parallel-Old"><span class="toc-text">Parallel Old</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CMS（Concurrent-Mark-Sweep）"><span class="toc-text">CMS（Concurrent Mark Sweep）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G1"><span class="toc-text">G1</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内存分配与回收策略"><span class="toc-text">内存分配与回收策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#分代收集算法"><span class="toc-text">分代收集算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Full-GC-amp-Minor-GC"><span class="toc-text">Full GC&amp;Minor GC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载"><span class="toc-text">类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#破坏双亲委派模型"><span class="toc-text">破坏双亲委派模型</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL"><span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础-1"><span class="toc-text">基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#范式"><span class="toc-text">范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引"><span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#B-Tree-B-Tree"><span class="toc-text">B-Tree/B+Tree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#红黑树"><span class="toc-text">红黑树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引的适用条件"><span class="toc-text">索引的适用条件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#联合索引"><span class="toc-text">联合索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#匹配最左列"><span class="toc-text">匹配最左列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高性能索引策略"><span class="toc-text">高性能索引策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#独立的列"><span class="toc-text">独立的列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#前缀索引和索引选择性"><span class="toc-text">前缀索引和索引选择性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多列索引"><span class="toc-text">多列索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#索引列的顺序"><span class="toc-text">索引列的顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#聚簇索引"><span class="toc-text">聚簇索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#覆盖索引"><span class="toc-text">覆盖索引</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事务"><span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ACID"><span class="toc-text">ACID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ACID实现"><span class="toc-text">ACID实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#隔离级别"><span class="toc-text">隔离级别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVCC"><span class="toc-text">MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#版本链"><span class="toc-text">版本链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReadView"><span class="toc-text">ReadView</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#并发方案"><span class="toc-text">并发方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#锁"><span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#锁的粒度"><span class="toc-text">锁的粒度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么场景加表锁"><span class="toc-text">什么场景加表锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#意向锁"><span class="toc-text">意向锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#InnoDB中具体的行锁形式"><span class="toc-text">InnoDB中具体的行锁形式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#insert时的加锁"><span class="toc-text">insert时的加锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存储引擎"><span class="toc-text">存储引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复制"><span class="toc-text">复制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis"><span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型"><span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据结构"><span class="toc-text">数据结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring"><span class="toc-text">Spring</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#网络"><span class="toc-text">网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTPs"><span class="toc-text">HTTPs</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#操作系统"><span class="toc-text">操作系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分布式"><span class="toc-text">分布式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#分布式数据库"><span class="toc-text">分布式数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#负载均衡"><span class="toc-text">负载均衡</span></a></li></ol></li></ol>
    </div>
  </div><div class="post-content"><h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="hashCode-和equals"><a href="#hashCode-和equals" class="headerlink" title="hashCode()和equals()"></a>hashCode()和equals()</h3><p>如果两个对象equals()，那么hashCode()一定相等。（想想散列表）</p>
<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p>IO 阻塞、对每个连接创建一个线程处理</p>
<p>NIO Selector + 一个线程轮询 （Netty）</p>
<p>AIO 线程池异步处理</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>关键代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;  <span class="comment">//定位索引位置</span></span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>良好的Hash算法和扩容机制是的Hash碰撞的概率减少并且哈希桶数组占用的空间少。</p>
<p><code>threshold = length*Load factor</code> 。默认的负载因子0.75是对空间和时间效率的平衡。</p>
<p>HashMap中table的length必须为2的幂（若自定义initial capacity，会指定为大于它的最小2的幂），这样做是为了在<strong>取模和扩容时做优化</strong>。</p>
<p>为了减少冲突，HashMap定位哈希桶索引位置时，加入了高位参与运算。</p>
<p>HashMap中哈希算法：取key的hashCode()值、高位运算、取模运算。</p>
<p>Java8在扩容时的链表部分的优化，Java7是“重新计算索引+头插法”，Java8在重新计算索引时做了优化，计算快。下图中新增的比特可以认为是随机的，则在扩容时，均匀地将冲突地结点分散到新链表。</p>
<p><img src="https://i.loli.net/2019/09/22/gmxNESoPFi1KUJC.jpg" alt=""></p>
<p>多线程时，可能在put、resize后形成环形链表。</p>
<p>链表元素大于等于8，链表转化为树；扩容时若链表元素小于等于6，转化为链表。红黑树的平均查找长度log(n)，链表为n/2。当n&gt;=8时，有转化为树的必要。另外，在6和8之间有7，可以有效避免树和链表的频繁转化。</p>
<p>Reference</p>
<p><a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">java8之重新认识HashMap</a></p>
<p><a href="https://javadoop.com/post/hashmap#toc9" target="_blank" rel="noopener">Java7/8 中的 HashMap 和 ConcurrentHashMap 全解析</a></p>
<h4 id="HashMap树化的过程"><a href="#HashMap树化的过程" class="headerlink" title="HashMap树化的过程"></a>HashMap树化的过程</h4><p>TREEIFY_THRESHOLD = 8</p>
<p>MIN_TREEIFY_CAPACITY = 64</p>
<p>以上两者同时满足时，才树化。</p>
<p><a href="https://blog.csdn.net/fan2012huan/article/details/51088211" target="_blank" rel="noopener">HashMap的扩容及树化过程</a></p>
<p><a href="https://blog.csdn.net/xiao1_1bing/article/details/81870708" target="_blank" rel="noopener">HashMap分析之红黑树树化过程</a></p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>1.7  Segment extends ReentrantLock</p>
<p>1.8 CAS + synchronized</p>
<p>由于已经使用volatile保证了key、value可见性，所以在get时不需要加锁。</p>
<h4 id="Collections-synchronizedMap-和ConcurrentHashMap区别"><a href="#Collections-synchronizedMap-和ConcurrentHashMap区别" class="headerlink" title="Collections.synchronizedMap()和ConcurrentHashMap区别"></a>Collections.synchronizedMap()和ConcurrentHashMap区别</h4><p><a href="https://stackoverflow.com/questions/510632/whats-the-difference-between-concurrenthashmap-and-collections-synchronizedmap" target="_blank" rel="noopener">https://stackoverflow.com/questions/510632/whats-the-difference-between-concurrenthashmap-and-collections-synchronizedmap</a></p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>Lock前缀指令。</p>
<p>1）将当前处理器缓存行的数据写回到系统内存。</p>
<p>2）以上写回内存操作会使其他CPU里缓存了该内存地址的数据无效。</p>
<p>指令重排。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>任何一个对象都有一个monitor与之关联，当monitor被持有后，它将处于锁定状态。</p>
<p>代码同步块：monitorenter时，尝试获取monitor；monitorexit时，释放monitor。</p>
<p>同步方法：有ACC_SYNCHRONIZED标志，进入方法获取monitor，方法结束释放monitor。</p>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><h4 id="重量级锁缺点"><a href="#重量级锁缺点" class="headerlink" title="重量级锁缺点"></a>重量级锁缺点</h4><p>Java的线程是映射到操作系统的原生线程之上的，如果阻塞或唤醒一个线程，都需要操作系统帮忙完成，这就需要从用户态转换到核心态，因此状态转换需要耗费很多的处理器时间。</p>
<h4 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h4><p>自旋锁、偏向锁、轻量级锁</p>
<h3 id="Java实现原子操作"><a href="#Java实现原子操作" class="headerlink" title="Java实现原子操作"></a>Java实现原子操作</h3><p>CAS+自旋、锁</p>
<p>CAS的“ABA”问题：A-&gt;B-&gt;A，那么CAS操作就会认为A没有变过，可以通过控制变量值的版本来保证CAS操作的正确性。JUC中提供了一个带有标记的原子类来解决此问题。但大多数情况下ABA问题并不会影响程序并发的正确性，所以如果需要解决ABA问题，采用传统的互斥同步可能更高效。</p>
<h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>CAS实现，AtomicInteger等可做计数器，更好的实现：LongAdder。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>线程封闭</p>
<p>ThreadLocal提供了get和set等方法，这些方法为每个使用该变量的内存都存有一份独立的副本。</p>
<p>ThreadLocal对象通常用于防止可变的单实例变量（Singleton）或全局变量进行共享。</p>
<p>关键代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadLocal.java</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/09/21/PGjztove9r2kSEg.jpg" alt=""></p>
<p>线程终止后，threadLocals=null。</p>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>原子性地维护同步状态state（由子类重写tryAcquire、tryRelease…）</p>
<p>阻塞和释放线程（LockSupport）</p>
<p><strong>维护阻塞线程的队列</strong>（CLH，双向链表，FIFO）</p>
<p><img src="https://i.loli.net/2019/10/27/R9iVZToqy1pmE6l.png" alt=""></p>
<p><a href="https://www.javadoop.com/post/AbstractQueuedSynchronizer" target="_blank" rel="noopener">一行一行源码分析清楚AbstractQueuedSynchronizer</a></p>
<h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>非公平锁：如果获取锁的线程再次请求，则增加state，成功。可能造成饥饿，但线程切换少，吞吐量大。</p>
<p>公平锁：比非公平锁增加了当前结点是否有前驱结点的判断，若有，则不成功，FIFO。线程切换多。</p>
<h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>高16位读状态（c&gt;&gt;&gt;16)， 低16位写状态（c&amp;((1&lt;&lt;16) -1)）。</p>
<p>写锁：获取时，若读锁已经被获取（读状态不为0）或者当前线程不是已经获取写锁的线程，则等待。</p>
<p>读锁：在没有其他写线程访问时（写状态为0），读锁成功获取。  </p>
<p>如果读锁存在，则写锁不能被获取。原因：若允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他线程就可能无法感知当前写线程的操作。（脏读）</p>
<p>锁降级：锁降级中读锁的获取是必要的。若当前线程不获取读锁而直接释放写锁，假如另一个线程获取写锁并更新数据，那么当前线程可能无法感知数据的更新（<strong>可见性</strong>）。</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>execute执行command分四种情况：</p>
<ol>
<li><p>如果当前运行线程小于corePoolSize，则创建新线程来执行任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = ctl.get();</span><br><span class="line"><span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">    <span class="comment">// addWorker需要获取全局锁</span></span><br><span class="line">    <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    c = ctl.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果运行的线程大于等于corePoolSize，则将任务加入到BlockingQueue。</p>
</li>
<li><p>如果队列已满，再创建新的线程来处理任务（addWorker（command, false））。</p>
</li>
<li><p>如果创建新线程将使当前运行的线程超出maxinumPoolSize，任务将被拒绝，执行饱和策略。</p>
</li>
</ol>
<p>在ThreadPoolExecutor完成预热后（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都执行步骤2，而它不需要获取全局锁。</p>
<p><strong>工作线程</strong>：线程池创建线程时，会将线程封装成Worker，Worker在执行完任务后，还会循环获取BlockingQueue中的Worker来执行。</p>
<p><strong>提交任务</strong>：pool.execute(Runnable);      Future\<object> future = pool.submit(Runnable);</object></p>
<p><strong>关闭线程池</strong>：</p>
<p>shutdown和shutdownNow都会通知线程池不再接受任务，都会立即返回。</p>
<p>区别：showdown仅中断空闲线程，使得BlockingQueue中的线程可以被剩下的线程执行，该方法返回值为void。showdownNow中断所有线程，返回BlockingQueue中的线程列表。</p>
<h3 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h3><p><code>ThreadPoolExecutor(corePoolsize,  maxPoolSize,  keepAliveTime, BlockingQueue)</code></p>
<p>当线程池中的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待任务的最长时间，超时则线程终止。</p>
<h4 id="FixedThreadPool"><a href="#FixedThreadPool" class="headerlink" title="FixedThreadPool"></a>FixedThreadPool</h4><p>使用无界队列LinkedBlockingQueue作为线程池的工作队列（容量Integer.MAX_VALUE）。影响：</p>
<p>1）线程池中的线程数达到coerPoolSize后，新任务将在无界队列中等待，所以线程池中的线程数将不会超过corePoolSize。</p>
<p>适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，它适用于负载比较重的服务器。</p>
<h4 id="SingleThreadExecutor"><a href="#SingleThreadExecutor" class="headerlink" title="SingleThreadExecutor"></a>SingleThreadExecutor</h4><p>LinkedBlockingQueue</p>
<p>corePoolSize=1</p>
<p>适用于需要保证顺序地执行各个任务；并且在任意地时间点不会有多个线程是活动的应用场景。</p>
<h4 id="CacheThreadPool"><a href="#CacheThreadPool" class="headerlink" title="CacheThreadPool"></a>CacheThreadPool</h4><p>SynchronousQueue</p>
<p>corePoolSize=0, maxPoolSize=Integer.MAX_VALUE</p>
<p>如果主线程提交任务的速度高于maxPool中处理任务的速度，它会不断地创建新的线程。</p>
<p>适用于执行很多的短期异步任务小程序，或负载较轻的服务器。</p>
<p>Reference</p>
<p>《Java并发编程实战》</p>
<p>《Java并发编程之美》</p>
<p>《Java并发编程的艺术》</p>
<h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>Java虚拟机规范试图定义一种Java内存模型(JMM)来屏蔽各种硬件和操作系统的内存访问差异。</p>
<p>JMM的目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</p>
<p>Java线程 <-> 工作内存 <-> <strong>JMM</strong> <-> 主内存</-></-></-></p>
<h2 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h2><h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>记录正在执行的虚拟机字节码指令的地址。</p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p>
<p>-Xss 可以指定每个线程的Java虚拟机栈内存大小</p>
<p>异常：</p>
<p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出Stackoverflow异常；</p>
<p>如果虚拟机栈扩展时无法申请到足够的内存，会抛出OOM异常。</p>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>与Java虚拟机栈类似</p>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>几乎所有的对象实例以及数组都要在堆上分配，是垃圾收集器管理的主要区域。</p>
<p>从内存回收的角度来看：堆可分为新生代和老年代</p>
<p>从内存分配的进度来看：堆中可能划分出多个、线程私有的分配缓冲区</p>
<p>-Xms 可以指定堆初始值、-Xmx可以设置最大值</p>
<p>堆不需要物理上连续。若堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OOM异常。</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><p>在单CPU的环境中，serial由于没有线程交互的开销，所以能获得最高的单线程收集效率。</p>
<h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><p>Serial的多线程版本。</p>
<h4 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h4><p>目标是达到一个可控制的吞吐量。这里，吞吐量=运行用户代码的时间/（运行用户代码的时间+垃圾收集的时间）。高吞吐量可以高效地利用CPU时间，尽快完成程序的计算任务，主要适合在后台计算而不需要太多交互的场景。</p>
<p>-XX:MaxGCPauseMills（最大垃圾收集停顿时间） -XX:GCTimeRatio（垃圾收集时间占总时间的比率） </p>
<p>GC时间的缩短是以牺牲吞吐量的和新生代的空间来换取的：系统把新生代的空间调小。</p>
<h4 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h4><p>Serial的老年代版本。</p>
<h4 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h4><p>parallel scavenge的老年代版本。</p>
<h4 id="CMS（Concurrent-Mark-Sweep）"><a href="#CMS（Concurrent-Mark-Sweep）" class="headerlink" title="CMS（Concurrent Mark Sweep）"></a>CMS（Concurrent Mark Sweep）</h4><p>目标是获得最短的回收停顿时间。</p>
<p>4个步骤：</p>
<p>1）初始标记：只标记GC Roots能直接关联到的对象，速度很快，需要停顿；</p>
<p>2）并发标记：GC Roots Tracing的过程；</p>
<p>3）重新标记：修正并发标记期间因用户程序继续运行导致标记产生变动的那一部分对象的标记记录，停顿稍长一些；</p>
<p>4）并发清除。</p>
<p><img src="https://i.loli.net/2019/11/11/HDFZ3Ej62nCBxV4.jpg" alt=""></p>
<p><a href="https://www.cnblogs.com/littleLord/p/5380624.html" target="_blank" rel="noopener">详解CMS垃圾回收机制</a></p>
<h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><p>使用大小相等的独立区域（Region）划分内存以及按优先级来回收内存。</p>
<p>新生代和老年代不再是物理隔离的，它们都是一部分Region（不需要连续）的集合。</p>
<h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>分为新生代和老年代。</p>
<p>新生代：每次垃圾收集时都发现大量的对象死亡，存活率低。可以使用复制算法进行收集，只需要使用少量的复制成本，算法简单，效率高。</p>
<p>老年代：对象存活率高、没有额外空间对它进行分配担保，必须使用“标记——清理”，或者“标记——整理”。</p>
<p>大多数情况下，对象在新生代Eden区中分配。很长的字符串以及数组直接进入老年代。</p>
<h4 id="Full-GC-amp-Minor-GC"><a href="#Full-GC-amp-Minor-GC" class="headerlink" title="Full GC&amp;Minor GC"></a>Full GC&amp;Minor GC</h4><p>young GC：当young gen中的eden区分配满的时候触发。注意young GC中有部分存活对象会晋升到old gen，所以young GC后old gen的占用量通常会有所升高。</p>
<p>full GC：当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发young GC而是转为触发full GC（因为HotSpot VM的GC里，除了CMS的concurrent collection之外，其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先触发一次单独的young GC）；或者，如果有perm gen的话，要在perm gen分配空间但已经没有足够空间时，也要触发一次full GC；或者System.gc()、heap dump带GC，默认也是触发full GC。</p>
<p><a href="https://juejin.im/post/5b8d2a5551882542ba1ddcf8" target="_blank" rel="noopener">JVM 系列文章之 Full GC 和 Minor GC</a></p>
<h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p><a href="https://www.cnblogs.com/fefjay/p/6305499.html" target="_blank" rel="noopener">Java类编译、加载、和执行机制</a></p>
<h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><p>情形一：<strong>受到加载范围的限制</strong>，父类加载器无法加载到用户代码。</p>
<p>解决：设置线程上下文类加载器，可以在父类加载时使用这个加载器去加载所需的用户代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Launcher.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现双亲委派的组合</span></span><br><span class="line">var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line"><span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认将AppClassLoader设置为ContextClassLoader</span></span><br><span class="line">Thread.currentThread().setContextClassLoader(<span class="keyword">this</span>.loader);</span><br></pre></td></tr></table></figure>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><p>where子句指定行的条件，having子句指定组的条件。</p>
<h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p><a href="https://segmentfault.com/a/1190000013695030" target="_blank" rel="noopener">数据库逻辑设计之三大范式通俗理解</a></p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="B-Tree-B-Tree"><a href="#B-Tree-B-Tree" class="headerlink" title="B-Tree/B+Tree"></a>B-Tree/B+Tree</h3><p>m阶B树和B+树的主要区别在于：</p>
<ol>
<li>在B+树中，<strong>叶节点包含信息</strong>，所有非叶节点仅起索引作用，非叶节点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，<strong>不含有</strong>该关键字对应记录的<strong>存储地址</strong>。</li>
<li>B+树中，叶节点包含了<strong>全部关键字</strong>，且相邻叶节点是链接起来的；而在B树中，叶节点包含的关键字和非叶节点包含的关键字<strong>不重复</strong>。</li>
</ol>
<p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式<strong>存储在磁盘</strong>上。这样的话，索引查找过程中就要产生<strong>磁盘I/O消耗</strong>，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的时间复杂度。</p>
<p>数据库系统的设计者巧妙利用了磁盘预读原理，将一个<strong>节点的大小设为等于一个页</strong>，这样<strong>每个节点只需要一次I/O就可以完全载入</strong>。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p>每次新建节点时，直接申请一个页的空间，<strong>这样就保证一个节点物理上也存储在一个页里</strong>，加之计算机存储分配都是按页对齐的，就实现了一个节点只需一次I/O。</p>
<p><strong>B-Tree/B+Tree与红黑树比较</strong></p>
<p>平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。</p>
<p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</p>
<p><strong>B+Tree与B-Tree比较</strong></p>
<p>B+Tree更适合索引，原因和节点出度d有关。d越大索引的性能越好，<strong>而出度的上限取决于节点内key和data的大小</strong>：<br>$$<br>dmax=floor(pagesize/(keysize+datasize+pointsize))<br>$$<br>由于B+Tree内节点<strong>去掉了data域</strong>，因此可以拥有更大的出度，拥有更好的性能。</p>
<p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>保证二叉查找树的平衡性代价太高。</p>
<p>为了保证查找树的平衡性，我们需要一些灵活性，因此可以允许树中的一个节点保存多个键——2-3查找树。</p>
<p>2-3树中将一个4-节点分解为一棵2-3树可能有6种情况。每个变换（分解）都会将4-节点中的中键送入到父节点中，并重构相应的链接而不必涉及树的其他部分。这种局部变换<strong>不会影响树的全局有序性和平衡性</strong>。</p>
<p>红黑二叉查找树背后基本思想是用标准的二叉查找树和一些额外的信息（替换3-节点）来<strong>表示2-3树</strong>。</p>
<p><strong>左斜</strong>红链接表示两个2-节点连接起来构成一个3-节点，黑链接则是2-3树中的普通链接。</p>
<p>满足定义的红黑树与2-3树一一对应。</p>
<p>三种操作：左旋转、右旋转和颜色转换，这三种操作本质上是<strong>将红链接向上传递</strong>。</p>
<p><img src="https://i.loli.net/2019/11/14/VjCeM4JTcZzyrwO.jpg" alt=""></p>
<p>Reference</p>
<p>《算法（第四版）》</p>
<h3 id="索引的适用条件"><a href="#索引的适用条件" class="headerlink" title="索引的适用条件"></a>索引的适用条件</h3><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>多键值B+树</p>
<h4 id="匹配最左列"><a href="#匹配最左列" class="headerlink" title="匹配最左列"></a>匹配最左列</h4><p>最左列相等时，才能继续往下使用索引。    </p>
<p>《MySQL是怎样运行的：从根儿上理解MySQL》</p>
<h3 id="高性能索引策略"><a href="#高性能索引策略" class="headerlink" title="高性能索引策略"></a>高性能索引策略</h3><h4 id="独立的列"><a href="#独立的列" class="headerlink" title="独立的列"></a>独立的列</h4><p>索引不能是表达式的一部分，也不能是函数的参数。</p>
<h4 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h4><p>选择足够长的前缀以保证较高的选择性，同时又不能太长。前缀索引应该足够长，使得前缀索引的选择性<strong>接近于索引整个列</strong>。</p>
<p>一般来说，可以通过计算索引的选择性来确定前缀列的长度。不过，也要考虑数据分布不均匀的情况。</p>
<p>前缀索引的缺点：MySQL不能使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描（后面介绍）。</p>
<p>MySQL不支持后缀索引，可通过逆序存储数据实现“后缀索引”。</p>
<h4 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h4><p>在出现索引合并时，应考虑查询和表的单列索引是否合适。</p>
<h4 id="索引列的顺序"><a href="#索引列的顺序" class="headerlink" title="索引列的顺序"></a>索引列的顺序</h4><p>经验法则：把选择性最高的放在前列。</p>
<h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>是一种<strong>数据存储</strong>方式。InnoDB中聚簇索引是在同一个结构中保存了索引和数据行。InnoDB通过主键聚簇数据。</p>
<p>二级索引保存<strong>主键值</strong>。</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>一个索引包含（覆盖）所需要查询的字段的值。</p>
<p>对于InnoDB，如果二级索引保存的主键值能够覆盖查询，则可以避免对主键索引的二次查询。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>原子性</p>
<p>不可分割，要么全部成功提交，要么全部失败回滚。</p>
<p>一致性</p>
<p>数据库总是从一个一致性状态转换到另一个一致性状态（典型例子：转账时资金的增减）。</p>
<p><strong>隔离性</strong></p>
<p>通常来说，一个事务的修改在最终提交之前，对于其他事物是不可见的。</p>
<p>持久性</p>
<p>一旦事务提交，其所做的修改被永久保存在数据库中。</p>
<h3 id="ACID实现"><a href="#ACID实现" class="headerlink" title="ACID实现"></a>ACID实现</h3><p><a href="https://www.cnblogs.com/rjzheng/p/10841031.html" target="_blank" rel="noopener">Mysql中事务ACID实现原理</a></p>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>Read Uncommit（未提交读）</p>
<p>在事务未提交前，其他事务就可以读。事务可以读取未提交的数据，即脏读。在实际过程中很少使用。</p>
<p>Read Commint（提交读）</p>
<p>事务从开始直到提交之前，所做的修改对其他事务都是不可见的。可以解决脏读。但是，不可重复读。</p>
<p>Repeatable Read（可重复读）</p>
<p>该级别保证同一个事务<strong>多次读取同样记录</strong>的结果是一致的。但可能出现幻读，即某个事务在读取某个范围类的记录时，另外一个事务又在该范围内插入新的记录。</p>
<p><strong>MySQL在REPEATABLE READ隔离级别下，是可以禁止幻读问题的发生的</strong></p>
<p>MySQL默认。</p>
<p>Serializable（可串行化）</p>
<p>在读取的每一行加锁，所以可能导致大量的超时和锁争用的问题。实际也很少使用。</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h3><p>对于InnoDB的存储引擎，它的聚簇索引中都包含了两个必要的隐藏列：</p>
<ul>
<li>trx_id：事务对记录进行修改时，会将事务的id赋值给trx_id。</li>
<li>roll_pointer：事务对记录进行修改时，会将旧版本写入undo日志中，然后这个隐藏列指向undo日志。</li>
</ul>
<p>随着更新次数的增多，所有的版本都会被<code>roll_pointer</code>属性连接成一个<strong>链表</strong>，我们把这个链表称之为<code>版本链</code>，版本链的头节点就是当前记录最新的值。</p>
<h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>对于使用<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的事务来说，核心问题就是：<strong>需要判断一下版本链中的哪个版本是当前事务可见的</strong>。</p>
<p>ReadView中有四个重要内容：</p>
<ul>
<li>m_ids：表示在生成ReadView时，当前系统中活跃的读写事务的id列表。</li>
<li>min_trx_id：m_ids最小值。</li>
<li>max_trx_id：表示在生成ReadView时，应该分配给下一个事务的id值。</li>
<li>creator_trx_id：表示生成该ReadView的事务的id。</li>
</ul>
<blockquote>
<p>只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。</p>
</blockquote>
<p>有了这个<code>ReadView</code>，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：</p>
<ul>
<li>trx_id = creator_trx_id</li>
<li>被访问版本的trx_id &lt; min_trx_id，表明生成该版本的事务在当前事务生成<code>ReadView</code>前已经提交，所以该版本可以被当前事务访问。</li>
<li>被访问版本的trx_id &gt; max_trx_id，表明生成该版本的事务在当前事务生成<code>ReadView</code>后才开启，所以该版本不可以被当前事务访问。    </li>
<li>被访问版本的<code>trx_id</code>属性值在<code>min_trx_id</code>和<code>max_trx_id</code>之间，那就需要判断一下<code>trx_id</code>属性值是不是在<code>m_ids</code>列表中，如果在，说明创建<code>ReadView</code>时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建<code>ReadView</code>时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ul>
<p>MVCC指的就是在使用<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两种隔离级别的事务在执行普通的<code>SEELCT</code>操作时<strong>访问记录的版本链的过程</strong>，这样子可以使不同事务的<code>读-写</code>、<code>写-读</code>操作并发执行，从而提升系统性能。<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两个隔离级别的一个很大不同就是：生成ReadView的时机不同，READ COMMITTD在<strong>每一次进行普通SELECT操作前都会生成一个ReadView</strong>，而REPEATABLE READ只在<strong>第一次进行普通SELECT操作前生成一个ReadView</strong>，之后的查询操作都重复使用这个ReadView就好了。</p>
<h3 id="并发方案"><a href="#并发方案" class="headerlink" title="并发方案"></a>并发方案</h3><p>方案一：读操作利用多版本并发控制（<code>MVCC</code>），写操作进行<code>加锁</code>。</p>
<p>方案二：读、写操作都采用<code>加锁</code>的方式。</p>
<p>如果我们的一些业务场景不允许读取记录的旧版本，而是每次都必须去读取记录的最新版本，比方在银行存款的事务中。</p>
<p>采用<code>MVCC</code>方式的话，<code>读-写</code>操作彼此并不冲突，性能更高，采用<code>加锁</code>方式的话，<code>读-写</code>操作彼此需要排队执行，影响性能。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>共享锁（S锁）</p>
<p>排他锁（X锁）</p>
<h3 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h3><p>表级锁、 行级锁</p>
<h4 id="什么场景加表锁"><a href="#什么场景加表锁" class="headerlink" title="什么场景加表锁"></a>什么场景加表锁</h4><ol>
<li>全表更新。事务需要更新大部分数据，且表较大。若使用行锁，会导致事务执行效率低，从而可能造成其他事务长时间锁等待和更多的锁冲突。</li>
<li>多表查询。事务涉及多个表，比较复杂的关联查询，很可能引起死锁，造成大量事务回滚。这种情况若能一次性锁定事务涉及的表，从而可以避免死锁、减少数据库因事务回滚带来的开销。</li>
</ol>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><ul>
<li>意向共享锁，英文名：<code>Intention Shared Lock</code>，简称<code>IS锁</code>。当事务准备在某条记录上加<code>S锁</code>时，需要先在表级别加一个<code>IS锁</code>。</li>
<li>意向独占锁，英文名：<code>Intention Exclusive Lock</code>，简称<code>IX锁</code>。当事务准备在某条记录上加<code>X锁</code>时，需要先在表级别加一个<code>IX锁</code>。</li>
</ul>
<p>IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以<strong>快速判断表中的记录是否被上锁</strong>，以<strong>避免用遍历的方式来查看表中有没有上锁的记录</strong>，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是兼容的。</p>
<h4 id="InnoDB中具体的行锁形式"><a href="#InnoDB中具体的行锁形式" class="headerlink" title="InnoDB中具体的行锁形式"></a>InnoDB中具体的行锁形式</h4><p>Record Lock：单个记录</p>
<p>GAP：间隙锁（看SQL语句），解决幻读</p>
<p>Next-Key：Record + GAP</p>
<h4 id="insert时的加锁"><a href="#insert时的加锁" class="headerlink" title="insert时的加锁"></a>insert时的加锁</h4><p>我们前边说一个事务在执行<code>INSERT</code>操作时，如果即将插入的<code>间隙</code>已经被其他事务加了<code>gap锁</code>，那么本次<code>INSERT</code>操作会阻塞，并且当前事务会在该间隙上加一个<code>插入意向锁</code>，否则一般情况下<code>INSERT</code>操作是不加锁的。</p>
<p>别的事务在对这条记录加<code>S锁</code>或者<code>X锁</code>时，由于<code>隐式锁</code>的存在，会先帮助当前事务生成一个锁结构，然后自己再生成一个锁结构后进入等待状态。</p>
<p>Reference</p>
<p>《MySQL是怎样运行的：从根儿上理解MySQL》</p>
<p><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">Innodb中的事务隔离级别和锁的关系</a></p>
<p><a href="https://juejin.im/post/5b82e0196fb9a019f47d1823" target="_blank" rel="noopener">全面了解mysql锁机制（InnoDB）与问题排查</a></p>
<p><a href="https://www.aneasystone.com/archives/2017/12/solving-dead-locks-three.html" target="_blank" rel="noopener">解决死锁之路 - 常见 SQL 语句的加锁分析</a></p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>InnoDB和MyISAM区别</p>
<ul>
<li>是否支持行级锁：MyISAM只有表级锁，而InnoDB支持行级锁和表级锁，默认行级锁。</li>
<li>是否支持事务和崩溃后的安全恢复：MyISAM不支持事务，InnoDB支持事务，崩溃恢复能力好。</li>
<li>是否支持外键：MyISAM不支持，InnoDB支持。</li>
<li>是否支持MVCC：仅InnoDB支持。</li>
</ul>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>MySQL主从复制的过程概述</p>
<ol>
<li>在主库上把数据更改记录到二进制日志（binlog）中（这些记录被称为二进制事件）。</li>
<li>备库将主库上的日志复制到自己的中继日志（relay log）中。</li>
<li>备库读取中继日志中的事件，将其重放到备库数据之上。</li>
</ol>
<p>基于行和基于语句的复制。</p>
<p><a href="https://www.cnblogs.com/ivictor/p/5735580.html" target="_blank" rel="noopener">MySQL半同步复制</a></p>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><a href="https://redis.io/topics/data-types" target="_blank" rel="noopener">https://redis.io/topics/data-types</a></p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ol>
<li>string：类似于Java的ArrayList，采用预分配冗余空间来减少内存的频繁分配。</li>
<li>list：将多个ziplist使用双向指针串起来使用。</li>
<li>hash：类似于Java的HashMap数组加链表，特别之处是渐进式rehash()。</li>
<li>set：类似于Java的HashSet。</li>
<li>zset：一个hash字典加一个跳跃列表。</li>
</ol>
<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><p><a href="https://juejin.im/post/5cf7ca6d6fb9a07ef71062d7" target="_blank" rel="noopener">15个经典的Spring面试常见问题</a></p>
<p><a href="https://javadoop.com/" target="_blank" rel="noopener">Javadoop</a></p>
<p><a href="https://sylvanassun.github.io/2018/01/08/2018-01-08-spring_boot_auto_configure/" target="_blank" rel="noopener">Spring Boot自动配置的”魔法”是如何实现的？</a></p>
<p><a href="https://blog.csdn.net/icarus_wang/article/details/51649635" target="_blank" rel="noopener">Spring学习（二十二） Bean配置的三种方式（XML、注解、Java类）介绍与对比</a></p>
<p><a href="https://www.cnblogs.com/zrtqsk/p/3735273.html" target="_blank" rel="noopener">Spring Bean的生命周期（非常详细）</a></p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="HTTPs"><a href="#HTTPs" class="headerlink" title="HTTPs"></a>HTTPs</h2><p><a href="https://segmentfault.com/a/1190000011675421" target="_blank" rel="noopener">HTTPS详解</a></p>
<p><a href="https://github.com/wolverinn/Waking-Up/" target="_blank" rel="noopener">https://github.com/wolverinn/Waking-Up/</a></p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><p><a href="https://www.cnblogs.com/anker/p/3271773.html" target="_blank" rel="noopener">孤儿进程与僵尸进程总结</a></p>
<h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><h2 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h2><p><a href="https://juejin.im/post/5d495ad2e51d4561a54b6954" target="_blank" rel="noopener">在「不可靠」硬件上，分布式数据库如何保证数据可靠性和服务可用性？</a></p>
<h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p><a href="https://www.jianshu.com/p/fc268327d299" target="_blank" rel="noopener">分布式架构实践——负载均衡</a></p>

      </div>
      
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/java/">java</a>
            <a href="/tags/object-Object/">[object Object]</a>
            </div>
        
        <nav class="post-nav"><a class="next" href="/2019/08/21/algorithm/algorithm/">
        <span class="next-text nav-default">Algorithm Note</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:xu.io@qq.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/Langzi418" class="iconfont icon-github" title="github"></a>
        </div><div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2018 - 2020<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Singular</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/lib/pjax/jquery.pjax.min.js"></script>
  <script type="text/javascript" src="/lib/nprogress/nprogress.min.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
