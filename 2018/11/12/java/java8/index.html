<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=DejaVu Sans Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="java," />










<meta name="description" content="行为参数化  行为参数化，就是一个方法接受多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力。 行为参数化让代码更好地适应不断变化的要求，减轻未来的工作量。 传递代码，就是将新行为作为参数传递给方法。Java API中包括排序、线程和GUI处理。">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java8 Learn">
<meta property="og:url" content="http://yoursite.com/2018/11/12/java/java8/index.html">
<meta property="og:site_name" content="Peng&#39;S">
<meta property="og:description" content="行为参数化  行为参数化，就是一个方法接受多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力。 行为参数化让代码更好地适应不断变化的要求，减轻未来的工作量。 传递代码，就是将新行为作为参数传递给方法。Java API中包括排序、线程和GUI处理。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://i.loli.net/2018/11/06/5be0f72e8cebf.png">
<meta property="og:image" content="https://i.loli.net/2018/11/09/5be538c6a377b.png">
<meta property="og:image" content="https://i.loli.net/2018/11/06/5be14723ab807.png">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005wR1ytgy1fx53bfox7aj30wg0cqmyx.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005wR1ytgy1fx53bfsibxj30v00tdn2l.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005wR1ytgy1fx54gljrqpj30ua08rdg5.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005wR1ytgy1fx5b99awl1j30t60b3mym.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005wR1ytgy1fx5deji7d2j30q90ao0um.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/005wR1ytgy1fx5drh2b6uj30u608k3zg.jpg">
<meta property="og:updated_time" content="2018-11-12T11:35:26.521Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java8 Learn">
<meta name="twitter:description" content="行为参数化  行为参数化，就是一个方法接受多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力。 行为参数化让代码更好地适应不断变化的要求，减轻未来的工作量。 传递代码，就是将新行为作为参数传递给方法。Java API中包括排序、线程和GUI处理。">
<meta name="twitter:image" content="https://i.loli.net/2018/11/06/5be0f72e8cebf.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/11/12/java/java8/"/>





  <title>Java8 Learn | Peng'S</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Peng'S</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/12/java/java8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Peng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Peng'S">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java8 Learn</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-12T19:35:43+08:00">
                2018-11-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>行为参数化</p>
<ul>
<li>行为参数化，就是一个方法接受多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力。</li>
<li>行为参数化让代码更好地适应不断变化的要求，减轻未来的工作量。</li>
<li>传递代码，就是将新行为作为参数传递给方法。Java API中包括排序、线程和GUI处理。</li>
</ul>
<a id="more"></a>
<h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p><strong>在哪里使用Lambda?</strong></p>
<h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>函数式接口即只定义一个抽象方法的接口。</p>
<p><strong>Lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例（具体说来，是函数式接口一个具体实现的实例）。</strong></p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BufferedReaderProcessor</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">process</span><span class="params">(BufferedReader b)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">processFile</span><span class="params">(BufferedReaderProcessor p)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedReader br =</span><br><span class="line">                     <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"data.txt"</span>))) &#123;</span><br><span class="line">            <span class="keyword">return</span> p.process(br);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String oneLine = processFile((BufferedReader br) -&gt; br.readLine());</span><br><span class="line">        <span class="comment">// String oneLine = processFile(BufferedReader::readLine);</span></span><br><span class="line">        String twoLines = processFile(</span><br><span class="line">                (BufferedReader br) -&gt; br.readLine() + br.readLine());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用函数式接口"><a href="#使用函数式接口" class="headerlink" title="使用函数式接口"></a>使用函数式接口</h4><p>函数式接口很有用，因为抽象方法的签名可以描述Lambda表达式的签名。函数式接口的抽象方法的签名称为函数描述符。</p>
<p>Java API中已经有了几个函数式接口，比如 Comparable 、 Runnable 和Callable 。</p>
<p>Java 8 中有Predicate 、 Consumer 和 Function。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Predicate&lt;String&gt; nonEmptyStringPredicate = (String s) -&gt; !s.isEmpty();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(List&lt;T&gt; list, Consumer&lt;T&gt; c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(T i: list)&#123;</span><br><span class="line">    	c.accept(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">forEach(</span><br><span class="line">    Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>),(Integer i) -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, R&gt; <span class="function">List&lt;R&gt; <span class="title">map</span><span class="params">(List&lt;T&gt; list,Function&lt;T, R&gt; f)</span></span>&#123;</span><br><span class="line">List&lt;R&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(T s: list)&#123;</span><br><span class="line">    	result.add(f.apply(s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [7, 2, 6]</span></span><br><span class="line">List&lt;Integer&gt; l = map(Arrays.asList(<span class="string">"lambdas"</span>,<span class="string">"in"</span>,<span class="string">"action"</span>),(String s) -&gt; s.length());</span><br></pre></td></tr></table></figure>
<h4 id="原始类型特化"><a href="#原始类型特化" class="headerlink" title="原始类型特化"></a>原始类型特化</h4><p>比如，在下面的代码中，使用 IntPredicate 就避免了对值 1000 进行装箱操作，但要是用 <code>Predicate&lt;Integer&gt;</code> 就会把参数 1000 装箱到一个 Integer 对象中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntPredicate</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">IntPredicate evenNumbers = (<span class="keyword">int</span> i) -&gt; i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">evenNumbers.test(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">Predicate&lt;Integer&gt; oddNumbers = (Integer i) -&gt; i % <span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line">oddNumbers.test(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2018/11/06/5be0f72e8cebf.png" alt="funinter.PNG"></p>
<p><img src="https://i.loli.net/2018/11/09/5be538c6a377b.png" alt="funinter2.png"></p>
<p>因函数式接口都不允许抛出受检异常。如果需要Lambda表达式抛出异常，有两种方法：定义一个自己的函数式接口，并声明受检异常，或把Lambda包在一个try/catch块中。</p>
<h3 id="类型检查、类型推断以及限制"><a href="#类型检查、类型推断以及限制" class="headerlink" title="类型检查、类型推断以及限制"></a>类型检查、类型推断以及限制</h3><h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><p>Java编译器会从上下文（<strong>目标类型</strong>）推断出用什么函数式接口来配合Lambda表达式，这意味着它也可以推断出适合Lambda的签名，因为函数描述符可以通过目标类型来得到。这样做的好处在于，编译器可以了解Lambda表达式的参数类型，这样就可以在Lambda语法中<strong>省去标注</strong>参数类型。</p>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>可以视为某些Lambda的快捷写法。可以重复使用现有的方法定义，并像Lambda一样传递它们。</p>
<p>如果一个Lambda表达式只是“直接调用这个方法”，那最好还是用名称来调用它，而不是去描述如何调用它。</p>
<h3 id="复合Lambda表达式的有用方法"><a href="#复合Lambda表达式的有用方法" class="headerlink" title="复合Lambda表达式的有用方法"></a>复合Lambda表达式的有用方法</h3><h4 id="比较器复合"><a href="#比较器复合" class="headerlink" title="比较器复合"></a>比较器复合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort(comparing(Apple::getWeight).reversed());</span><br></pre></td></tr></table></figure>
<h4 id="比较器链"><a href="#比较器链" class="headerlink" title="比较器链"></a>比较器链</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inventory.sort(comparing(Apple::getWeight)</span><br><span class="line">    .reversed()</span><br><span class="line">    .thenComparing(Apple::getCountry));</span><br></pre></td></tr></table></figure>
<h4 id="谓词复合"><a href="#谓词复合" class="headerlink" title="谓词复合"></a>谓词复合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;Apple&gt; redAndHeavyAppleOrGreen =</span><br><span class="line">    redApple.and(a -&gt; a.getWeight() &gt; <span class="number">150</span>)</span><br><span class="line">    .or(a -&gt; <span class="string">"green"</span>.equals(a.getColor()));</span><br></pre></td></tr></table></figure>
<h4 id="函数复合"><a href="#函数复合" class="headerlink" title="函数复合"></a>函数复合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; f = x -&gt; x + <span class="number">1</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; g = x -&gt; x * <span class="number">2</span>;</span><br><span class="line">Function&lt;Integer, Integer&gt; h = f.andThen(g);</span><br><span class="line"><span class="keyword">int</span> result = h.apply(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>它允许以声明性方式处理数据集合（通过查询语句来表达，而不是临时编写一个实现）。 </p>
<p><strong>只能遍历一次。</strong></p>
<h4 id="内部迭代与外部迭代"><a href="#内部迭代与外部迭代" class="headerlink" title="内部迭代与外部迭代"></a>内部迭代与外部迭代</h4><p>Java Collection外部迭代，Stream内部迭代。</p>
<p>内部迭代优点：可以透明地并行处理， 或者用更优化的顺序进行处理。</p>
<h4 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h4><p>诸如 filter 或 sorted 等中间操作会返回另一个流。这让多个操作可以连接起来形成一个查询。重要的是，除非流水线上触发一个终端操作，否则中间操作不会执行任何处理——它们很懒。</p>
<h4 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h4><p>终端操作会从流的流水线生成结果。其结果是任何不是流的值，比如 List 、 Integer ，甚至 void 。</p>
<h4 id="使用流"><a href="#使用流" class="headerlink" title="使用流"></a>使用流</h4><p>三件事：一数据源、二中间操作链、三终端操作。</p>
<p>流的流水线理念类似于构建器模式。</p>
<p><img src="https://i.loli.net/2018/11/06/5be14723ab807.png" alt="stream.PNG"></p>
<h3 id="筛选和切片"><a href="#筛选和切片" class="headerlink" title="筛选和切片"></a>筛选和切片</h3><h4 id="用谓词筛选"><a href="#用谓词筛选" class="headerlink" title="用谓词筛选"></a>用谓词筛选</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dish&gt; vegetarianMenu = menu.stream()</span><br><span class="line">	.filter(Dish::isVegetarian)</span><br><span class="line">	.collect(toList());</span><br></pre></td></tr></table></figure>
<p>流还支持一个叫作 distinct 的方法，它会返回一个元素各异（根据流所生成元素的hashCode 和 equals 方法实现）的流。</p>
<h4 id="截短流"><a href="#截短流" class="headerlink" title="截短流"></a>截短流</h4><p>流支持 limit(n) 方法，该方法会返回一个不超过给定长度的流。</p>
<h4 id="跳过元素"><a href="#跳过元素" class="headerlink" title="跳过元素"></a>跳过元素</h4><p>流还支持 skip(n) 方法，返回一个扔掉了前 n 个元素的流。</p>
<h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><h4 id="流的扁平化"><a href="#流的扁平化" class="headerlink" title="流的扁平化"></a>流的扁平化</h4><p> Arrays.stream() 的方法可以接受一个数组并产生一个流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; uniqueCharacters =</span><br><span class="line">    words.stream()</span><br><span class="line">    .map(w -&gt; w.split(<span class="string">""</span>))</span><br><span class="line">    .flatMap(Arrays::stream)</span><br><span class="line">    .distinct()</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p>flatMap合并为一个流。</p>
<h4 id="查找和匹配"><a href="#查找和匹配" class="headerlink" title="查找和匹配"></a>查找和匹配</h4><p>allMatch、anyMatch、noneMatch、findFirst、findAny</p>
<h5 id="短路求值"><a href="#短路求值" class="headerlink" title="短路求值"></a>短路求值</h5><p>对于流而言，某些操作（例如 allMatch 、 anyMatch 、 noneMatch 、 findFirst 和 findAny ）不用处理整个流就能得到结果。只要找到一个元素，就可以有结果了。同样， limit 也是一个短路操作：它只需要创建一个给定大小的流，而用不着处理流中所有的元素。在碰到无限大小的流的时候，这种操作就有用了：它们可以把无限流变成有限流。</p>
<h4 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h4><h5 id="算术"><a href="#算术" class="headerlink" title="算术"></a>算术</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = numbers.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a + b);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = numbers.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure>
<h5 id="最值"><a href="#最值" class="headerlink" title="最值"></a>最值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; max = numbers.stream().reduce(Integer::max);</span><br></pre></td></tr></table></figure>
<h4 id="原始类型流特化"><a href="#原始类型流特化" class="headerlink" title="原始类型流特化"></a>原始类型流特化</h4><p>IntStream、DoubleStream、LongStream，分别将流中的元素特化为int、long和double，从而避免了暗含的装箱成本。还带来了进行常用数值归约的新方法，如sum、max。</p>
<p> IntStream 还支持其他的方便方法，如max 、 min 、 average 等。</p>
<h5 id="映射到数值流"><a href="#映射到数值流" class="headerlink" title="映射到数值流"></a>映射到数值流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> calories = menu.stream()</span><br><span class="line">    .mapToInt(Dish::getCalories)</span><br><span class="line">    .sum();</span><br></pre></td></tr></table></figure>
<h5 id="转换回对象流"><a href="#转换回对象流" class="headerlink" title="转换回对象流"></a>转换回对象流</h5><p>IntStream 上的操作只能产生原始整数： IntStream 的 map 操作接受的Lambda必须接受 int 并返回 int。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = intStream.boxed();</span><br></pre></td></tr></table></figure>
<h5 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h5><p>Java 8引入了两个可以用于 IntStream 和 LongStream 的静态方法，帮助生成这种范围：range 和 rangeClosed 。这两个方法都是第一个参数受起始值，第二个参数接受结束值。但range 是不包含结束值的，而 rangeClosed 则包含结束值。</p>
<h3 id="构建流"><a href="#构建流" class="headerlink" title="构建流"></a>构建流</h3><h4 id="由值创建流"><a href="#由值创建流" class="headerlink" title="由值创建流"></a>由值创建流</h4><p>静态方法Stream.of，通过显示值创建流。可接受任意数量的参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Java 8 "</span>, <span class="string">"Lambdas "</span>, <span class="string">"In "</span>, <span class="string">"Action"</span>);</span><br></pre></td></tr></table></figure>
<p>可使用empty得到一个空流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; emptyStream = Stream.empty();</span><br></pre></td></tr></table></figure>
<h4 id="由数组创建流"><a href="#由数组创建流" class="headerlink" title="由数组创建流"></a>由数组创建流</h4><p>Arrays.stream接受数组作为参数，例如，可将一个原始类型int转换成IntStream。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] numbers = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = Arrays.stream(numbers).sum();</span><br></pre></td></tr></table></figure>
<h4 id="由文件生成流"><a href="#由文件生成流" class="headerlink" title="由文件生成流"></a>由文件生成流</h4><p>Java NIO（非阻塞IO）</p>
<h4 id="由函数生成流：创建无限流"><a href="#由函数生成流：创建无限流" class="headerlink" title="由函数生成流：创建无限流"></a>由函数生成流：创建无限流</h4><p>Stream API提供了两个静态方法来从函数生成流： Stream.iterate 和 Stream.generate 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>)</span><br><span class="line">    .limit(<span class="number">10</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>都是按需生成，但generate不是依次对每个新生成的值应用函数。它接受一个<code>Supplier&lt;T&gt;</code>类型的Lambda提供新的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(Math::random)</span><br><span class="line">    .limit(<span class="number">5</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h3 id="用流-lt-收集-gt-数据"><a href="#用流-lt-收集-gt-数据" class="headerlink" title="用流&lt;收集&gt;数据"></a>用流&lt;收集&gt;数据</h3><p>函数式编程相对于指令式编程一个主要的优势：只需指出希望的结果——“做什么”，而不用操心执行的步骤——“如何做”。</p>
<h4 id="预定义收集器"><a href="#预定义收集器" class="headerlink" title="预定义收集器"></a>预定义收集器</h4><p>三大功能：</p>
<ul>
<li>将流元素归约和汇总为一个值</li>
<li>元素分组</li>
<li>元素分区</li>
</ul>
<h4 id="归约和汇总"><a href="#归约和汇总" class="headerlink" title="归约和汇总"></a>归约和汇总</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> howManyDishes = menu.stream().count()；</span><br><span class="line"><span class="keyword">int</span> howManyDishes = menu.size();</span><br></pre></td></tr></table></figure>
<h5 id="查找流中的最大值和最小值"><a href="#查找流中的最大值和最小值" class="headerlink" title="查找流中的最大值和最小值"></a>查找流中的最大值和最小值</h5><p>Collectors.maxBy 和Collectors.minBy ，用来计算流中的最大或最小值。这两个收集器接收一个 Comparator 参数来比较流中的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Dish&gt; dishCaloriesComparator =</span><br><span class="line">	Comparator.comparingInt(Dish::getCalories);</span><br><span class="line"></span><br><span class="line">Optional&lt;Dish&gt; mostCalorieDish =</span><br><span class="line">    menu.stream()</span><br><span class="line">    .collect(maxBy(dishCaloriesComparator));</span><br><span class="line"></span><br><span class="line">Optional&lt;Dish&gt; mostCalorieDish =</span><br><span class="line">                menu.stream()</span><br><span class="line">                        .max(dishCaloriesComp);</span><br></pre></td></tr></table></figure>
<h5 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求和</span></span><br><span class="line"><span class="keyword">int</span> totalCalories =</span><br><span class="line">	menu.stream().collect(summingInt(Dish::getCalories));</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> totalCalories =</span><br><span class="line">                menu.stream()</span><br><span class="line">                        .mapToInt(Dish::getCalories).sum();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求平均值</span></span><br><span class="line"><span class="keyword">double</span> avgCalories =</span><br><span class="line">	menu.stream().collect(averagingInt(Dish::getCalories));</span><br><span class="line"></span><br><span class="line">OptionalDouble avgCalories2 =</span><br><span class="line">                menu.stream()</span><br><span class="line">                        .mapToDouble(Dish::getCalories)</span><br><span class="line">                        .average();</span><br></pre></td></tr></table></figure>
<p>有时候，我们可能希望得到两个或更多这样的结果，而且只需要一次操作就可以完成。此时，可以使用summarizingInt工厂方法返回收集器。例如，通过一次summarinzing操作，即可得到菜肴热量的总和、平均值、最大值、最小值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics menuStatistics =</span><br><span class="line">	menu.stream().collect(summarizingInt(Dish::getCalories));</span><br></pre></td></tr></table></figure>
<p>收集到一个IntSummaryStatisics中，它提供了一个取值方法来访问结果。</p>
<h5 id="连接字符串"><a href="#连接字符串" class="headerlink" title="连接字符串"></a>连接字符串</h5><p>joining工厂方法返回一个收集器会把对流中的每一个对象应用toString方法得到的字符串连接成一个字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String shortMeu = menu.stream().map(Dish::getName).collect(joining());</span><br></pre></td></tr></table></figure>
<p>joining内部使用StringBuilder。如果Dish类有一个toString方法来返回菜肴的名称，那无需用提取每一道菜名称的函数来对原流做映射，就能得到相同的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String shortMenu = menu.stream().collect(joining());</span><br></pre></td></tr></table></figure>
<p>joining()工厂方法有一个重载版本，可接受分界符，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String shortMenu = 		menu.stream().map(Dish::getName).collect(joining(<span class="string">", "</span>));</span><br></pre></td></tr></table></figure>
<h4 id="广义的归约汇总"><a href="#广义的归约汇总" class="headerlink" title="广义的归约汇总"></a>广义的归约汇总</h4><p>以上所有的收集器，都可以用reducing方法定义归约过程。以上方法只是方便程序员而已。</p>
<p><strong>collect与reduce</strong>: collect()适合表达可变容器上的归约，更关键的是它适合并行操作。</p>
<p><strong>根据情况选择最佳方案</strong></p>
<h4 id="以下开始发挥collect的作用"><a href="#以下开始发挥collect的作用" class="headerlink" title="以下开始发挥collect的作用"></a>以下开始发挥collect的作用</h4><h5 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h5><p><code>Collections.groupingBy(Function)</code></p>
<p>Function称为分类函数。分组操作的结果是一个Map。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, List&lt;Dish&gt;&gt; dishesByType =</span><br><span class="line">	menu.stream().collect(groupingBy(Dish::getType));</span><br></pre></td></tr></table></figure>
<p>可用Lambda编写复杂的分类函数。</p>
<p><code>Collections.groupingBy(Function,Collector)</code></p>
<p>接受collector类型的第二个参数，进行二级分组。可把一个内层的groupingBy传递给外层的groupingBy，作为二级分类标准。</p>
<p>这里的collector可以是任意类型，例如counting()，maxBy()。</p>
<p><code>maxBy(Comparator)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Optional&lt;Dish&gt;&gt; mostCaloricByType =</span><br><span class="line">    menu.stream()</span><br><span class="line">    .collect(groupingBy(Dish::getType,</span><br><span class="line">    	maxBy(comparingInt(Dish::getCalories))));</span><br></pre></td></tr></table></figure>
<p> groupingBy 收集器只有在应用分组条件后，第一次在流中找到某个键对应的元素时才会把键加入分组 Map 中。这意味着 Optional 包装器在这里不是很有用。</p>
<p>把收集器返回的结果转换为另一种类型，你可以使用Collectors.collectingAndThen 工厂方法返回的收集器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Dish&gt; mostCaloricByType =</span><br><span class="line">	menu.stream()</span><br><span class="line">        .collect(groupingBy(Dish::getType,</span><br><span class="line">        	collectingAndThen(</span><br><span class="line">            maxBy(comparingInt(Dish::getCalories)),</span><br><span class="line">            Optional::get)));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Integer&gt; totalCaloriesByType =</span><br><span class="line">    menu.stream().collect(groupingBy(Dish::getType,</span><br><span class="line">    summingInt(Dish::getCalories)));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Set&lt;CaloricLevel&gt;&gt; caloricLevelsByType =</span><br><span class="line">    menu.stream().collect(</span><br><span class="line">    	groupingBy(Dish::getType, mapping(</span><br><span class="line">    	dish -&gt; &#123; <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT; &#125;,</span><br><span class="line">        toSet() )));</span><br></pre></td></tr></table></figure>
<p>注意在上一个示例中，对于返回的 Set 是什么类型并没有任何保证。但通过使用 toCollection ，你就可以有更多的控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Set&lt;CaloricLevel&gt;&gt; caloricLevelsByType =</span><br><span class="line">    menu.stream().collect(</span><br><span class="line">    groupingBy(Dish::getType, mapping(</span><br><span class="line">    dish -&gt; &#123; <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT; &#125;,</span><br><span class="line">    toCollection(HashSet::<span class="keyword">new</span>) )));</span><br></pre></td></tr></table></figure>
<h5 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h5><p>它是分组的特殊情况：由一个谓词（返回布尔值的函数）作为分类函数，称为分区函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Dish&gt;&gt; partitionedMenu =</span><br><span class="line">                menu.stream()</span><br><span class="line">                      .collect(partitioningBy(Dish::isVegetarian));</span><br><span class="line"></span><br><span class="line">List&lt;Dish&gt; vegetarianDishes = partitionedMenu.get(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>分区的好处在于保留了分区函数返回 true 或 false 的两套流元素列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, Dish&gt; mostCaloricPartitionedByVegetarian =</span><br><span class="line">	menu.stream().collect(</span><br><span class="line">        partitioningBy(Dish::isVegetarian,</span><br><span class="line">        collectingAndThen(</span><br><span class="line">        maxBy(comparingInt(Dish::getCalories)),</span><br><span class="line">        Optional::get)));</span><br></pre></td></tr></table></figure>
<p>可以仿造groupingBy多级分区。</p>
<p><img src="http://ww1.sinaimg.cn/large/005wR1ytgy1fx53bfox7aj30wg0cqmyx.jpg" alt=""><br><img src="http://ww1.sinaimg.cn/large/005wR1ytgy1fx53bfsibxj30v00tdn2l.jpg" alt=""></p>
<h3 id="收集器接口"><a href="#收集器接口" class="headerlink" title="收集器接口"></a>收集器接口</h3><p>可为collector接口提供自己的实现，从而自由地创建自定义归约操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Supplier&lt;A&gt; <span class="title">supplier</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">BiConsumer&lt;A, T&gt; <span class="title">accumulator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Function&lt;A, R&gt; <span class="title">finisher</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">BinaryOperator&lt;A&gt; <span class="title">combiner</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h3><p>对顺序流调用parallel方法，并不意味着流本身有任何实际的变化。它在内部实际上就是设了一个 boolean 标志，表示你想让调用 parallel 之后进行的所有操作都并行执行。</p>
<p>并行流内部使用了默认的ForkJoinPool，它默认的线程数量是处理器的数量，可由Runtime.getRuntime().availableProcessors()得到。</p>
<p><strong>避免共享可变状态，确保并行 Stream 得到正确的结果。</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/005wR1ytgy1fx54gljrqpj30ua08rdg5.jpg" alt=""></p>
<p>并行流无需显式地处理线程和同步问题。</p>
<h4 id="自定义Spliterator"><a href="#自定义Spliterator" class="headerlink" title="自定义Spliterator"></a>自定义Spliterator</h4><p>因为原始的 String 在任意位置拆分，所以有时一个词会被分为两个词，然后数了两次。这就说明，拆分流会影响结果，而把顺序流换成并行流就可能使结果出错。</p>
<p>如何解决这个问题呢？解决方案就是要确保 String 不是在随机位置拆开的，而只能在尾<br>拆开。要做到这一点，你必须为 Character 实现一个 Spliterator ，它只能在两个词之间拆开String （如下所示），然后由此创建并行流。</p>
<h3 id="Optional替代Null"><a href="#Optional替代Null" class="headerlink" title="Optional替代Null"></a>Optional替代Null</h3><h4 id="如何为缺失的对象建模？"><a href="#如何为缺失的对象建模？" class="headerlink" title="如何为缺失的对象建模？"></a>如何为缺失的对象建模？</h4><p>Optional：当变量存在时，Optional类只是对类的简单封装。当变量不存在时，缺失的值被建模成一个“空”的Optional对象，由方法Optional.empty返回。 Optional.empty() 方法是一个静态工厂方法，它返回 Optional 类的特定单一实例。</p>
<p>Optional.empty()用处：</p>
<p><img src="http://ww1.sinaimg.cn/large/005wR1ytgy1fx5b99awl1j30t60b3mym.jpg" alt=""></p>
<h4 id="应用Optional"><a href="#应用Optional" class="headerlink" title="应用Optional"></a>应用Optional</h4><h5 id="创建Optional对象："><a href="#创建Optional对象：" class="headerlink" title="创建Optional对象："></a>创建Optional对象：</h5><ol>
<li><p>声明一个空的Optional</p>
<p><code>Optional&lt;Car&gt; optCar= Optional.empty();</code></p>
</li>
<li><p>依据一个非空值创建Optional</p>
<p><code>Optional&lt;Car&gt; optCar = Optional.of(car);</code></p>
<p>若car是null，抛出NPE。</p>
</li>
<li><p>可接受null的Optional</p>
<p><code>Optional&lt;Car&gt; optCar = Optional.ofNullable(car);</code>    </p>
</li>
</ol>
<p>Optional提供的get方法在遭遇空的Optional对象时，也会抛出异常。</p>
<p>怎么办？</p>
<h5 id="使用map从Optional对象中提取和转换值"><a href="#使用map从Optional对象中提取和转换值" class="headerlink" title="使用map从Optional对象中提取和转换值"></a>使用map从Optional对象中提取和转换值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getCarInsuranceName</span><span class="params">(Optional&lt;Person&gt; person)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> person.flatMap(Person::getCar)</span><br><span class="line">        .flatMap(Car::getInsurance)</span><br><span class="line">        .map(Insurance::getName)</span><br><span class="line">        .orElse(<span class="string">"Unknown"</span>); <span class="comment">// Optional为空时，设置默认值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 Optional 类设计时就没特别考虑将其作为类的字段使用，所以它也并未实现<br>Serializable 接口。</p>
<p>若要实现序列化的域模型，作为替代方案，提供一个能访问声明为 Optional 、变量值可能缺失的接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Car car;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;Car&gt; <span class="title">getCarAsOptional</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> Optional.ofNullable(car);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CompleptableFuture-组合式异步编程"><a href="#CompleptableFuture-组合式异步编程" class="headerlink" title="CompleptableFuture:组合式异步编程"></a>CompleptableFuture:组合式异步编程</h3><h4 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h4><p>它设计初衷是为将来某个时刻会发生的结果进行建模。</p>
<p><img src="http://ww1.sinaimg.cn/large/005wR1ytgy1fx5deji7d2j30q90ao0um.jpg" alt=""></p>
<p>这种编程方式让你的线程可以在 ExecutorService 以并发方式调用另一个线程执行耗时操作的同时，去执行一些其他的任务。接着，如果你已经运行到没有异步操作的结果就无法继续任何有意义的工作时，可以调用它的 get 方法去获取操作的结果。如果操<br>作已经完成，该方法会立刻返回操作的结果，否则它会阻塞你的线程，直到操作完成，返回相应的结果。</p>
<p>Future 接口的局限性：很难表述 Future 结果之间的依赖性。</p>
<p>于是CompletableFuture，CompletableFuture 和 Future 的关系就跟 Stream 和 Collection 的关系一样。</p>
<h4 id="使用-CompletableFuture-构建异步应用"><a href="#使用-CompletableFuture-构建异步应用" class="headerlink" title="使用 CompletableFuture 构建异步应用"></a>使用 CompletableFuture 构建异步应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Double&gt; <span class="title">getPriceAsync</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">	CompletableFuture&lt;Double&gt; futurePrice = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    <span class="keyword">new</span> Thread( () -&gt; &#123;</span><br><span class="line">    <span class="keyword">double</span> price = calculatePrice(product);</span><br><span class="line">    futurePrice.complete(price);</span><br><span class="line">    &#125;).start();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无需等待尚未结束的计算，直接返回Future对象</span></span><br><span class="line">    <span class="keyword">return</span> futurePrice;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用工厂方法-supplyAsync-创建-CompletableFuture"><a href="#使用工厂方法-supplyAsync-创建-CompletableFuture" class="headerlink" title="使用工厂方法 supplyAsync 创建 CompletableFuture"></a>使用工厂方法 supplyAsync 创建 CompletableFuture</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;Double&gt; <span class="title">getPriceAsync</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.supplyAsync(() -&gt; calculatePrice(product));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>supplyAsync 方法接受一个生产者（ Supplier ）作为参数，返回一个CompletableFuture对象，该对象完成异步执行后会读取调用生产者方法的返回值。</p>
<p>生产者方法会交由 ForkJoinPool池中的某个执行线程（ Executor ）运行，但是你也可以使用 supplyAsync 方法的重载版本，传递第二个参数指定不同的执行线程执行生产者方法。一般而言，向 CompletableFuture 的工厂方法传递可选参数，指定生产者方法的执行线程是可行的。</p>
<h5 id="使用-CompletableFuture-发起异步请求"><a href="#使用-CompletableFuture-发起异步请求" class="headerlink" title="使用 CompletableFuture 发起异步请求"></a>使用 CompletableFuture 发起异步请求</h5><p><img src="http://ww1.sinaimg.cn/large/005wR1ytgy1fx5drh2b6uj30u608k3zg.jpg" alt=""></p>
<p>这里使用两个不同的Stream流水线的原因是：流操作之间存在延迟。如果在单一的流水线中处理流，发向不同商家的请求只能以同步、顺序执行的方式才会成功。</p>
<h3 id="寻找更好的方案"><a href="#寻找更好的方案" class="headerlink" title="寻找更好的方案"></a>寻找更好的方案</h3><p> 当任务数超过四个时，定制执行器。</p>
<p>N(threads) = N(CPU) <em> U(CPU) </em> (1 + W/C)<br>其中：</p>
<ul>
<li>N CPU 是处理器的核的数目，可以通过 Runtime.getRuntime().availableProce-<br>ssors() 得到</li>
<li>U CPU 是期望的CPU利用率（该值应该介于0和1之间）</li>
<li>W/C是等待时间与计算时间的比率</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor executor =</span><br><span class="line">    Executors.newFixedThreadPool(Math.min(shops.size(), <span class="number">100</span>),</span><br><span class="line">        <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">            t.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>Java程序无法终止或者退出一个正在运行中的线程，所以最后剩下的那个线程会由于一直等待无法发生的事件而引发问题。与此相反，如果将线程标记为守护进程，意味着程序退出时它也会被回收。这二者之间没有性能上的差异。</p>
<h4 id="并行——使用流还是-CompletableFutures-？"><a href="#并行——使用流还是-CompletableFutures-？" class="headerlink" title="并行——使用流还是 CompletableFutures ？"></a>并行——使用流还是 CompletableFutures ？</h4><ul>
<li>如果进行的是计算密集型的操作，并且没有IO，推荐使用Stream接口，因为实现简单，同时效率也可能是最高的（如果所有线程都是计算密集型，根据以上估算公式，就没有必要创建比处理器核数更多的线程）。</li>
<li>反之，如果你并行的工作单元还涉及等待I/O的操作（包括网络连接等待），那么使用CompletableFuture 灵活性更好，你可以像前文讨论的那样，依据等待/计算，或者W/C的比率设定需要使用的线程数。这种情况不使用并行流的另一个原因是，处理流的流水线中如果发生I/O等待，流的延迟特性会让我们很难判断到底什么时候触发了等待。</li>
</ul>
<h4 id="对多个异步任务进行流水线操作"><a href="#对多个异步任务进行流水线操作" class="headerlink" title="对多个异步任务进行流水线操作"></a>对多个异步任务进行流水线操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findDiscountFuture</span><span class="params">(String product)</span> </span>&#123;</span><br><span class="line">        List&lt;CompletableFuture&lt;String&gt;&gt; futureList = shops.stream()</span><br><span class="line">                .map(shop -&gt;</span><br><span class="line">                        CompletableFuture.supplyAsync(</span><br><span class="line">                                () -&gt; shop.getName() + <span class="string">" price is "</span> + shop.getPrice(product),executor))</span><br><span class="line">                .map(future -&gt; future.thenApply(Quote::parse))</span><br><span class="line">                .map(future -&gt; future.thenCompose(quote -&gt;</span><br><span class="line">                        CompletableFuture.supplyAsync(</span><br><span class="line">                                () -&gt; Discount.applyDiscount(quote), executor)))</span><br><span class="line">                .collect(toList());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> futureList.stream()</span><br><span class="line">                .map(CompletableFuture::join)</span><br><span class="line">                .collect(toList());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>thenCompose方法允许对两个异步操作进行流水线，第一个操作完成时，将其结果作为参数传递给第二个操作。换句话说，即创建两个CompletableFuture对象调用thenCompose，并向其传递一个Function。当第一个CompletableFuture执行完毕后，它的结果结果将作为该函数的参数， 这个函数返回值是以第一个 CompletableFuture 的返回做输入计算出的第二个 CompletableFuture 对象。</p>
<p> thenCompose 方法像 CompletableFuture 类中的其他方法一<br>样，也提供了一个以 Async 后缀结尾的版本 thenComposeAsync 。通常而言，名称中不带 Async的方法和它的前一个任务一样，在同一个线程中运行；而名称以 Async 结尾的方法会将后续的任务提交到一个线程池，所以每个任务是由不同的线程处理的。就这个例子而言，第二个CompletableFuture 对象的结果取决于第一个CompletableFuture ，所以无论你使用哪个版本的方法来处理 CompletableFuture 对象，对于最终的结果，或者大致的时间而言都没有多少差别。我们选择 thenCompose 方法的原因是因为它更高效一些，因为少了很多线程切换的开销。</p>
<p>主线程还能执行其它重要的操作，如响应UI。</p>
<p>另一种比较常见的情况是，你需要将两个完全不相干的 CompletableFuture 对象的结果整合起来，而且你也不希望等到第一个任务完全结束才开始第二项任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Double&gt; futurePriceInUSD =</span><br><span class="line">    CompletableFuture.supplyAsync(() -&gt; shop.getPrice(product))</span><br><span class="line">    .thenCombine(</span><br><span class="line">    	CompletableFuture.supplyAsync(</span><br><span class="line">    		() -&gt; exchangeService.getRate(Money.EUR, Money.USD)),</span><br><span class="line">    		(price, rate) -&gt; price * rate</span><br><span class="line">   	 	);</span><br></pre></td></tr></table></figure>
<p>这里thenCombine方法，它接受BiFunction作为第二个参数，这个参数定义了两个CompletableFuture 对象完成计算后，如何合并结果。它的Async版本是：导致BiFunction中定义的合并操作被提交到线程池中，由另一个任务以异步的方式执行。<strong>其中的两个CompletableFuture 对象是在不同的线程执行的。</strong></p>
<p><strong>CompletableFuture 利用Lambda表达式以声明式的API提供了一种机制，能够用最有效的方式，非常容易地将多个以同步或异步方式执行复杂操作的任务结合到一起。</strong></p>
<h4 id="响应-CompletableFuture-的-completion-事件"><a href="#响应-CompletableFuture-的-completion-事件" class="headerlink" title="响应 CompletableFuture 的 completion 事件"></a>响应 CompletableFuture 的 completion 事件</h4><p>避免的首要的问题是，等待创建一个包含了所有价格的List创建完成。应该直接处理CompletableFuture。这样每个 CompletableFuture 都在为某个商店执行必要的操<br>作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Stream&lt;CompletableFuture&lt;String&gt;&gt; findDiscountStream(String product) &#123;</span><br><span class="line">        <span class="keyword">return</span> shops.stream()</span><br><span class="line">                .map(shop -&gt;</span><br><span class="line">                        CompletableFuture.supplyAsync(</span><br><span class="line">                                () -&gt; shop.getName() + <span class="string">" price is "</span> + shop.getPrice(product),</span><br><span class="line">                                executor))</span><br><span class="line">                .map(future -&gt; future.thenApply(Quote::parse))</span><br><span class="line">                .map(future -&gt; future.thenCompose(quote -&gt;</span><br><span class="line">                        CompletableFuture.supplyAsync(</span><br><span class="line">                                () -&gt; Discount.applyDiscount(quote), executor)));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">findPricesStream(<span class="string">"myPhone"</span>).map(f -&gt; f.thenAccept(System.out::println));</span><br></pre></td></tr></table></figure>
<p>thenAccept方法也有Async版本。异步版本会对处理结果的消费者进行调度，从线程池中选择一个新的线程继续执行，不再由同一个线程完成CompletableFuture的所有任务。</p>
<p>如果想避免不必要的上下文切换，避免在等待线程上浪费时间，尽快响应CompletableFuture的completion事件，可以不使用异步版本。</p>
<p>由于 thenAccept 方法已经定义了如何处理 CompletableFuture 返回的结果，一旦<br>CompletableFuture 计算得到结果，它就返回一个<code>CompletableFuture&lt;Void&gt;</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture[] futures = findPricesStream(<span class="string">"myPhone"</span>)</span><br><span class="line">    .map(f -&gt; f.thenAccept(System.out::println))</span><br><span class="line">    .toArray(size -&gt; <span class="keyword">new</span> CompletableFuture[size]);</span><br><span class="line">CompletableFuture.allOf(futures).join();</span><br></pre></td></tr></table></figure>
<p>allOf 工厂方法接收一个由 CompletableFuture 构成的数组，数组中的所有CompletableFuture 对象执行完成之后，它返回一个<code>CompletableFuture&lt;Void&gt;</code> 对象。这意味着，如果你需要等待最初 Stream 中的所有 CompletableFuture 对象执行完毕，对 allOf 方法返回的CompletableFuture 执行 join 操作是个不错的主意。</p>
<p>然而在另一些场景中，你可能希望只要 CompletableFuture 对象数组中有任何一个执行完毕就不再等待，比如，你正在查询两个汇率服务器，任何一个返回了结果都能满足你的需求。在这种情况下，你可以使用一个类似的工厂方法 anyOf 。该方法接收一个 CompletableFuture 对象构成的数组，返回由第一个执行完毕的 CompletableFuture 对象的返回值构成的<code>CompletableFuture&lt;Object&gt;</code> 。</p>
<h3 id="新的日期和时间API"><a href="#新的日期和时间API" class="headerlink" title="新的日期和时间API"></a>新的日期和时间API</h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/02/python/fluentpy2/" rel="next" title="FluentPy Note（2）">
                <i class="fa fa-chevron-left"></i> FluentPy Note（2）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/11/20/python/problem/" rel="prev" title="Python编程中邂逅的问题">
                Python编程中邂逅的问题 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
   <div id="gitalk-container"></div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Peng</p>
              <p class="site-description motion-element" itemprop="description">Github Personal Website</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda"><span class="nav-number">1.</span> <span class="nav-text">Lambda</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#函数式接口"><span class="nav-number">1.1.</span> <span class="nav-text">函数式接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用函数式接口"><span class="nav-number">1.2.</span> <span class="nav-text">使用函数式接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原始类型特化"><span class="nav-number">1.3.</span> <span class="nav-text">原始类型特化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型检查、类型推断以及限制"><span class="nav-number">2.</span> <span class="nav-text">类型检查、类型推断以及限制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#类型推断"><span class="nav-number">2.1.</span> <span class="nav-text">类型推断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法引用"><span class="nav-number">3.</span> <span class="nav-text">方法引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复合Lambda表达式的有用方法"><span class="nav-number">4.</span> <span class="nav-text">复合Lambda表达式的有用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#比较器复合"><span class="nav-number">4.1.</span> <span class="nav-text">比较器复合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#比较器链"><span class="nav-number">4.2.</span> <span class="nav-text">比较器链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#谓词复合"><span class="nav-number">4.3.</span> <span class="nav-text">谓词复合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数复合"><span class="nav-number">4.4.</span> <span class="nav-text">函数复合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流"><span class="nav-number">5.</span> <span class="nav-text">流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内部迭代与外部迭代"><span class="nav-number">5.1.</span> <span class="nav-text">内部迭代与外部迭代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#中间操作"><span class="nav-number">5.2.</span> <span class="nav-text">中间操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#终端操作"><span class="nav-number">5.3.</span> <span class="nav-text">终端操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用流"><span class="nav-number">5.4.</span> <span class="nav-text">使用流</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#筛选和切片"><span class="nav-number">6.</span> <span class="nav-text">筛选和切片</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用谓词筛选"><span class="nav-number">6.1.</span> <span class="nav-text">用谓词筛选</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#截短流"><span class="nav-number">6.2.</span> <span class="nav-text">截短流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#跳过元素"><span class="nav-number">6.3.</span> <span class="nav-text">跳过元素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#映射"><span class="nav-number">7.</span> <span class="nav-text">映射</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#流的扁平化"><span class="nav-number">7.1.</span> <span class="nav-text">流的扁平化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查找和匹配"><span class="nav-number">7.2.</span> <span class="nav-text">查找和匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#短路求值"><span class="nav-number">7.2.1.</span> <span class="nav-text">短路求值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#归约"><span class="nav-number">7.3.</span> <span class="nav-text">归约</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#算术"><span class="nav-number">7.3.1.</span> <span class="nav-text">算术</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#最值"><span class="nav-number">7.3.2.</span> <span class="nav-text">最值</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#原始类型流特化"><span class="nav-number">7.4.</span> <span class="nav-text">原始类型流特化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#映射到数值流"><span class="nav-number">7.4.1.</span> <span class="nav-text">映射到数值流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#转换回对象流"><span class="nav-number">7.4.2.</span> <span class="nav-text">转换回对象流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数值范围"><span class="nav-number">7.4.3.</span> <span class="nav-text">数值范围</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#构建流"><span class="nav-number">8.</span> <span class="nav-text">构建流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#由值创建流"><span class="nav-number">8.1.</span> <span class="nav-text">由值创建流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#由数组创建流"><span class="nav-number">8.2.</span> <span class="nav-text">由数组创建流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#由文件生成流"><span class="nav-number">8.3.</span> <span class="nav-text">由文件生成流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#由函数生成流：创建无限流"><span class="nav-number">8.4.</span> <span class="nav-text">由函数生成流：创建无限流</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用流-lt-收集-gt-数据"><span class="nav-number">9.</span> <span class="nav-text">用流&lt;收集&gt;数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#预定义收集器"><span class="nav-number">9.1.</span> <span class="nav-text">预定义收集器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#归约和汇总"><span class="nav-number">9.2.</span> <span class="nav-text">归约和汇总</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#查找流中的最大值和最小值"><span class="nav-number">9.2.1.</span> <span class="nav-text">查找流中的最大值和最小值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#汇总"><span class="nav-number">9.2.2.</span> <span class="nav-text">汇总</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#连接字符串"><span class="nav-number">9.2.3.</span> <span class="nav-text">连接字符串</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#广义的归约汇总"><span class="nav-number">9.3.</span> <span class="nav-text">广义的归约汇总</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#以下开始发挥collect的作用"><span class="nav-number">9.4.</span> <span class="nav-text">以下开始发挥collect的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#分组"><span class="nav-number">9.4.1.</span> <span class="nav-text">分组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#分区"><span class="nav-number">9.4.2.</span> <span class="nav-text">分区</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#收集器接口"><span class="nav-number">10.</span> <span class="nav-text">收集器接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并行流"><span class="nav-number">11.</span> <span class="nav-text">并行流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义Spliterator"><span class="nav-number">11.1.</span> <span class="nav-text">自定义Spliterator</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Optional替代Null"><span class="nav-number">12.</span> <span class="nav-text">Optional替代Null</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#如何为缺失的对象建模？"><span class="nav-number">12.1.</span> <span class="nav-text">如何为缺失的对象建模？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#应用Optional"><span class="nav-number">12.2.</span> <span class="nav-text">应用Optional</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#创建Optional对象："><span class="nav-number">12.2.1.</span> <span class="nav-text">创建Optional对象：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用map从Optional对象中提取和转换值"><span class="nav-number">12.2.2.</span> <span class="nav-text">使用map从Optional对象中提取和转换值</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CompleptableFuture-组合式异步编程"><span class="nav-number">13.</span> <span class="nav-text">CompleptableFuture:组合式异步编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Future接口"><span class="nav-number">13.1.</span> <span class="nav-text">Future接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-CompletableFuture-构建异步应用"><span class="nav-number">13.2.</span> <span class="nav-text">使用 CompletableFuture 构建异步应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#使用工厂方法-supplyAsync-创建-CompletableFuture"><span class="nav-number">13.2.1.</span> <span class="nav-text">使用工厂方法 supplyAsync 创建 CompletableFuture</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用-CompletableFuture-发起异步请求"><span class="nav-number">13.2.2.</span> <span class="nav-text">使用 CompletableFuture 发起异步请求</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#寻找更好的方案"><span class="nav-number">14.</span> <span class="nav-text">寻找更好的方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#并行——使用流还是-CompletableFutures-？"><span class="nav-number">14.1.</span> <span class="nav-text">并行——使用流还是 CompletableFutures ？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对多个异步任务进行流水线操作"><span class="nav-number">14.2.</span> <span class="nav-text">对多个异步任务进行流水线操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#响应-CompletableFuture-的-completion-事件"><span class="nav-number">14.3.</span> <span class="nav-text">响应 CompletableFuture 的 completion 事件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新的日期和时间API"><span class="nav-number">15.</span> <span class="nav-text">新的日期和时间API</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Peng</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
   <script type="text/javascript">
        var gitalk = new Gitalk({
          clientID: 'f65636121bc2964d8103',
          clientSecret: 'a11700e292b326c942651a636f32c28e525f2829',
          repo: 'langzi418.github.io',
          owner: 'Langzi418',
          admin: ['Langzi418'],
          id: location.pathname,
          distractionFreeMode: 'true'
        })
        gitalk.render('gitalk-container')
       </script>




  





  

  

  

  
  

  

  

  

</body>
</html>
